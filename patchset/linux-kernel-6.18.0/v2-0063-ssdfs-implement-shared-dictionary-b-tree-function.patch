From 0991b5cd551bfef76b4bbcf599d64954a93fd028 Mon Sep 17 00:00:00 2001
From: Viacheslav Dubeyko <slava@dubeyko.com>
Date: Mon, 2 Feb 2026 21:48:52 -0800
Subject: [PATCH v2 63/79] ssdfs: implement shared dictionary b-tree
 functionality

This patch implements shared dictionary b-tree functionality.

Signed-off-by: Viacheslav Dubeyko <slava@dubeyko.com>
---
 fs/ssdfs/shared_dictionary.c        | 21342 ++++++++++++++++++++++++++
 fs/ssdfs/shared_dictionary_thread.c |   457 +
 2 files changed, 21799 insertions(+)
 create mode 100644 fs/ssdfs/shared_dictionary.c
 create mode 100644 fs/ssdfs/shared_dictionary_thread.c

diff --git a/fs/ssdfs/shared_dictionary.c b/fs/ssdfs/shared_dictionary.c
new file mode 100644
index 000000000000..a6176466e03d
--- /dev/null
+++ b/fs/ssdfs/shared_dictionary.c
@@ -0,0 +1,21342 @@
+/*
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ *
+ * SSDFS -- SSD-oriented File System.
+ *
+ * fs/ssdfs/shared_dictionary.c - shared dictionary btree implementation.
+ *
+ * Copyright (c) 2014-2019 HGST, a Western Digital Company.
+ *              http://www.hgst.com/
+ * Copyright (c) 2014-2026 Viacheslav Dubeyko <slava@dubeyko.com>
+ *              http://www.ssdfs.org/
+ *
+ * (C) Copyright 2014-2019, HGST, Inc., All rights reserved.
+ *
+ * Created by HGST, San Jose Research Center, Storage Architecture Group
+ *
+ * Authors: Viacheslav Dubeyko <slava@dubeyko.com>
+ *
+ * Acknowledgement: Cyril Guyot
+ *                  Zvonimir Bandic
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pagevec.h>
+
+#include "peb_mapping_queue.h"
+#include "peb_mapping_table_cache.h"
+#include "folio_vector.h"
+#include "ssdfs.h"
+#include "btree_search.h"
+#include "btree_node.h"
+#include "btree.h"
+#include "shared_dictionary.h"
+
+#ifdef CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING
+atomic64_t ssdfs_dict_folio_leaks;
+atomic64_t ssdfs_dict_memory_leaks;
+atomic64_t ssdfs_dict_cache_leaks;
+#endif /* CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING */
+
+/*
+ * void ssdfs_dict_cache_leaks_increment(void *kaddr)
+ * void ssdfs_dict_cache_leaks_decrement(void *kaddr)
+ * void *ssdfs_dict_kmalloc(size_t size, gfp_t flags)
+ * void *ssdfs_dict_kzalloc(size_t size, gfp_t flags)
+ * void *ssdfs_dict_kcalloc(size_t n, size_t size, gfp_t flags)
+ * void ssdfs_dict_kfree(void *kaddr)
+ * struct folio *ssdfs_dict_alloc_folio(gfp_t gfp_mask,
+ *                                      unsigned int order)
+ * struct folio *ssdfs_dict_add_batch_folio(struct folio_batch *batch,
+ *                                          unsigned int order)
+ * void ssdfs_dict_free_folio(struct folio *folio)
+ * void ssdfs_dict_folio_batch_release(struct folio_batch *batch)
+ */
+#ifdef CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING
+	SSDFS_MEMORY_LEAKS_CHECKER_FNS(dict)
+#else
+	SSDFS_MEMORY_ALLOCATOR_FNS(dict)
+#endif /* CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING */
+
+void ssdfs_dict_memory_leaks_init(void)
+{
+#ifdef CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING
+	atomic64_set(&ssdfs_dict_folio_leaks, 0);
+	atomic64_set(&ssdfs_dict_memory_leaks, 0);
+	atomic64_set(&ssdfs_dict_cache_leaks, 0);
+#endif /* CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING */
+}
+
+void ssdfs_dict_check_memory_leaks(void)
+{
+#ifdef CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING
+	if (atomic64_read(&ssdfs_dict_folio_leaks) != 0) {
+		SSDFS_ERR("SHARED DICTIONARY: "
+			  "memory leaks include %lld folios\n",
+			  atomic64_read(&ssdfs_dict_folio_leaks));
+	}
+
+	if (atomic64_read(&ssdfs_dict_memory_leaks) != 0) {
+		SSDFS_ERR("SHARED DICTIONARY: "
+			  "memory allocator suffers from %lld leaks\n",
+			  atomic64_read(&ssdfs_dict_memory_leaks));
+	}
+
+	if (atomic64_read(&ssdfs_dict_cache_leaks) != 0) {
+		SSDFS_ERR("SHARED DICTIONARY: "
+			  "caches suffers from %lld leaks\n",
+			  atomic64_read(&ssdfs_dict_cache_leaks));
+	}
+#endif /* CONFIG_SSDFS_MEMORY_LEAKS_ACCOUNTING */
+}
+
+typedef int (*get_search_key_func_t)(struct ssdfs_btree_node *node,
+				     u16 index,
+				     union ssdfs_shdict_search_key *value);
+
+static inline
+void ssdfs_check_shdict_btree_node_area(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_node_index_area *hash_tbl,
+				struct ssdfs_btree_node_index_area *lookup_tbl,
+				struct ssdfs_btree_node_items_area *items_area,
+				u16 index_count,
+				u64 start_hash, u64 end_hash,
+				get_search_key_func_t get_key);
+static inline
+void ssdfs_debug_show_areas_state(struct ssdfs_btree_node *node,
+				  struct ssdfs_btree_node_index_area *hash_tbl,
+				  struct ssdfs_btree_node_index_area *lookup_tbl,
+				  struct ssdfs_btree_node_items_area *items_area);
+
+#ifdef CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK
+static
+void ssdfs_check_shdict_btree_node_consistency(struct ssdfs_btree_node *node);
+#endif /* CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK */
+
+/******************************************************************************
+ *                         NAME INFO FUNCTIONALITY                            *
+ ******************************************************************************/
+
+static struct kmem_cache *ssdfs_name_info_cachep;
+
+void ssdfs_zero_name_info_cache_ptr(void)
+{
+	ssdfs_name_info_cachep = NULL;
+}
+
+static
+void ssdfs_init_name_info_once(void *obj)
+{
+	struct ssdfs_name_info *ni_obj = obj;
+
+	memset(ni_obj, 0, sizeof(struct ssdfs_name_info));
+}
+
+void ssdfs_destroy_name_info_cache(void)
+{
+	if (ssdfs_name_info_cachep)
+		kmem_cache_destroy(ssdfs_name_info_cachep);
+}
+
+int ssdfs_init_name_info_cache(void)
+{
+	ssdfs_name_info_cachep = kmem_cache_create("ssdfs_name_info_cache",
+					sizeof(struct ssdfs_name_info), 0,
+					SLAB_RECLAIM_ACCOUNT | SLAB_ACCOUNT,
+					ssdfs_init_name_info_once);
+	if (!ssdfs_name_info_cachep) {
+		SSDFS_ERR("unable to create name info objects cache\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_name_info_alloc() - allocate memory for name info object
+ */
+struct ssdfs_name_info *ssdfs_name_info_alloc(void)
+{
+	struct ssdfs_name_info *ptr;
+	unsigned int nofs_flags;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!ssdfs_name_info_cachep);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	nofs_flags = memalloc_nofs_save();
+	ptr = kmem_cache_alloc(ssdfs_name_info_cachep, GFP_KERNEL);
+	memalloc_nofs_restore(nofs_flags);
+
+	if (!ptr) {
+		SSDFS_ERR("fail to allocate memory for name\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return ptr;
+}
+
+/*
+ * ssdfs_name_info_free() - free memory for name info object
+ */
+void ssdfs_name_info_free(struct ssdfs_name_info *ni)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!ssdfs_name_info_cachep);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!ni)
+		return;
+
+	kmem_cache_free(ssdfs_name_info_cachep, ni);
+}
+
+/*
+ * ssdfs_name_info_init() - name info initialization
+ * @type: operation type
+ * @hash: name hash
+ * @str: name string
+ * @len: name length
+ * @ni: name info [out]
+ */
+void ssdfs_name_info_init(int type, u64 hash,
+			  const unsigned char *str,
+			  const size_t len,
+			  struct ssdfs_name_info *ni)
+{
+	size_t copy_len;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!str || !ni);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	memset(ni, 0, sizeof(struct ssdfs_name_info));
+
+	INIT_LIST_HEAD(&ni->list);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(type <= SSDFS_INIT_SHDICT_NODE ||
+		type >= SSDFS_NAME_OP_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+	ni->type = type;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(hash >= U64_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+	ni->desc.name.hash = hash;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(len > SSDFS_MAX_NAME_LEN);
+#endif /* CONFIG_SSDFS_DEBUG */
+	copy_len = min_t(size_t, len, SSDFS_MAX_NAME_LEN);
+	ni->desc.name.len = copy_len;
+
+	ssdfs_memcpy(ni->desc.name.str_buf, 0, SSDFS_MAX_NAME_LEN,
+		     str, 0, len,
+		     copy_len);
+}
+
+/*
+ * ssdfs_node_index_init() - node init info initialization
+ * @type: operation type
+ * @hash: name hash
+ * @str: name string
+ * @len: name length
+ * @ni: name info [out]
+ */
+void ssdfs_node_index_init(int type, struct ssdfs_btree_index *index,
+			   struct ssdfs_name_info *ni)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!index || !ni);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	memset(ni, 0, sizeof(struct ssdfs_name_info));
+
+	INIT_LIST_HEAD(&ni->list);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(type != SSDFS_INIT_SHDICT_NODE);
+#endif /* CONFIG_SSDFS_DEBUG */
+	ni->type = type;
+
+	ssdfs_memcpy(&ni->desc.index,
+		     0, sizeof(struct ssdfs_btree_index),
+		     index, 0, sizeof(struct ssdfs_btree_index),
+		     sizeof(struct ssdfs_btree_index));
+}
+
+/******************************************************************************
+ *                         NAMES QUEUE FUNCTIONALITY                          *
+ ******************************************************************************/
+
+/*
+ * ssdfs_names_queue_init() - initialize names queue
+ * @nq: initialized names queue
+ */
+void ssdfs_names_queue_init(struct ssdfs_names_queue *nq)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!nq);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	spin_lock_init(&nq->lock);
+	INIT_LIST_HEAD(&nq->list);
+}
+
+/*
+ * is_ssdfs_names_queue_empty() - check that names queue is empty
+ * @nq: names queue
+ */
+bool is_ssdfs_names_queue_empty(struct ssdfs_names_queue *nq)
+{
+	bool is_empty;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!nq);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	spin_lock(&nq->lock);
+	is_empty = list_empty_careful(&nq->list);
+	spin_unlock(&nq->lock);
+
+	return is_empty;
+}
+
+/*
+ * ssdfs_names_queue_add_head() - add name at the head of queue
+ * @nq: names queue
+ * @ni: name info
+ */
+void ssdfs_names_queue_add_head(struct ssdfs_names_queue *nq,
+				struct ssdfs_name_info *ni)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!nq || !ni);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	spin_lock(&nq->lock);
+	list_add(&ni->list, &nq->list);
+	spin_unlock(&nq->lock);
+}
+
+/*
+ * ssdfs_names_queue_add_tail() - add name at the tail of queue
+ * @nq: names queue
+ * @ni: name info
+ */
+void ssdfs_names_queue_add_tail(struct ssdfs_names_queue *nq,
+				struct ssdfs_name_info *ni)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!nq || !ni);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	spin_lock(&nq->lock);
+	list_add_tail(&ni->list, &nq->list);
+	spin_unlock(&nq->lock);
+}
+
+/*
+ * ssdfs_names_queue_remove_first() - get name and remove from queue
+ * @nq: names queue
+ * @ni: first name [out]
+ *
+ * This function get first name in @nq, remove it from queue
+ * and return as @ni.
+ *
+ * RETURN:
+ * [success] - @ni contains pointer on name.
+ * [failure] - error code:
+ *
+ * %-ENODATA     - queue is empty.
+ * %-ENOENT      - first entry is NULL.
+ */
+int ssdfs_names_queue_remove_first(struct ssdfs_names_queue *nq,
+				   struct ssdfs_name_info **ni)
+{
+	bool is_empty;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!nq || !ni);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	spin_lock(&nq->lock);
+	is_empty = list_empty_careful(&nq->list);
+	if (!is_empty) {
+		*ni = list_first_entry_or_null(&nq->list,
+						struct ssdfs_name_info,
+						list);
+		if (!*ni) {
+			SSDFS_WARN("first entry is NULL\n");
+			err = -ENOENT;
+		} else
+			list_del(&(*ni)->list);
+	}
+	spin_unlock(&nq->lock);
+
+	if (is_empty) {
+		SSDFS_DBG("names queue is empty\n");
+		err = -ENODATA;
+	}
+
+	return err;
+}
+
+/*
+ * ssdfs_names_queue_remove_all() - remove all names from queue
+ * @nq: names queue
+ *
+ * This function removes all names from the queue.
+ */
+void ssdfs_names_queue_remove_all(struct ssdfs_names_queue *nq)
+{
+	bool is_empty;
+	LIST_HEAD(tmp_list);
+	struct list_head *this, *next;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!nq);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	spin_lock(&nq->lock);
+	is_empty = list_empty_careful(&nq->list);
+	if (!is_empty)
+		list_replace_init(&nq->list, &tmp_list);
+	spin_unlock(&nq->lock);
+
+	if (is_empty)
+		return;
+
+	list_for_each_safe(this, next, &tmp_list) {
+		struct ssdfs_name_info *ni;
+
+		ni = list_entry(this, struct ssdfs_name_info, list);
+		list_del(&ni->list);
+
+		switch (ni->type) {
+		case SSDFS_NAME_ADD:
+		case SSDFS_NAME_CHANGE:
+		case SSDFS_NAME_DELETE:
+			SSDFS_WARN("delete name: "
+				   "op_type %#x, hash %llx, len %zu\n",
+				   ni->type,
+				   ni->desc.name.hash,
+				   ni->desc.name.len);
+			break;
+
+		default:
+			SSDFS_WARN("invalid name operation type %#x\n",
+				   ni->type);
+			break;
+		}
+	}
+}
+
+/******************************************************************************
+ *                SHARED DICTIONARY TREE OBJECT FUNCTIONALITY                 *
+ ******************************************************************************/
+
+/*
+ * ssdfs_shared_dict_btree_create() - create shared dictionary btree
+ * @fsi: pointer on shared file system object
+ *
+ * This method tries to create shared dictionary btree object.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-EINVAL     - invalid input.
+ * %-ENOMEM     - unable to allocate memory.
+ * %-ERANGE     - internal error.
+ */
+int ssdfs_shared_dict_btree_create(struct ssdfs_fs_info *fsi)
+{
+	struct ssdfs_shared_dict_btree_info *ptr;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!fsi);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("fsi %p\n", fsi);
+#else
+	SSDFS_DBG("fsi %p\n", fsi);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	fsi->shdictree = NULL;
+
+	ptr = ssdfs_dict_kzalloc(sizeof(struct ssdfs_shared_dict_btree_info),
+				 GFP_KERNEL);
+	if (!ptr) {
+		SSDFS_ERR("fail to allocate shared dictionary tree\n");
+		return -ENOMEM;
+	}
+
+	ptr->fsi = fsi;
+
+	atomic_set(&ptr->state, SSDFS_SHDICT_BTREE_UNKNOWN_STATE);
+
+	err = ssdfs_btree_create(fsi,
+				 SSDFS_SHARED_DICT_BTREE_INO,
+				 &ssdfs_shared_dict_btree_desc_ops,
+				 &ssdfs_shared_dict_btree_ops,
+				 &ptr->generic_tree);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to create shared dictionary tree: err %d\n",
+			  err);
+		goto fail_create_shared_dict_tree;
+	}
+
+	init_rwsem(&ptr->lock);
+	atomic_set(&ptr->read_reqs, 0);
+	init_waitqueue_head(&ptr->wait_queue);
+	ssdfs_names_queue_init(&ptr->requests.queue);
+
+	err = ssdfs_shared_dict_start_thread(ptr);
+	if (err == -EINTR) {
+		/*
+		 * Ignore this error.
+		 */
+		goto destroy_shared_dict_object;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to start shared dictionary tree's thread: "
+			  "err %d\n", err);
+		goto destroy_shared_dict_object;
+	}
+
+	err = ssdfs_sysfs_create_shared_dict_group(fsi);
+	if (err)
+		goto destroy_shared_dict_object;
+
+	atomic_set(&ptr->state, SSDFS_SHDICT_BTREE_CREATED);
+
+	ssdfs_debug_shdict_btree_object(ptr);
+
+	fsi->shdictree = ptr;
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("DONE: create shared dictionary\n");
+#else
+	SSDFS_DBG("DONE: create shared dictionary\n");
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	return 0;
+
+destroy_shared_dict_object:
+	ssdfs_btree_destroy(&ptr->generic_tree);
+
+fail_create_shared_dict_tree:
+	ssdfs_dict_kfree(ptr);
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_destroy - destroy shared dictionary btree
+ * @fsi: file system info object
+ */
+void ssdfs_shared_dict_btree_destroy(struct ssdfs_fs_info *fsi)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!fsi);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("shdictree %p\n", fsi->shdictree);
+#else
+	SSDFS_DBG("shdictree %p\n", fsi->shdictree);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	if (!fsi->shdictree)
+		return;
+
+	ssdfs_sysfs_delete_shared_dict_group(fsi);
+
+	ssdfs_names_queue_remove_all(&fsi->shdictree->requests.queue);
+
+	ssdfs_btree_destroy(&fsi->shdictree->generic_tree);
+	ssdfs_dict_kfree(fsi->shdictree);
+	fsi->shdictree = NULL;
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("finished\n");
+#else
+	SSDFS_DBG("finished\n");
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+}
+
+/*
+ * ssdfs_shared_dict_btree_init - prepare shared dictionary btree init
+ * @fsi: file system info object
+ */
+int ssdfs_shared_dict_btree_init(struct ssdfs_fs_info *fsi)
+{
+	struct ssdfs_shared_dict_btree_info *tree;
+	struct ssdfs_btree_inline_root_node root_node;
+	struct ssdfs_name_info *ni;
+	u8 items_count;
+	int i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!fsi);
+	BUG_ON(!rwsem_is_locked(&fsi->volume_sem));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("shdictree %p\n", fsi->shdictree);
+#else
+	SSDFS_DBG("shdictree %p\n", fsi->shdictree);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	if (!fsi->shdictree)
+		return -ERANGE;
+
+	tree = fsi->shdictree;
+
+	switch (atomic_read(&tree->state)) {
+	case SSDFS_SHDICT_BTREE_CREATED:
+		atomic_set(&tree->state, SSDFS_SHDICT_BTREE_UNDER_INIT);
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_ERR("invalid tree's state %#x\n",
+			  atomic_read(&tree->state));
+		goto finish_init;
+	}
+
+	ssdfs_memcpy(&root_node,
+		     0, sizeof(struct ssdfs_btree_inline_root_node),
+		     &fsi->vs->shared_dict_btree.root_node,
+		     0, sizeof(struct ssdfs_btree_inline_root_node),
+		     sizeof(struct ssdfs_btree_inline_root_node));
+
+	tree->generic_tree.create_cno = 0;
+	items_count = root_node.header.items_count;
+
+	if (items_count == 0) {
+		err = 0;
+		atomic_set(&tree->state, SSDFS_SHDICT_BTREE_INITIALIZED);
+		goto finish_init;
+	} else if (items_count > SSDFS_BTREE_ROOT_NODE_INDEX_COUNT) {
+		err = -EFAULT;
+		SSDFS_WARN("btree's header is corrupted\n");
+		atomic_set(&tree->state, SSDFS_SHDICT_BTREE_CORRUPTED);
+		goto finish_init;
+	}
+
+	for (i = 0; i < items_count; i++) {
+		ni = ssdfs_name_info_alloc();
+		if (IS_ERR_OR_NULL(ni)) {
+			err = !ni ? -ENOMEM : PTR_ERR(ni);
+			SSDFS_ERR("fail to allocate name info: "
+				  "err %d\n", err);
+			goto finish_init;
+		}
+
+		ssdfs_node_index_init(SSDFS_INIT_SHDICT_NODE,
+					&root_node.indexes[i], ni);
+		ssdfs_names_queue_add_tail(&tree->requests.queue, ni);
+	}
+
+finish_init:
+	ssdfs_debug_shdict_btree_object(tree);
+	wake_up_all(&tree->wait_queue);
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("finished: err %d\n", err);
+#else
+	SSDFS_DBG("finished: err %d\n", err);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_read_req_inc() - increase number of read requests
+ * @tree: pointer on shared dictionary btree object
+ */
+static inline
+void ssdfs_shared_dict_read_req_inc(struct ssdfs_shared_dict_btree_info *tree)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	atomic_inc(&tree->read_reqs);
+}
+
+/*
+ * ssdfs_shared_dict_read_req_dec() - decrease number of read requests
+ * @tree: pointer on shared dictionary btree object
+ */
+static inline
+void ssdfs_shared_dict_read_req_dec(struct ssdfs_shared_dict_btree_info *tree)
+{
+	int read_reqs;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	read_reqs = atomic_dec_return(&tree->read_reqs);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(read_reqs < 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (read_reqs == 0)
+		wake_up_all(&tree->wait_queue);
+}
+
+/*
+ * ssdfs_shared_dict_btree_flush() - flush dirty shared dictionary btree
+ * @tree: pointer on shared dictionary btree object
+ *
+ * This method tries to flush the dirty inodes btree.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+int ssdfs_shared_dict_btree_flush(struct ssdfs_shared_dict_btree_info *tree)
+{
+	struct ssdfs_name_requests_queue *ptr;
+	struct ssdfs_btree_search *search;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("tree %p\n", tree);
+#else
+	SSDFS_DBG("tree %p\n", tree);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	if (atomic_read(&tree->state) == SSDFS_SHDICT_BTREE_CORRUPTED) {
+		SSDFS_WARN("shared dictionary is corrupted\n");
+		return -ERANGE;
+	}
+
+	ptr = &tree->requests;
+
+	search = ssdfs_btree_search_alloc();
+	if (!search) {
+		SSDFS_ERR("fail to allocate btree search object\n");
+		return -ENOMEM;
+	}
+
+	down_write(&tree->lock);
+
+	while (has_queue_unprocessed_names(tree)) {
+		struct ssdfs_name_info *ni = NULL;
+
+		err = ssdfs_names_queue_remove_first(&ptr->queue, &ni);
+		if (err == -ENODATA) {
+			err = 0;
+			goto try_to_flush;
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to get name: err %d\n", err);
+			goto finish_flush;
+		} else if (ni == NULL) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid name info\n");
+			goto finish_flush;
+		}
+
+		switch (ni->type) {
+		case SSDFS_NAME_ADD:
+			ssdfs_btree_search_init(search);
+
+			err = ssdfs_shared_dict_tree_add(tree,
+							 ni->desc.name.hash,
+							 ni->desc.name.str_buf,
+							 ni->desc.name.len,
+							 search);
+			if (err == -EEXIST) {
+				/* name exist -> do nothing */
+				err = 0;
+				ssdfs_name_info_free(ni);
+				continue;
+			} else if (unlikely(err)) {
+				ssdfs_fs_error(tree->generic_tree.fsi->sb,
+						__FILE__, __func__, __LINE__,
+						"fail to add name: "
+						"hash %llx, name %s, len %zu, "
+						"err %d\n",
+						ni->desc.name.hash,
+						ni->desc.name.str_buf,
+						ni->desc.name.len,
+						err);
+				ssdfs_name_info_free(ni);
+				goto finish_flush;
+			} else
+				ssdfs_name_info_free(ni);
+			break;
+
+		case SSDFS_NAME_CHANGE:
+		case SSDFS_NAME_DELETE:
+			SSDFS_ERR("unsupported operation: "
+				  "type %#x, hash %llx, len %zu\n",
+				  ni->type, ni->desc.name.hash,
+				  ni->desc.name.len);
+			ssdfs_name_info_free(ni);
+			break;
+
+		default:
+			SSDFS_ERR("invalid operation type: "
+				  "type %#x, hash %llx, len %zu\n",
+				  ni->type, ni->desc.name.hash,
+				  ni->desc.name.len);
+			ssdfs_name_info_free(ni);
+			break;
+		};
+	};
+
+try_to_flush:
+	err = ssdfs_btree_flush(&tree->generic_tree);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to flush shared dictionary btree: "
+			  "err %d\n", err);
+	}
+
+finish_flush:
+	up_write(&tree->lock);
+
+	ssdfs_btree_search_free(search);
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("finished: err %d\n", err);
+#else
+	SSDFS_DBG("finished: err %d\n", err);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	return err;
+}
+
+/*
+ * is_shared_dict_under_init() - check that shared dictionary is initializing
+ */
+static inline
+bool is_shared_dict_under_init(struct ssdfs_shared_dict_btree_info *tree)
+{
+	return atomic_read(&tree->state) == SSDFS_SHDICT_BTREE_UNDER_INIT;
+}
+
+/*
+ * ssdfs_shared_dict_get_name() - get name from dictionary
+ * @tree: shared dictionary tree
+ * @hash: name hash
+ * @name: name buffer
+ *
+ * This method tries to retrieve the name from shared dictionary.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOMEM     - fail to allocate memory.
+ * %-ENODATA    - name doesn't exist in dictionary.
+ */
+int ssdfs_shared_dict_get_name(struct ssdfs_shared_dict_btree_info *tree,
+				u64 hash,
+				struct ssdfs_name_string *name)
+{
+	struct ssdfs_btree_search *search;
+	bool is_second_try = false;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree || !name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("tree %p, hash %llx\n",
+		  tree, hash);
+#else
+	SSDFS_DBG("tree %p, hash %llx\n",
+		  tree, hash);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+try_check_state:
+	switch (atomic_read(&tree->state)) {
+	case SSDFS_SHDICT_BTREE_CREATED:
+	case SSDFS_SHDICT_BTREE_INITIALIZED:
+		/* tree is ready for operations */
+		break;
+
+	case SSDFS_SHDICT_BTREE_UNDER_INIT:
+		if (is_second_try) {
+			SSDFS_ERR("second try to wait the init ending\n");
+			return -ERANGE;
+		} else {
+			DEFINE_WAIT_FUNC(wait, woken_wake_function);
+
+			add_wait_queue(&tree->wait_queue, &wait);
+			while (is_shared_dict_under_init(tree)) {
+				if (signal_pending(current)) {
+					break;
+				} else {
+					wait_woken(&wait, TASK_INTERRUPTIBLE,
+						   SSDFS_DEFAULT_TIMEOUT);
+				}
+			}
+			remove_wait_queue(&tree->wait_queue, &wait);
+		}
+
+		is_second_try = true;
+		goto try_check_state;
+
+	case SSDFS_SHDICT_BTREE_CORRUPTED:
+		SSDFS_WARN("tree is corrupted\n");
+		return -EFAULT;
+
+	default:
+		SSDFS_ERR("invalid tree's state %#x\n",
+			  atomic_read(&tree->state));
+		return -ERANGE;
+	}
+
+	memset(name, 0, sizeof(struct ssdfs_name_string));
+
+	search = ssdfs_btree_search_alloc();
+	if (!search) {
+		SSDFS_ERR("fail to allocate btree search object\n");
+		return -ENOMEM;
+	}
+
+	ssdfs_btree_search_init(search);
+
+	ssdfs_shared_dict_read_req_inc(tree);
+	down_read(&tree->lock);
+	err = ssdfs_shared_dict_tree_find(tree, hash, search);
+	up_read(&tree->lock);
+	ssdfs_shared_dict_read_req_dec(tree);
+
+	if (err == -ENODATA) {
+		/* name doesn't exist in dictionary */
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find the name: hash %llx\n", hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_get_name;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to find the name: hash %llx, err %d\n",
+			  hash, err);
+		goto finish_get_name;
+	}
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_VALID_ITEM:
+		/* expected state */
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_ERR("invalid result state %#x\n",
+			  search->result.state);
+		goto finish_get_name;
+	}
+
+	if (unlikely(search->result.err)) {
+		err = search->result.err;
+		SSDFS_ERR("result has error %d\n",
+			  search->result.err);
+		goto finish_get_name;
+	}
+
+	if (search->result.name_buf.state != SSDFS_BTREE_SEARCH_INLINE_BUFFER) {
+		err = -ERANGE;
+		SSDFS_ERR("unsupported buffer state %#x\n",
+			  search->result.name_buf.state);
+		goto finish_get_name;
+	}
+
+	if (search->result.name_buf.items_count != 1) {
+		err = -ERANGE;
+		SSDFS_ERR("unexpected items_count %u\n",
+			  search->result.name_buf.items_count);
+		goto finish_get_name;
+	}
+
+	if (!search->result.name_buf.place.name) {
+		err = -ERANGE;
+		SSDFS_ERR("empty name buffer\n");
+		goto finish_get_name;
+	}
+
+	if (hash != search->result.name_buf.place.name->hash) {
+		err = -ERANGE;
+		SSDFS_ERR("hash1 %llu != hash2 %llu\n",
+			  hash,
+			  search->result.name_buf.place.name->hash);
+		goto finish_get_name;
+	}
+
+	if (search->result.name_buf.place.name->len == 0 ||
+	    search->result.name_buf.place.name->len > SSDFS_MAX_NAME_LEN) {
+		err = -ERANGE;
+		SSDFS_ERR("invalid name length %zu\n",
+			  search->result.name_buf.place.name->len);
+		goto finish_get_name;
+	}
+
+	ssdfs_memcpy(name,
+		     0, sizeof(struct ssdfs_name_string),
+		     search->result.name_buf.place.name,
+		     0, sizeof(struct ssdfs_name_string),
+		     sizeof(struct ssdfs_name_string));
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("name %s\n", name->str);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+finish_get_name:
+	ssdfs_btree_search_free(search);
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("finished: err %d\n", err);
+#else
+	SSDFS_DBG("finished: err %d\n", err);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_save_name() - add name into queue
+ * @tree: shared dictionary tree
+ * @hash: name hash
+ * @str: name string
+ *
+ * This method tries to add name into requests queue.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOMEM     - fail to allocate memory.
+ */
+int ssdfs_shared_dict_save_name(struct ssdfs_shared_dict_btree_info *tree,
+				u64 hash,
+				const struct qstr *str)
+{
+	struct ssdfs_btree_search *search = NULL;
+	struct ssdfs_name_info *ni = NULL;
+	bool is_second_try = false;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree || !str);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("hash %llx, name %s, len %u\n",
+		  hash, str->name, str->len);
+#else
+	SSDFS_DBG("hash %llx, name %s, len %u\n",
+		  hash, str->name, str->len);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+try_check_state:
+	switch (atomic_read(&tree->state)) {
+	case SSDFS_SHDICT_BTREE_CREATED:
+	case SSDFS_SHDICT_BTREE_INITIALIZED:
+		/* tree is ready for operations */
+		break;
+
+	case SSDFS_SHDICT_BTREE_UNDER_INIT:
+		if (is_second_try) {
+			SSDFS_ERR("second try to wait the init ending\n");
+			return -ERANGE;
+		} else {
+			DEFINE_WAIT_FUNC(wait, woken_wake_function);
+
+			add_wait_queue(&tree->wait_queue, &wait);
+			while (is_shared_dict_under_init(tree)) {
+				if (signal_pending(current)) {
+					break;
+				} else {
+					wait_woken(&wait, TASK_INTERRUPTIBLE,
+						   SSDFS_DEFAULT_TIMEOUT);
+				}
+			}
+			remove_wait_queue(&tree->wait_queue, &wait);
+		}
+
+		is_second_try = true;
+		goto try_check_state;
+
+	case SSDFS_SHDICT_BTREE_CORRUPTED:
+		SSDFS_WARN("tree is corrupted\n");
+		return -EFAULT;
+
+	default:
+		SSDFS_ERR("invalid tree's state %#x\n",
+			  atomic_read(&tree->state));
+		return -ERANGE;
+	}
+
+	if (hash >= U64_MAX) {
+		SSDFS_ERR("invalid hash\n");
+		return -EINVAL;
+	}
+
+	search = ssdfs_btree_search_alloc();
+	if (!search) {
+		err = -ENOMEM;
+		SSDFS_ERR("fail to allocate btree search object\n");
+		goto finish_save_name;
+	}
+
+	ni = ssdfs_name_info_alloc();
+	if (IS_ERR_OR_NULL(ni)) {
+		err = !ni ? -ENOMEM : PTR_ERR(ni);
+		SSDFS_ERR("fail to allocate name info: "
+			  "err %d\n", err);
+		goto finish_save_name;
+	}
+
+	ssdfs_btree_search_init(search);
+	ssdfs_name_info_init(SSDFS_NAME_ADD, hash, str->name, str->len, ni);
+
+	down_write(&tree->lock);
+	err = ssdfs_shared_dict_tree_add(tree,
+					 ni->desc.name.hash,
+					 ni->desc.name.str_buf,
+					 ni->desc.name.len,
+					 search);
+	up_write(&tree->lock);
+
+	if (err == -EEXIST) {
+		/* name exist -> do nothing */
+		err = 0;
+		goto finish_save_name;
+	} else if (unlikely(err)) {
+		ssdfs_fs_error(tree->generic_tree.fsi->sb,
+				__FILE__, __func__, __LINE__,
+				"fail to add name: "
+				"hash %llx, name %s, len %zu, "
+				"err %d\n",
+				ni->desc.name.hash,
+				ni->desc.name.str_buf,
+				ni->desc.name.len,
+				err);
+		goto finish_save_name;
+	}
+
+finish_save_name:
+	if (ni)
+		ssdfs_name_info_free(ni);
+	if (search)
+		ssdfs_btree_search_free(search);
+
+#ifdef CONFIG_SSDFS_TRACK_API_CALL
+	SSDFS_ERR("finished: err %d\n", err);
+#else
+	SSDFS_DBG("finished: err %d\n", err);
+#endif /* CONFIG_SSDFS_TRACK_API_CALL */
+
+	return err;
+}
+
+/******************************************************************************
+ *               SHARED DICTIONARY TREE OBJECT FUNCTIONALITY                  *
+ ******************************************************************************/
+
+/*
+ * need_initialize_shared_dict_btree_search() - check necessity to init
+ * @name_hash: name hash
+ * @search: search object
+ */
+static inline
+bool need_initialize_shared_dict_btree_search(u64 name_hash,
+					      struct ssdfs_btree_search *search)
+{
+	return need_initialize_btree_search(search) ||
+		search->request.start.hash != name_hash;
+}
+
+/*
+ * ssdfs_shared_dict_tree_find() - find a name in the tree
+ * @tree: shared diction tree
+ * @name_hash: name hash
+ * @search: search object
+ *
+ * This method tries to find a name for the requested @name_hash.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-EINVAL     - invalid input.
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - item hasn't been found
+ */
+int ssdfs_shared_dict_tree_find(struct ssdfs_shared_dict_btree_info *tree,
+				u64 name_hash,
+				struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree || !search);
+
+	SSDFS_DBG("tree %p, hash %llx, search %p\n",
+		  tree, name_hash, search);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	search->request.type = SSDFS_BTREE_SEARCH_FIND_ITEM;
+
+	if (name_hash == U64_MAX) {
+		SSDFS_ERR("invalid name hash\n");
+		return -ERANGE;
+	}
+
+	if (need_initialize_shared_dict_btree_search(name_hash, search)) {
+		ssdfs_btree_search_init(search);
+		search->request.type = SSDFS_BTREE_SEARCH_FIND_ITEM;
+		search->request.flags =
+				SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE |
+				SSDFS_BTREE_SEARCH_HAS_VALID_COUNT;
+		search->request.start.hash = name_hash;
+		search->request.start.name = NULL;
+		search->request.start.name_len = 0;
+		search->request.end.hash = name_hash;
+		search->request.end.name = NULL;
+		search->request.end.name_len = 0;
+		search->request.count = 1;
+	}
+
+	return ssdfs_btree_find_item(&tree->generic_tree, search);
+}
+
+/*
+ * ssdfs_shared_dict_tree_add() - add the name into the tree
+ * @tree: shared dictionary tree
+ * @name_hash: name hash
+ * @name: name string
+ * @len: length of the string
+ * @search: search object
+ *
+ * This method tries to add the name into the tree.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-EINVAL     - invalid input.
+ * %-ERANGE     - internal error.
+ * %-EEXIST     - name exists in the tree.
+ */
+int ssdfs_shared_dict_tree_add(struct ssdfs_shared_dict_btree_info *tree,
+				u64 name_hash,
+				const char *name, size_t len,
+				struct ssdfs_btree_search *search)
+{
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree || !name || !search);
+
+	SSDFS_DBG("tree %p, hash %llx, name %s, len %zu, search %p\n",
+		  tree, name_hash, name, len, search);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	search->request.type = SSDFS_BTREE_SEARCH_FIND_ITEM;
+
+	if (name_hash >= U64_MAX) {
+		SSDFS_ERR("invalid name hash\n");
+		return -ERANGE;
+	}
+
+	if (need_initialize_shared_dict_btree_search(name_hash, search)) {
+		ssdfs_btree_search_init(search);
+		search->request.type = SSDFS_BTREE_SEARCH_FIND_ITEM;
+		search->request.flags =
+				SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE |
+				SSDFS_BTREE_SEARCH_HAS_VALID_COUNT |
+				SSDFS_BTREE_SEARCH_HAS_VALID_NAME;
+		search->request.start.hash = name_hash;
+		search->request.start.name = name;
+		search->request.start.name_len = len;
+		search->request.end.hash = name_hash;
+		search->request.end.name = name;
+		search->request.end.name_len = len;
+		search->request.count = 1;
+	} else {
+		search->request.flags =
+				SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE |
+				SSDFS_BTREE_SEARCH_HAS_VALID_COUNT |
+				SSDFS_BTREE_SEARCH_HAS_VALID_NAME;
+	}
+
+	err = ssdfs_btree_find_item(&tree->generic_tree, search);
+	if (err == -ENODATA) {
+		/*
+		 * Name doesn't exist in the tree.
+		 */
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to find the name: "
+			  "name_hash %llx, err %d\n",
+			  name_hash, err);
+		return err;
+	} else {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("name exists in the tree: "
+			  "hash %llx, name %s, len %zu\n",
+			  name_hash, name, len);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -EEXIST;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+	case SSDFS_BTREE_SEARCH_PLEASE_ADD_NODE:
+	case SSDFS_BTREE_SEARCH_OBSOLETE_RESULT:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid search result's state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	search->request.type = SSDFS_BTREE_SEARCH_ADD_ITEM;
+	err = ssdfs_btree_add_item(&tree->generic_tree, search);
+
+	ssdfs_btree_search_forget_parent_node(search);
+	ssdfs_btree_search_forget_child_node(search);
+
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to add the name into the tree: "
+			  "err %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ *        SPECIALIZED SHARED DICTIONARY BTREE DESCRIPTOR OPERATIONS           *
+ ******************************************************************************/
+
+/*
+ * ssdfs_shared_dict_btree_desc_init() - specialized btree descriptor init
+ * @fsi: pointer on shared file system object
+ * @tree: pointer on shared dictionary btree object
+ */
+static
+int ssdfs_shared_dict_btree_desc_init(struct ssdfs_fs_info *fsi,
+					struct ssdfs_btree *tree)
+{
+	struct ssdfs_btree_descriptor *desc;
+	u32 erasesize;
+	u32 node_size;
+	u16 item_size;
+	u32 index_area_min_size = SSDFS_MAX_NAME_LEN + 1;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!fsi || !tree);
+	BUG_ON(!rwsem_is_locked(&fsi->volume_sem));
+
+	SSDFS_DBG("fsi %p, tree %p\n",
+		  fsi, tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	erasesize = fsi->erasesize;
+
+	desc = &fsi->vs->shared_dict_btree.desc;
+
+	if (le32_to_cpu(desc->magic) != SSDFS_SHARED_DICT_BTREE_MAGIC) {
+		err = -EIO;
+		SSDFS_ERR("invalid magic %#x\n",
+			  le32_to_cpu(desc->magic));
+		goto finish_btree_desc_init;
+	}
+
+	/* TODO: check flags */
+
+	if (desc->type != SSDFS_SHARED_DICTIONARY_BTREE) {
+		err = -EIO;
+		SSDFS_ERR("invalid btree type %#x\n",
+			  desc->type);
+		goto finish_btree_desc_init;
+	}
+
+	node_size = 1 << desc->log_node_size;
+	if (node_size < SSDFS_4KB || node_size > erasesize) {
+		err = -EIO;
+		SSDFS_ERR("invalid node size: "
+			  "log_node_size %u, node_size %u, erasesize %u\n",
+			  desc->log_node_size,
+			  node_size, erasesize);
+		goto finish_btree_desc_init;
+	}
+
+	item_size = le16_to_cpu(desc->item_size);
+
+	if (item_size != SSDFS_MAX_NAME_LEN) {
+		err = -EIO;
+		SSDFS_ERR("invalid item size %u\n",
+			  item_size);
+		goto finish_btree_desc_init;
+	}
+
+	if (le16_to_cpu(desc->index_area_min_size) != index_area_min_size) {
+		err = -EIO;
+		SSDFS_ERR("invalid index_area_min_size %u\n",
+			  le16_to_cpu(desc->index_area_min_size));
+		goto finish_btree_desc_init;
+	}
+
+	err = ssdfs_btree_desc_init(fsi, tree, desc,
+				    (u8)SSDFS_DENTRY_INLINE_NAME_MAX_LEN,
+				    SSDFS_MAX_NAME_LEN);
+
+finish_btree_desc_init:
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to init btree descriptor: err %d\n",
+			  err);
+	}
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_desc_flush() - specialized btree's descriptor flush
+ * @tree: pointer on shared dictionary btree object
+ */
+static
+int ssdfs_shared_dict_btree_desc_flush(struct ssdfs_btree *tree)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_btree_descriptor desc;
+	u32 erasesize;
+	u32 node_size;
+	u32 index_area_min_size = SSDFS_MAX_NAME_LEN + 1;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree || !tree->fsi);
+
+	SSDFS_DBG("owner_ino %llu, type %#x, state %#x\n",
+		  tree->owner_ino, tree->type,
+		  atomic_read(&tree->state));
+
+	BUG_ON(!rwsem_is_locked(&tree->fsi->volume_sem));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = tree->fsi;
+
+	memset(&desc, 0xFF, sizeof(struct ssdfs_btree_descriptor));
+
+	desc.magic = cpu_to_le32(SSDFS_SHARED_DICT_BTREE_MAGIC);
+	desc.item_size = cpu_to_le16(SSDFS_MAX_NAME_LEN);
+
+	err = ssdfs_btree_desc_flush(tree, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("invalid btree descriptor: err %d\n",
+			  err);
+		return err;
+	}
+
+	if (desc.type != SSDFS_SHARED_DICTIONARY_BTREE) {
+		SSDFS_ERR("invalid btree type %#x\n",
+			  desc.type);
+		return -ERANGE;
+	}
+
+	erasesize = fsi->erasesize;
+	node_size = 1 << desc.log_node_size;
+
+	if (node_size < SSDFS_4KB || node_size > erasesize) {
+		SSDFS_ERR("invalid node size: "
+			  "log_node_size %u, node_size %u, erasesize %u\n",
+			  desc.log_node_size,
+			  node_size, erasesize);
+		return -ERANGE;
+	}
+
+	if (le16_to_cpu(desc.index_area_min_size) != index_area_min_size) {
+		SSDFS_ERR("invalid index_area_min_size %u\n",
+			  le16_to_cpu(desc.index_area_min_size));
+		return -ERANGE;
+	}
+
+	ssdfs_memcpy(&fsi->vs->shared_dict_btree.desc,
+		     0, sizeof(struct ssdfs_btree_descriptor),
+		     &desc,
+		     0, sizeof(struct ssdfs_btree_descriptor),
+		     sizeof(struct ssdfs_btree_descriptor));
+
+	return 0;
+}
+
+/******************************************************************************
+ *             SPECIALIZED SHARED DICTIONARY BTREE OPERATIONS                 *
+ ******************************************************************************/
+
+/*
+ * ssdfs_shared_dict_btree_create_root_node() - specialized root node creation
+ * @fsi: pointer on shared file system object
+ * @node: pointer on node object [out]
+ */
+static
+int ssdfs_shared_dict_btree_create_root_node(struct ssdfs_fs_info *fsi,
+					     struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree_inline_root_node *root_node;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!fsi || !fsi->vs || !node);
+	BUG_ON(!rwsem_is_locked(&fsi->volume_sem));
+
+	SSDFS_DBG("fsi %p, node %p\n",
+		  fsi, node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	root_node = &fsi->vs->shared_dict_btree.root_node;
+	err = ssdfs_btree_create_root_node(node, root_node);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to create root node: err %d\n",
+			  err);
+	}
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_pre_flush_root_node() - root node pre-flush
+ * @node: pointer on node object
+ */
+static
+int ssdfs_shared_dict_btree_pre_flush_root_node(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree *tree;
+	struct ssdfs_state_bitmap *bmap;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u, state %#x\n",
+		  node->node_id, atomic_read(&node->state));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->state)) {
+	case SSDFS_BTREE_NODE_DIRTY:
+		/* expected state */
+		break;
+
+	case SSDFS_BTREE_NODE_INITIALIZED:
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u is clean\n",
+			  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return 0;
+
+	case SSDFS_BTREE_NODE_CORRUPTED:
+		SSDFS_WARN("node %u is corrupted\n",
+			   node->node_id);
+		down_read(&node->bmap_array.lock);
+		bmap = &node->bmap_array.bmap[SSDFS_BTREE_NODE_DIRTY_BMAP];
+		spin_lock(&bmap->lock);
+		bitmap_clear(bmap->ptr, 0, node->bmap_array.bits_count);
+		spin_unlock(&bmap->lock);
+		up_read(&node->bmap_array.lock);
+		clear_ssdfs_btree_node_dirty(node);
+		return -EFAULT;
+
+	default:
+		SSDFS_ERR("invalid node state %#x\n",
+			  atomic_read(&node->state));
+		return -ERANGE;
+	}
+
+	tree = node->tree;
+	if (!tree) {
+		SSDFS_ERR("node hasn't pointer on tree\n");
+		return -ERANGE;
+	}
+
+	if (tree->type != SSDFS_SHARED_DICTIONARY_BTREE) {
+		SSDFS_WARN("invalid tree type %#x\n",
+			   tree->type);
+		return -ERANGE;
+	}
+
+	down_write(&node->full_lock);
+	down_write(&node->header_lock);
+
+	err = ssdfs_btree_pre_flush_root_node(node);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to pre-flush root node: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+	}
+
+	up_write(&node->header_lock);
+	up_write(&node->full_lock);
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_flush_root_node() - specialized root node flush
+ * @node: pointer on node object
+ */
+static
+int ssdfs_shared_dict_btree_flush_root_node(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree_inline_root_node *root_node;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree || !node->tree->fsi);
+	BUG_ON(!rwsem_is_locked(&node->tree->fsi->volume_sem));
+
+	SSDFS_DBG("node_id %u, state %#x\n",
+		  node->node_id, atomic_read(&node->state));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!is_ssdfs_btree_node_dirty(node)) {
+		SSDFS_WARN("node %u is not dirty\n",
+			   node->node_id);
+		return 0;
+	}
+
+	root_node = &node->tree->fsi->vs->shared_dict_btree.root_node;
+	ssdfs_btree_flush_root_node(node, root_node);
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_btree_create_node() - specialized node creation
+ * @node: pointer on node object
+ */
+static
+int ssdfs_shared_dict_btree_create_node(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree *tree;
+	void *addr[SSDFS_BTREE_NODE_BMAP_COUNT];
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	size_t ltbl2_item_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t htbl_item_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u32 node_size;
+	u32 items_area_size = 0;
+	u16 item_size = 0;
+	u16 index_size = 0;
+	u16 index_area_min_size;
+	u16 items_capacity = 0;
+	u16 index_capacity = 0;
+	u32 index_area_size = 0;
+	size_t bmap_bytes;
+	int i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree);
+	WARN_ON(atomic_read(&node->state) != SSDFS_BTREE_NODE_CREATED);
+
+	SSDFS_DBG("node_id %u, state %#x\n",
+		  node->node_id, atomic_read(&node->state));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	tree = node->tree;
+	node_size = tree->node_size;
+	index_area_min_size = tree->index_area_min_size;
+
+	node->node_ops = &ssdfs_shared_dict_btree_node_ops;
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_INDEX_NODE:
+		switch (atomic_read(&node->index_area.state)) {
+		case SSDFS_BTREE_NODE_INDEX_AREA_EXIST:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("invalid index area's state %#x\n",
+				  atomic_read(&node->items_area.state));
+			return -ERANGE;
+		}
+
+		switch (atomic_read(&node->items_area.state)) {
+		case SSDFS_BTREE_NODE_AREA_ABSENT:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("invalid items area's state %#x\n",
+				  atomic_read(&node->items_area.state));
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_BTREE_HYBRID_NODE:
+		switch (atomic_read(&node->index_area.state)) {
+		case SSDFS_BTREE_NODE_INDEX_AREA_EXIST:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("invalid index area's state %#x\n",
+				  atomic_read(&node->items_area.state));
+			return -ERANGE;
+		}
+
+		switch (atomic_read(&node->items_area.state)) {
+		case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("invalid items area's state %#x\n",
+				  atomic_read(&node->items_area.state));
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_BTREE_LEAF_NODE:
+		switch (atomic_read(&node->index_area.state)) {
+		case SSDFS_BTREE_NODE_AREA_ABSENT:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("invalid index area's state %#x\n",
+				  atomic_read(&node->items_area.state));
+			return -ERANGE;
+		}
+
+		switch (atomic_read(&node->items_area.state)) {
+		case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("invalid items area's state %#x\n",
+				  atomic_read(&node->items_area.state));
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_WARN("invalid node type %#x\n",
+			   atomic_read(&node->type));
+		return -ERANGE;
+	}
+
+	down_write(&node->header_lock);
+	down_write(&node->bmap_array.lock);
+
+	memset(node->raw.dict_header.lookup_table1, 0xFF,
+		sizeof(struct ssdfs_shdict_ltbl1_item) * SSDFS_SHDIC_LTBL1_SIZE);
+	node->raw.dict_header.lookup_table1_items = cpu_to_le16(0);
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_INDEX_NODE:
+		node->index_area.offset = (u32)hdr_size;
+		node->index_area.area_size = node_size - hdr_size;
+
+		index_area_size = node->index_area.area_size;
+		index_size = node->index_area.index_size;
+
+		node->index_area.index_capacity = index_area_size / index_size;
+		index_capacity = node->index_area.index_capacity;
+
+		node->bmap_array.index_start_bit =
+			SSDFS_BTREE_NODE_HEADER_INDEX + 1;
+		node->bmap_array.item_start_bit =
+			node->bmap_array.index_start_bit + index_capacity;
+		break;
+
+	case SSDFS_BTREE_HYBRID_NODE:
+		node->index_area.offset = (u32)hdr_size;
+
+		if (index_area_min_size == 0 ||
+		    index_area_min_size >= (node_size - hdr_size)) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid index area desc: "
+				  "index_area_min_size %u, "
+				  "node_size %u, hdr_size %zu\n",
+				  index_area_min_size,
+				  node_size, hdr_size);
+			goto finish_create_node;
+		}
+
+		node->index_area.area_size = index_area_min_size;
+
+		index_area_size = node->index_area.area_size;
+		index_size = node->index_area.index_size;
+		node->index_area.index_capacity = index_area_size / index_size;
+		index_capacity = node->index_area.index_capacity;
+
+		atomic_or(SSDFS_BTREE_NODE_HAS_L1TBL, &node->flags);
+
+		atomic_set(&node->lookup_tbl_area.state,
+			   SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST);
+		atomic_or(SSDFS_BTREE_NODE_HAS_L2TBL, &node->flags);
+		node->lookup_tbl_area.offset = node->node_size;
+		node->lookup_tbl_area.index_size = ltbl2_item_size;
+
+		atomic_set(&node->hash_tbl_area.state,
+			   SSDFS_BTREE_NODE_HASH_TBL_EXIST);
+		atomic_or(SSDFS_BTREE_NODE_HAS_HASH_TBL, &node->flags);
+		node->hash_tbl_area.offset = node->node_size;
+		node->hash_tbl_area.index_size = htbl_item_size;
+
+		node->items_area.offset = node->index_area.offset +
+						node->index_area.area_size;
+
+		if (node->items_area.offset >= node_size) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid items area desc: "
+				  "area_offset %u, node_size %u\n",
+				  node->items_area.offset,
+				  node_size);
+			goto finish_create_node;
+		}
+
+		node->items_area.area_size = node_size -
+						node->items_area.offset;
+		node->items_area.free_space = node->items_area.area_size;
+		node->items_area.item_size = tree->item_size;
+		node->items_area.min_item_size = tree->min_item_size;
+		node->items_area.max_item_size = tree->max_item_size;
+
+		items_area_size = node->items_area.area_size;
+		item_size = node->items_area.item_size;
+
+		node->items_area.items_count = 0;
+		node->items_area.items_capacity = items_area_size / item_size;
+		items_capacity = node->items_area.items_capacity;
+
+		if (node->items_area.items_capacity == 0) {
+			err = -ERANGE;
+			SSDFS_ERR("items area's capacity %u\n",
+				  node->items_area.items_capacity);
+			goto finish_create_node;
+		}
+
+		node->bmap_array.index_start_bit =
+			SSDFS_BTREE_NODE_HEADER_INDEX + 1;
+		node->bmap_array.item_start_bit =
+			node->bmap_array.index_start_bit + index_capacity;
+		break;
+
+	case SSDFS_BTREE_LEAF_NODE:
+		atomic_or(SSDFS_BTREE_NODE_HAS_L1TBL, &node->flags);
+
+		atomic_set(&node->lookup_tbl_area.state,
+			   SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST);
+		atomic_or(SSDFS_BTREE_NODE_HAS_L2TBL, &node->flags);
+		node->lookup_tbl_area.offset = node->node_size;
+		node->lookup_tbl_area.index_size = ltbl2_item_size;
+
+		atomic_set(&node->hash_tbl_area.state,
+			   SSDFS_BTREE_NODE_HASH_TBL_EXIST);
+		atomic_or(SSDFS_BTREE_NODE_HAS_HASH_TBL, &node->flags);
+		node->hash_tbl_area.offset = node->node_size;
+		node->hash_tbl_area.index_size = htbl_item_size;
+
+		node->items_area.offset = (u32)hdr_size;
+		node->items_area.area_size = node_size - hdr_size;
+		node->items_area.free_space = node->items_area.area_size;
+		node->items_area.item_size = tree->item_size;
+		node->items_area.min_item_size = tree->min_item_size;
+		node->items_area.max_item_size = tree->max_item_size;
+
+		items_area_size = node->items_area.area_size;
+		item_size = node->items_area.item_size;
+
+		node->items_area.items_count = 0;
+		node->items_area.items_capacity = items_area_size / item_size;
+		items_capacity = node->items_area.items_capacity;
+
+		node->bmap_array.item_start_bit =
+				SSDFS_BTREE_NODE_HEADER_INDEX + 1;
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_WARN("invalid node type %#x\n",
+			   atomic_read(&node->type));
+		goto finish_create_node;
+	}
+
+	node->bmap_array.bits_count = index_capacity + items_capacity + 1;
+
+	if (item_size > 0)
+		items_capacity = node_size / item_size;
+	else
+		items_capacity = 0;
+
+	if (index_size > 0)
+		index_capacity = node_size / index_size;
+	else
+		index_capacity = 0;
+
+	bmap_bytes = index_capacity + items_capacity + 1;
+	bmap_bytes += BITS_PER_LONG + (BITS_PER_LONG - 1);
+	bmap_bytes /= BITS_PER_BYTE;
+
+	if (bmap_bytes == 0 || bmap_bytes > SSDFS_SHARED_DICT_BMAP_SIZE) {
+		err = -EIO;
+		SSDFS_ERR("invalid bmap_bytes %zu\n",
+			  bmap_bytes);
+		goto finish_create_node;
+	}
+
+	node->bmap_array.bmap_bytes = bmap_bytes;
+
+finish_create_node:
+	up_write(&node->bmap_array.lock);
+	up_write(&node->header_lock);
+
+	if (unlikely(err))
+		return err;
+
+	err = ssdfs_btree_node_allocate_bmaps(addr, bmap_bytes);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to allocate node's bitmaps: "
+			  "bmap_bytes %zu, err %d\n",
+			  bmap_bytes, err);
+		return err;
+	}
+
+	down_write(&node->bmap_array.lock);
+	for (i = 0; i < SSDFS_BTREE_NODE_BMAP_COUNT; i++) {
+		spin_lock(&node->bmap_array.bmap[i].lock);
+		node->bmap_array.bmap[i].ptr = addr[i];
+		addr[i] = NULL;
+		spin_unlock(&node->bmap_array.bmap[i].lock);
+	}
+	up_write(&node->bmap_array.lock);
+
+	err = ssdfs_btree_node_allocate_content_space(node, node_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to allocate content space: "
+			  "node_size %u, err %d\n",
+			  node_size, err);
+		return err;
+	}
+
+	ssdfs_debug_btree_node_object(node);
+
+	return err;
+}
+
+/*
+ * ssdfs_init_lookup_table_hash_range() - extract hash range of lookup table
+ * @node: node object
+ * @area_offset: offset of the area in bytes
+ * @area_size: size of the area in bytes
+ * @desc_count: count of descriptors in the area
+ * @start_hash: starting hash of lookup table [out]
+ * @end_hash: ending hash of lookup table [out]
+ *
+ * This method tries to extract start and end hash from
+ * the raw lookup table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_init_lookup_table_hash_range(struct ssdfs_btree_node *node,
+					u16 area_offset, u16 area_size,
+					u16 desc_count,
+					u64 *start_hash, u64 *end_hash)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_shdict_ltbl2_item item;
+	struct ssdfs_smart_folio folio;
+	struct ssdfs_content_block *blk;
+	size_t desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	u16 position;
+	u32 src_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree);
+	BUG_ON(!start_hash || !end_hash);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, height %u\n",
+		  node->node_id,
+		  atomic_read(&node->height));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	*start_hash = U64_MAX;
+	*end_hash = U64_MAX;
+
+	if (desc_count == 0)
+		return 0;
+
+	position = 0;
+
+	err = __ssdfs_define_memory_folio(fsi, area_offset, area_size,
+					  node->node_size, desc_size,
+					  position,
+					  &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to define folio index: err %d\n",
+			  err);
+		return err;
+	}
+
+	if ((folio.desc.offset_inside_page + desc_size) > PAGE_SIZE) {
+		SSDFS_ERR("invalid offset into the page: "
+			  "offset %u, desc_size %zu\n",
+			  folio.desc.offset_inside_page, desc_size);
+		return -ERANGE;
+	}
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid page index: "
+			  "folio_index %u, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	blk = &node->content.blocks[folio.desc.folio_index];
+	src_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_from_batch(&item, 0, desc_size,
+					&blk->batch, src_offset,
+					desc_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	*start_hash = le64_to_cpu(item.hash);
+
+	position = desc_count - 1;
+
+	if (position == 0) {
+		*end_hash = *start_hash;
+		return 0;
+	}
+
+	err = __ssdfs_define_memory_folio(fsi, area_offset, area_size,
+					  node->node_size, desc_size,
+					  position,
+					  &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to define folio index: err %d\n",
+			  err);
+		return err;
+	}
+
+	if ((folio.desc.offset_inside_page + desc_size) > PAGE_SIZE) {
+		SSDFS_ERR("invalid offset into the page: "
+			  "offset %u, desc_size %zu\n",
+			  folio.desc.offset_inside_page, desc_size);
+		return -ERANGE;
+	}
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid block index: "
+			  "folio_index %u, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	blk = &node->content.blocks[folio.desc.folio_index];
+	src_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_from_batch(&item, 0, desc_size,
+					&blk->batch, src_offset,
+					desc_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	*end_hash = le64_to_cpu(item.hash);
+
+	return 0;
+}
+
+/*
+ * ssdfs_init_hash_table_range() - extract hash range of hash table
+ * @node: node object
+ * @area_offset: offset of the area in bytes
+ * @area_size: size of the area in bytes
+ * @desc_count: count of descriptors in the area
+ * @start_hash: starting hash of hash table [out]
+ * @end_hash: ending hash of hash table [out]
+ *
+ * This method tries to extract start and end hash from
+ * the raw hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_init_hash_table_range(struct ssdfs_btree_node *node,
+				u16 area_offset, u16 area_size,
+				u16 desc_count,
+				u64 *start_hash, u64 *end_hash)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_shdict_htbl_item item;
+	struct ssdfs_smart_folio folio;
+	struct ssdfs_content_block *blk;
+	size_t desc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u32 src_offset;
+	u16 position;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree);
+	BUG_ON(!start_hash || !end_hash);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, height %u\n",
+		  node->node_id,
+		  atomic_read(&node->height));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	*start_hash = U64_MAX;
+	*end_hash = U64_MAX;
+
+	if (desc_count == 0)
+		return 0;
+
+	position = 0;
+
+	err = __ssdfs_define_memory_folio(fsi, area_offset, area_size,
+					  node->node_size, desc_size,
+					  position,
+					  &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to define folio index: err %d\n",
+			  err);
+		return err;
+	}
+
+	if ((folio.desc.offset_inside_page + desc_size) > PAGE_SIZE) {
+		SSDFS_ERR("invalid offset into the page: "
+			  "offset %u, desc_size %zu\n",
+			  folio.desc.offset_inside_page, desc_size);
+		return -ERANGE;
+	}
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid page index: "
+			  "folio_index %u, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	blk = &node->content.blocks[folio.desc.folio_index];
+	src_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_from_batch(&item, 0, desc_size,
+					&blk->batch, src_offset,
+					desc_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	*start_hash = le64_to_cpu(item.hash);
+
+	position = desc_count - 1;
+
+	if (position == 0) {
+		*end_hash = *start_hash;
+		return 0;
+	}
+
+	err = __ssdfs_define_memory_folio(fsi, area_offset, area_size,
+					  node->node_size, desc_size,
+					  position,
+					  &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to define folio index: err %d\n",
+			  err);
+		return err;
+	}
+
+	if ((folio.desc.offset_inside_page + desc_size) > PAGE_SIZE) {
+		SSDFS_ERR("invalid offset into the page: "
+			  "offset %u, desc_size %zu\n",
+			  folio.desc.offset_inside_page, desc_size);
+		return -ERANGE;
+	}
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid page index: "
+			  "folio_index %u, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	blk = &node->content.blocks[folio.desc.folio_index];
+	src_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_from_batch(&item, 0, desc_size,
+					&blk->batch, src_offset,
+					desc_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	*end_hash = le64_to_cpu(item.hash);
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_init_lookup_table_area() - init lookup table
+ * @node: node object
+ * @hdr: node's header
+ *
+ * This method tries to init the lookup table's area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-EIO        - header is corrupted.
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shared_dict_init_lookup_table_area(struct ssdfs_btree_node *node,
+				struct ssdfs_shared_dictionary_node_header *hdr)
+{
+	u16 flags;
+	u16 area_offset;
+	u16 area_size;
+	size_t desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	u16 desc_capacity;
+	u16 free_space;
+	u16 items_count;
+	u64 start_hash = U64_MAX;
+	u64 end_hash = U64_MAX;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree || !hdr);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, height %u\n",
+		  node->node_id,
+		  atomic_read(&node->height));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	flags = le16_to_cpu(hdr->node.flags);
+
+	if (flags & SSDFS_BTREE_NODE_HAS_L2TBL) {
+		area_offset = le16_to_cpu(hdr->lookup_table2.offset);
+		area_size = le16_to_cpu(hdr->lookup_table2.size);
+		free_space = le16_to_cpu(hdr->lookup_table2.free_space);
+		items_count = le16_to_cpu(hdr->lookup_table2.items_count);
+
+		if (area_size % desc_size) {
+			SSDFS_ERR("corrupted lookup table: "
+				  "area_size %u, desc_size %zu\n",
+				  area_size, desc_size);
+			return -EIO;
+		}
+
+		if (area_size != ((items_count * desc_size) + free_space)) {
+			SSDFS_ERR("invalid area descriptor: "
+				  "area_size %u, items_count %u, "
+				  "desc_size %zu, free_space %u\n",
+				  area_size, items_count,
+				  desc_size, free_space);
+			return -EIO;
+		}
+
+		desc_capacity = area_size / desc_size;
+
+		atomic_set(&node->lookup_tbl_area.state,
+				SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST);
+		atomic_or(SSDFS_BTREE_NODE_HAS_L1TBL, &node->flags);
+		atomic_or(SSDFS_BTREE_NODE_HAS_L2TBL, &node->flags);
+		node->lookup_tbl_area.offset = area_offset;
+		node->lookup_tbl_area.area_size = area_size;
+		node->lookup_tbl_area.index_size = desc_size;
+		node->lookup_tbl_area.index_count = items_count;
+		node->lookup_tbl_area.index_capacity = desc_capacity;
+
+		err = ssdfs_init_lookup_table_hash_range(node, area_offset,
+							 area_size, items_count,
+							 &start_hash,
+							 &end_hash);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to retrieve hash range: "
+				  "err %d\n",
+				  err);
+			return err;
+		}
+
+		node->lookup_tbl_area.start_hash = start_hash;
+		node->lookup_tbl_area.end_hash = end_hash;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("flags %#x, items_count %u\n",
+		  flags, node->lookup_tbl_area.index_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_init_hash_table_area() - init hash table
+ * @node: node object
+ * @hdr: node's header
+ *
+ * This method tries to init the hash table's area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-EIO        - header is corrupted.
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shared_dict_init_hash_table_area(struct ssdfs_btree_node *node,
+				struct ssdfs_shared_dictionary_node_header *hdr)
+{
+	u16 flags;
+	u16 area_offset;
+	u16 area_size;
+	size_t desc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u16 desc_capacity;
+	u16 free_space;
+	u16 items_count;
+	u64 start_hash = U64_MAX;
+	u64 end_hash = U64_MAX;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree || !hdr);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, height %u\n",
+		  node->node_id,
+		  atomic_read(&node->height));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	flags = le16_to_cpu(hdr->node.flags);
+
+	if (flags & SSDFS_BTREE_NODE_HAS_HASH_TBL) {
+		area_offset = le16_to_cpu(hdr->hash_table.offset);
+		area_size = le16_to_cpu(hdr->hash_table.size);
+		free_space = le16_to_cpu(hdr->hash_table.free_space);
+		items_count = le16_to_cpu(hdr->hash_table.items_count);
+
+		if (area_size % desc_size) {
+			SSDFS_ERR("corrupted lookup table: "
+				  "area_size %u, desc_size %zu\n",
+				  area_size, desc_size);
+			return -EIO;
+		}
+
+		if (area_size != ((items_count * desc_size) + free_space)) {
+			SSDFS_ERR("invalid area descriptor: "
+				  "area_size %u, items_count %u, "
+				  "desc_size %zu, free_space %u\n",
+				  area_size, items_count,
+				  desc_size, free_space);
+			return -EIO;
+		}
+
+		desc_capacity = area_size / desc_size;
+
+		atomic_set(&node->hash_tbl_area.state,
+				SSDFS_BTREE_NODE_HASH_TBL_EXIST);
+		atomic_or(SSDFS_BTREE_NODE_HAS_HASH_TBL, &node->flags);
+		node->hash_tbl_area.offset = area_offset;
+		node->hash_tbl_area.area_size = area_size;
+		node->hash_tbl_area.index_size = desc_size;
+		node->hash_tbl_area.index_count = items_count;
+		node->hash_tbl_area.index_capacity = desc_capacity;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("offset %u, area_size %u, desc_size %zu, "
+			  "index_count %u, index_capacity %u\n",
+			  area_offset, area_size, desc_size,
+			  items_count, desc_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_init_hash_table_range(node, area_offset,
+						  area_size, items_count,
+						  &start_hash,
+						  &end_hash);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to retrieve hash range: "
+				  "err %d\n",
+				  err);
+			return err;
+		}
+
+		node->hash_tbl_area.start_hash = start_hash;
+		node->hash_tbl_area.end_hash = end_hash;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_btree_init_node() - init shared dictionary tree's node
+ * @node: pointer on node object
+ *
+ * This method tries to init the node of shared dictionary btree.
+ *
+ *       It makes sense to allocate the bitmap with taking into
+ *       account that we will resize the node. So, it needs
+ *       to allocate the index area in bitmap is equal to
+ *       the whole node and items area is equal to the whole node.
+ *       This technique provides opportunity not to resize or
+ *       to shift the content of the bitmap.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ENOMEM     - unable to allocate memory.
+ * %-ERANGE     - internal error.
+ * %-EIO        - invalid node's header content
+ */
+static
+int ssdfs_shared_dict_btree_init_node(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree *tree;
+	struct ssdfs_shared_dict_btree_info *tree_info = NULL;
+	struct ssdfs_shared_dictionary_node_header *hdr;
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	void *addr[SSDFS_BTREE_NODE_BMAP_COUNT];
+	struct folio *folio;
+	void *kaddr;
+	u64 start_hash, end_hash;
+	u32 node_size;
+	u8 min_item_size;
+	u16 max_item_size;
+	u16 items_capacity;
+	u16 free_space;
+	u16 str_area_offset;
+	u16 str_area_bytes;
+	u16 hash_tbl_offset;
+	u16 hash_tbl_size;
+	u16 lookup_tbl2_offset;
+	u16 lookup_tbl2_size;
+	u32 calculated_used_space;
+	u16 strings_count;
+	u16 flags;
+	u8 index_size;
+	u32 index_area_size = 0;
+	u16 index_capacity = 0;
+	size_t bmap_bytes;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u, state %#x\n",
+		  node->node_id, atomic_read(&node->state));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	tree = node->tree;
+	if (!tree) {
+		SSDFS_ERR("node hasn't pointer on tree\n");
+		return -ERANGE;
+	}
+
+	if (tree->type != SSDFS_SHARED_DICTIONARY_BTREE) {
+		SSDFS_WARN("invalid tree type %#x\n",
+			   tree->type);
+		return -ERANGE;
+	} else {
+		tree_info = container_of(tree,
+					 struct ssdfs_shared_dict_btree_info,
+					 generic_tree);
+	}
+
+	if (atomic_read(&node->state) != SSDFS_BTREE_NODE_CONTENT_PREPARED) {
+		SSDFS_WARN("fail to init node: id %u, state %#x\n",
+			   node->node_id, atomic_read(&node->state));
+		return -ERANGE;
+	}
+
+	down_read(&node->full_lock);
+
+	if (node->content.count == 0) {
+		err = -ERANGE;
+		SSDFS_ERR("empty node's content: id %u\n",
+			  node->node_id);
+		goto finish_init_node;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(folio_batch_count(&node->content.blocks[0].batch) == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	folio = node->content.blocks[0].batch.folios[0];
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!folio);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	kaddr = kmap_local_folio(folio, 0);
+
+	hdr = (struct ssdfs_shared_dictionary_node_header *)kaddr;
+
+	if (!is_csum_valid(&hdr->node.check, hdr, hdr_size)) {
+		err = -EIO;
+		SSDFS_ERR("invalid checksum: node_id %u\n",
+			  node->node_id);
+		goto finish_init_operation;
+	}
+
+	if (le32_to_cpu(hdr->node.magic.common) != SSDFS_SUPER_MAGIC ||
+	    le16_to_cpu(hdr->node.magic.key) != SSDFS_DICTIONARY_BNODE_MAGIC) {
+		err = -EIO;
+		SSDFS_ERR("invalid magic: common %#x, key %#x\n",
+			  le32_to_cpu(hdr->node.magic.common),
+			  le16_to_cpu(hdr->node.magic.key));
+		goto finish_init_operation;
+	}
+
+	down_write(&node->header_lock);
+
+	ssdfs_memcpy(&node->raw.dict_header, 0, hdr_size,
+		     hdr, 0, hdr_size,
+		     hdr_size);
+
+	err = ssdfs_btree_init_node(node, &hdr->node,
+				    hdr_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to init node: id %u, err %d\n",
+			  node->node_id, err);
+		goto finish_header_init;
+	}
+
+	start_hash = le64_to_cpu(hdr->node.start_hash);
+	end_hash = le64_to_cpu(hdr->node.end_hash);
+	node_size = 1 << hdr->node.log_node_size;
+	index_size = hdr->node.index_size;
+	min_item_size = hdr->node.min_item_size;
+	max_item_size = le16_to_cpu(hdr->node.max_item_size);
+	items_capacity = le16_to_cpu(hdr->node.items_capacity);
+	strings_count = le16_to_cpu(hdr->str_area.items_count);
+	free_space = le16_to_cpu(hdr->str_area.free_space);
+	str_area_offset = le16_to_cpu(hdr->str_area.offset);
+	str_area_bytes = le16_to_cpu(hdr->str_area.size);
+	hash_tbl_offset = le16_to_cpu(hdr->hash_table.offset);
+	hash_tbl_size = le16_to_cpu(hdr->hash_table.size);
+	lookup_tbl2_offset = le16_to_cpu(hdr->lookup_table2.offset);
+	lookup_tbl2_size = le16_to_cpu(hdr->lookup_table2.size);
+
+	if (start_hash >= U64_MAX || end_hash >= U64_MAX) {
+		err = -EIO;
+		SSDFS_ERR("invalid hash range: "
+			  "start_hash %llx, end_hash %llx\n",
+			  start_hash, end_hash);
+		goto finish_header_init;
+	}
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_INDEX_NODE:
+		index_area_size = 1 << hdr->node.log_index_area_size;
+
+		if (index_area_size != node_size) {
+			err = -EIO;
+			SSDFS_ERR("invalid index_area_size %u\n",
+				  index_area_size);
+			goto finish_header_init;
+		}
+
+		index_area_size -= hdr_size;
+		break;
+
+	case SSDFS_BTREE_HYBRID_NODE:
+	case SSDFS_BTREE_LEAF_NODE:
+		if (min_item_size != SSDFS_DENTRY_INLINE_NAME_MAX_LEN ||
+		    max_item_size != SSDFS_MAX_NAME_LEN) {
+			err = -EIO;
+			SSDFS_ERR("invalid item_size: "
+				  "min_item_size %u, max_item_size %u\n",
+				  min_item_size, max_item_size);
+			goto finish_header_init;
+		}
+
+		if (items_capacity == 0 ||
+		    items_capacity > (node_size / min_item_size)) {
+			err = -EIO;
+			SSDFS_ERR("invalid items_capacity %u\n",
+				  items_capacity);
+			goto finish_header_init;
+		}
+
+		if (strings_count > items_capacity) {
+			err = -EIO;
+			SSDFS_ERR("strings_count %u > items_capacity %u\n",
+				  strings_count, items_capacity);
+			goto finish_header_init;
+		}
+
+		if (hdr->node.log_index_area_size > 0)
+			index_area_size = 1 << hdr->node.log_index_area_size;
+
+		calculated_used_space = hdr_size + index_area_size;
+		calculated_used_space += lookup_tbl2_size;
+		calculated_used_space += hash_tbl_size;
+		calculated_used_space += str_area_bytes;
+
+		if (node_size != calculated_used_space) {
+			err = -EIO;
+			SSDFS_ERR("corrupted node: free_space %u, "
+				  "node_size %u, calculated_used_space %u\n",
+				  free_space, node_size,
+				  calculated_used_space);
+			goto finish_header_init;
+		}
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_WARN("invalid node type %#x\n",
+			   atomic_read(&node->type));
+		goto finish_header_init;
+	};
+
+	if (free_space > str_area_bytes) {
+		err = -EIO;
+		SSDFS_ERR("free_space %u, str_area_bytes %u\n",
+			  free_space, str_area_bytes);
+		goto finish_header_init;
+	}
+
+	if (str_area_offset != (hdr_size + index_area_size)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted strings area: "
+			  "str_area_offset %u, hdr_size %zu, "
+			  "index_area_size %u\n",
+			  str_area_offset,
+			  hdr_size,
+			  index_area_size);
+		goto finish_header_init;
+	}
+
+	if (hash_tbl_offset != (str_area_offset + str_area_bytes)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted hash table: "
+			  "hash_tbl_offset %u, str_area_offset %u, "
+			  "str_area_bytes %u\n",
+			  hash_tbl_offset,
+			  str_area_offset,
+			  str_area_bytes);
+		goto finish_header_init;
+	}
+
+	if (lookup_tbl2_offset != (hash_tbl_offset + hash_tbl_size)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted lookup table: "
+			  "lookup_tbl2_offset %u, hash_tbl_offset %u, "
+			  "hash_tbl_size %u\n",
+			  lookup_tbl2_offset,
+			  hash_tbl_offset,
+			  hash_tbl_size);
+		goto finish_header_init;
+	}
+
+	err = ssdfs_shared_dict_init_lookup_table_area(node, hdr);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to init lookup table: err %d\n",
+			  err);
+		goto finish_header_init;
+	}
+
+	err = ssdfs_shared_dict_init_hash_table_area(node, hdr);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to init hash table: err %d\n",
+			  err);
+		goto finish_header_init;
+	}
+
+	node->items_area.offset = str_area_offset;
+	node->items_area.area_size = str_area_bytes;
+	node->items_area.free_space = free_space;
+	node->items_area.min_item_size = min_item_size;
+	node->items_area.max_item_size = max_item_size;
+	node->items_area.items_count = strings_count;
+	node->items_area.items_capacity = items_capacity;
+
+finish_header_init:
+	up_write(&node->header_lock);
+
+	if (unlikely(err))
+		goto finish_init_operation;
+
+	if (min_item_size > 0)
+		items_capacity = node_size / min_item_size;
+	else
+		items_capacity = 0;
+
+	if (index_size > 0)
+		index_capacity = node_size / index_size;
+	else
+		index_capacity = 0;
+
+	bmap_bytes = index_capacity + items_capacity + 1;
+	bmap_bytes += BITS_PER_LONG + (BITS_PER_LONG - 1);
+	bmap_bytes /= BITS_PER_BYTE;
+
+	if (bmap_bytes == 0 || bmap_bytes > SSDFS_SHARED_DICT_BMAP_SIZE) {
+		err = -EIO;
+		SSDFS_ERR("invalid bmap_bytes %zu\n",
+			  bmap_bytes);
+		goto finish_init_operation;
+	}
+
+	err = ssdfs_btree_node_allocate_bmaps(addr, bmap_bytes);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to allocate node's bitmaps: "
+			  "bmap_bytes %zu, err %d\n",
+			  bmap_bytes, err);
+		goto finish_init_operation;
+	}
+
+	down_write(&node->bmap_array.lock);
+
+	flags = atomic_read(&node->flags);
+	if (flags & SSDFS_BTREE_NODE_HAS_INDEX_AREA) {
+		node->bmap_array.index_start_bit =
+			SSDFS_BTREE_NODE_HEADER_INDEX + 1;
+		/*
+		 * Reserve the whole node space as
+		 * potential space for indexes.
+		 */
+		index_capacity = node_size / index_size;
+		node->bmap_array.item_start_bit =
+			node->bmap_array.index_start_bit + index_capacity;
+	} else if (flags & SSDFS_BTREE_NODE_HAS_ITEMS_AREA) {
+		node->bmap_array.item_start_bit =
+				SSDFS_BTREE_NODE_HEADER_INDEX + 1;
+	} else
+		BUG();
+
+	node->bmap_array.bits_count = index_capacity + items_capacity + 1;
+	node->bmap_array.bmap_bytes = bmap_bytes;
+
+	ssdfs_btree_node_init_bmaps(node, addr);
+
+	spin_lock(&node->bmap_array.bmap[SSDFS_BTREE_NODE_ALLOC_BMAP].lock);
+	bitmap_set(node->bmap_array.bmap[SSDFS_BTREE_NODE_ALLOC_BMAP].ptr,
+		   0, strings_count);
+	spin_unlock(&node->bmap_array.bmap[SSDFS_BTREE_NODE_ALLOC_BMAP].lock);
+
+	up_write(&node->bmap_array.lock);
+finish_init_operation:
+	kunmap_local(kaddr);
+
+	if (unlikely(err))
+		goto finish_init_node;
+
+finish_init_node:
+	up_read(&node->full_lock);
+
+	ssdfs_debug_btree_node_object(node);
+
+	return err;
+}
+
+static
+void ssdfs_shared_dict_btree_destroy_node(struct ssdfs_btree_node *node)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("operation is unavailable\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+}
+
+/*
+ * ssdfs_shared_dict_btree_add_node() - add node into shared dictionary
+ * @node: pointer on node object
+ *
+ * This method tries to finish addition of node into shared dictionary.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shared_dict_btree_add_node(struct ssdfs_btree_node *node)
+{
+	int type;
+	u16 items_capacity = 0;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u, state %#x\n",
+		  node->node_id, atomic_read(&node->state));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->state)) {
+	case SSDFS_BTREE_NODE_CREATED:
+	case SSDFS_BTREE_NODE_DIRTY:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_WARN("invalid node: id %u, state %#x\n",
+			   node->node_id, atomic_read(&node->state));
+		return -ERANGE;
+	}
+
+	type = atomic_read(&node->type);
+
+	switch (type) {
+	case SSDFS_BTREE_INDEX_NODE:
+	case SSDFS_BTREE_HYBRID_NODE:
+	case SSDFS_BTREE_LEAF_NODE:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_WARN("invalid node type %#x\n", type);
+		return -ERANGE;
+	};
+
+	down_write(&node->header_lock);
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		items_capacity = node->items_area.items_capacity;
+		break;
+	default:
+		items_capacity = 0;
+		break;
+	};
+
+	if (items_capacity == 0) {
+		if (type == SSDFS_BTREE_LEAF_NODE ||
+		    type == SSDFS_BTREE_HYBRID_NODE) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid node state: "
+				  "type %#x, items_capacity %u\n",
+				  type, items_capacity);
+			goto finish_add_node;
+		}
+	} else {
+		node->raw.dict_header.str_area.items_count = cpu_to_le16(0);
+		node->raw.dict_header.str_area.free_space =
+				cpu_to_le16((u16)node->items_area.area_size);
+
+		node->raw.dict_header.hash_table.offset = cpu_to_le16(U16_MAX);
+		node->raw.dict_header.hash_table.size = cpu_to_le16(0);
+		node->raw.dict_header.hash_table.free_space = cpu_to_le16(0);
+		node->raw.dict_header.hash_table.items_count = cpu_to_le16(0);
+
+		node->raw.dict_header.lookup_table2.offset =
+						cpu_to_le16(U16_MAX);
+		node->raw.dict_header.lookup_table2.size =
+							cpu_to_le16(0);
+		node->raw.dict_header.lookup_table2.free_space =
+							cpu_to_le16(0);
+		node->raw.dict_header.lookup_table2.items_count =
+							cpu_to_le16(0);
+	}
+
+finish_add_node:
+	up_write(&node->header_lock);
+
+	if (err)
+		return err;
+
+	err = ssdfs_btree_update_parent_node_pointer(node->tree, node);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to update parent pointer: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	ssdfs_debug_btree_node_object(node);
+
+	return 0;
+}
+
+
+static
+int ssdfs_shared_dict_btree_delete_node(struct ssdfs_btree_node *node)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	/* TODO: implement */
+	SSDFS_DBG("TODO: implement\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+	return 0;
+}
+
+
+/*
+ * ssdfs_mark_hash_table_dirty() - mark the hash table as dirty
+ * @node: node object
+ */
+static inline
+void ssdfs_mark_hash_table_dirty(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_state_bitmap *bmap;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->bmap_array.lock);
+	bmap = &node->bmap_array.bmap[SSDFS_BTREE_NODE_DIRTY_BMAP];
+	spin_lock(&bmap->lock);
+	bmap->flags |= SSDFS_HASH_TBL_IS_USING;
+	spin_unlock(&bmap->lock);
+	up_read(&node->bmap_array.lock);
+}
+
+/*
+ * ssdfs_mark_hash_table_clean() - mark the hash table as clean
+ * @node: node object
+ */
+static inline
+void ssdfs_mark_hash_table_clean(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_state_bitmap *bmap;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->bmap_array.lock);
+	bmap = &node->bmap_array.bmap[SSDFS_BTREE_NODE_DIRTY_BMAP];
+	spin_lock(&bmap->lock);
+	bmap->flags &= ~SSDFS_HASH_TBL_IS_USING;
+	spin_unlock(&bmap->lock);
+	up_read(&node->bmap_array.lock);
+}
+
+/*
+ * ssdfs_mark_lookup2_table_dirty() - mark the lookup2 table as dirty
+ * @node: node object
+ */
+static inline
+void ssdfs_mark_lookup2_table_dirty(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_state_bitmap *bmap;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->bmap_array.lock);
+	bmap = &node->bmap_array.bmap[SSDFS_BTREE_NODE_DIRTY_BMAP];
+	spin_lock(&bmap->lock);
+	bmap->flags |= SSDFS_LOOKUP_TBL2_IS_USING;
+	spin_unlock(&bmap->lock);
+	up_read(&node->bmap_array.lock);
+}
+
+/*
+ * ssdfs_mark_lookup2_table_clean() - mark the lookup2 table as clean
+ * @node: node object
+ */
+static inline
+void ssdfs_mark_lookup2_table_clean(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_state_bitmap *bmap;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->bmap_array.lock);
+	bmap = &node->bmap_array.bmap[SSDFS_BTREE_NODE_DIRTY_BMAP];
+	spin_lock(&bmap->lock);
+	bmap->flags &= ~SSDFS_LOOKUP_TBL2_IS_USING;
+	spin_unlock(&bmap->lock);
+	up_read(&node->bmap_array.lock);
+}
+
+/*
+ * ssdfs_shared_dict_btree_pre_flush_node() - pre-flush node's header
+ * @node: pointer on node object
+ *
+ * This method tries to flush node's header.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_shared_dict_btree_pre_flush_node(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_shared_dictionary_node_header dict_header;
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	size_t ltbl_desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t htbl_desc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	struct ssdfs_btree *tree;
+	struct ssdfs_state_bitmap *bmap;
+	struct folio *folio;
+	u16 index_area_size;
+	u16 strings_count;
+	u32 str_area_offset;
+	u32 str_area_size;
+	u32 str_area_free_space;
+	u32 hash_tbl_offset;
+	u32 hash_tbl_size;
+	u16 hash_tbl_items;
+	u32 hash_tbl_free_space;
+	u32 lookup_tbl2_offset;
+	u32 lookup_tbl2_size;
+	u16 lookup_tbl2_items;
+	u32 lookup_tbl2_free_space;
+	u32 used_space;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node_id %u, state %#x\n",
+		  node->node_id, atomic_read(&node->state));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->state)) {
+	case SSDFS_BTREE_NODE_DIRTY:
+		/* expected state */
+		break;
+
+	case SSDFS_BTREE_NODE_INITIALIZED:
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u is clean\n",
+			  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return 0;
+
+	case SSDFS_BTREE_NODE_CORRUPTED:
+		SSDFS_WARN("node %u is corrupted\n",
+			   node->node_id);
+		down_read(&node->bmap_array.lock);
+		bmap = &node->bmap_array.bmap[SSDFS_BTREE_NODE_DIRTY_BMAP];
+		spin_lock(&bmap->lock);
+		bitmap_clear(bmap->ptr, 0, node->bmap_array.bits_count);
+		spin_unlock(&bmap->lock);
+		up_read(&node->bmap_array.lock);
+		clear_ssdfs_btree_node_dirty(node);
+		return -EFAULT;
+
+	default:
+		SSDFS_ERR("invalid node state %#x\n",
+			  atomic_read(&node->state));
+		return -ERANGE;
+	}
+
+	tree = node->tree;
+	if (!tree) {
+		SSDFS_ERR("node hasn't pointer on tree\n");
+		return -ERANGE;
+	}
+
+	if (tree->type != SSDFS_SHARED_DICTIONARY_BTREE) {
+		SSDFS_WARN("invalid tree type %#x\n",
+			   tree->type);
+		return -ERANGE;
+	}
+
+	down_write(&node->full_lock);
+	down_write(&node->header_lock);
+
+	ssdfs_memcpy(&dict_header, 0, hdr_size,
+		     &node->raw.dict_header, 0, hdr_size,
+		     hdr_size);
+
+	dict_header.node.magic.common = cpu_to_le32(SSDFS_SUPER_MAGIC);
+	dict_header.node.magic.key = cpu_to_le16(SSDFS_DICTIONARY_BNODE_MAGIC);
+	dict_header.node.magic.version.major = SSDFS_MAJOR_REVISION;
+	dict_header.node.magic.version.minor = SSDFS_MINOR_REVISION;
+
+	err = ssdfs_btree_node_pre_flush_header(node, &dict_header.node);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to flush generic header: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		goto finish_shared_dict_header_preparation;
+	}
+
+	switch (atomic_read(&node->index_area.state)) {
+	case SSDFS_BTREE_NODE_INDEX_AREA_EXIST:
+		index_area_size = node->index_area.area_size;
+		break;
+
+	case SSDFS_BTREE_NODE_AREA_ABSENT:
+		index_area_size = 0;
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_ERR("invalid area state %#x\n",
+			  atomic_read(&node->index_area.state));
+		goto finish_shared_dict_header_preparation;
+	}
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		switch (atomic_read(&node->lookup_tbl_area.state)) {
+		case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+			/* expected state */
+			break;
+
+		default:
+			err = -ERANGE;
+			SSDFS_ERR("lookup table is absent\n");
+			goto finish_shared_dict_header_preparation;
+		}
+
+		switch (atomic_read(&node->hash_tbl_area.state)) {
+		case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+			/* expected state */
+			break;
+
+		default:
+			err = -ERANGE;
+			SSDFS_ERR("hash table is absent\n");
+			goto finish_shared_dict_header_preparation;
+		}
+
+		strings_count = node->items_area.items_count;
+		str_area_offset = node->items_area.offset;
+		str_area_size = node->items_area.area_size;
+		str_area_free_space = node->items_area.free_space;
+
+		hash_tbl_offset = node->hash_tbl_area.offset;
+		hash_tbl_size = node->hash_tbl_area.area_size;
+		hash_tbl_items = node->hash_tbl_area.index_count;
+
+		if (hash_tbl_size < (hash_tbl_items * htbl_desc_size)) {
+			err = -ERANGE;
+			SSDFS_ERR("corrupted hash table: "
+				  "size %u, items %u, desc_size %zu\n",
+				  hash_tbl_size,
+				  hash_tbl_items,
+				  htbl_desc_size);
+			goto finish_shared_dict_header_preparation;
+		}
+
+		hash_tbl_free_space = hash_tbl_size;
+		hash_tbl_free_space -= hash_tbl_items * htbl_desc_size;
+
+		lookup_tbl2_offset = node->lookup_tbl_area.offset;
+		lookup_tbl2_size = node->lookup_tbl_area.area_size;
+		lookup_tbl2_items = node->lookup_tbl_area.index_count;
+
+		if (lookup_tbl2_size < (lookup_tbl2_items * ltbl_desc_size)) {
+			err = -ERANGE;
+			SSDFS_ERR("corrupted lookup table: "
+				  "size %u, items %u, desc_size %zu\n",
+				  lookup_tbl2_size,
+				  lookup_tbl2_items,
+				  ltbl_desc_size);
+			goto finish_shared_dict_header_preparation;
+		}
+
+		lookup_tbl2_free_space = lookup_tbl2_size;
+		lookup_tbl2_free_space -= lookup_tbl2_items * ltbl_desc_size;
+		break;
+
+	case SSDFS_BTREE_NODE_AREA_ABSENT:
+		strings_count = 0;
+		str_area_offset = node->node_size;
+		str_area_size = 0;
+		str_area_free_space = 0;
+		hash_tbl_offset = node->node_size;
+		hash_tbl_size = 0;
+		hash_tbl_items = 0;
+		hash_tbl_free_space = 0;
+		lookup_tbl2_offset = node->node_size;
+		lookup_tbl2_size = 0;
+		lookup_tbl2_items = 0;
+		lookup_tbl2_free_space = 0;
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_ERR("invalid area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		goto finish_shared_dict_header_preparation;
+	}
+
+	if (str_area_offset != (hdr_size + index_area_size)) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted strings area: "
+			  "str_area_offset %u, hdr_size %zu, "
+			  "index_area_size %u\n",
+			  str_area_offset,
+			  hdr_size,
+			  index_area_size);
+		goto finish_shared_dict_header_preparation;
+	}
+
+	if (hash_tbl_offset != (str_area_offset + str_area_size)) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted hash table: "
+			  "hash_tbl_offset %u, str_area_offset %u, "
+			  "str_area_size %u\n",
+			  hash_tbl_offset,
+			  str_area_offset,
+			  str_area_size);
+		goto finish_shared_dict_header_preparation;
+	}
+
+	if (lookup_tbl2_offset != (hash_tbl_offset + hash_tbl_size)) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted lookup table: "
+			  "lookup_tbl2_offset %u, hash_tbl_offset %u, "
+			  "hash_tbl_size %u\n",
+			  lookup_tbl2_offset,
+			  hash_tbl_offset,
+			  hash_tbl_size);
+		goto finish_shared_dict_header_preparation;
+	}
+
+	used_space = hdr_size + index_area_size;
+	used_space += str_area_size;
+	used_space += hash_tbl_size;
+	used_space += lookup_tbl2_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("hdr_size %zu, index_area_size %u, "
+		  "str_area_size %u, hash_tbl_size %u, "
+		  "lookup_tbl2_size %u\n",
+		  hdr_size, index_area_size,
+		  str_area_size, hash_tbl_size,
+		  lookup_tbl2_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (used_space != node->node_size) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted node: "
+			  "node_size %u, used_space %u\n",
+			  node->node_size,
+			  used_space);
+		goto finish_shared_dict_header_preparation;
+	}
+
+	if (str_area_free_space > str_area_size) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted node: free_space %u, area_size %u\n",
+			  str_area_free_space, str_area_size);
+		goto finish_shared_dict_header_preparation;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(str_area_offset >= U16_MAX);
+	BUG_ON(str_area_size >= U16_MAX);
+	BUG_ON(str_area_free_space >= U16_MAX);
+	BUG_ON(hash_tbl_offset >= U16_MAX);
+	BUG_ON(hash_tbl_size >= U16_MAX);
+	BUG_ON(hash_tbl_free_space >= U16_MAX);
+	BUG_ON(lookup_tbl2_offset >= U16_MAX);
+	BUG_ON(lookup_tbl2_size >= U16_MAX);
+	BUG_ON(lookup_tbl2_free_space >= U16_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	dict_header.str_area.offset = cpu_to_le16((u16)str_area_offset);
+	dict_header.str_area.size =  cpu_to_le16((u16)str_area_size);
+	dict_header.str_area.free_space = cpu_to_le16((u16)str_area_free_space);
+	dict_header.str_area.items_count = cpu_to_le16(strings_count);
+
+	dict_header.hash_table.offset = cpu_to_le16((u16)hash_tbl_offset);
+	dict_header.hash_table.size = cpu_to_le16((u16)hash_tbl_size);
+	dict_header.hash_table.free_space =
+					cpu_to_le16((u16)hash_tbl_free_space);
+	dict_header.hash_table.items_count = cpu_to_le16(hash_tbl_items);
+
+	dict_header.lookup_table2.offset = cpu_to_le16((u16)lookup_tbl2_offset);
+	dict_header.lookup_table2.size = cpu_to_le16((u16)lookup_tbl2_size);
+	dict_header.lookup_table2.free_space =
+					cpu_to_le16((u16)lookup_tbl2_free_space);
+	dict_header.lookup_table2.items_count = cpu_to_le16(lookup_tbl2_items);
+
+	dict_header.node.check.bytes = cpu_to_le16((u16)hdr_size);
+	dict_header.node.check.flags = cpu_to_le16(SSDFS_CRC32);
+
+	err = ssdfs_calculate_csum(&dict_header.node.check,
+				   &dict_header, hdr_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("unable to calculate checksum: err %d\n", err);
+		goto finish_shared_dict_header_preparation;
+	}
+
+	ssdfs_memcpy(&node->raw.dict_header, 0, hdr_size,
+		     &dict_header, 0, hdr_size,
+		     hdr_size);
+
+	ssdfs_mark_hash_table_clean(node);
+	ssdfs_mark_lookup2_table_clean(node);
+
+finish_shared_dict_header_preparation:
+	up_write(&node->header_lock);
+
+	if (unlikely(err))
+		goto finish_node_pre_flush;
+
+	if (node->content.count < 1) {
+		err = -ERANGE;
+		SSDFS_ERR("folio batch is empty\n");
+		goto finish_node_pre_flush;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(folio_batch_count(&node->content.blocks[0].batch) == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	folio = node->content.blocks[0].batch.folios[0];
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!folio);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	__ssdfs_memcpy_to_folio(folio, 0, PAGE_SIZE,
+				&dict_header, 0, hdr_size,
+				hdr_size);
+
+finish_node_pre_flush:
+	up_write(&node->full_lock);
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_flush_node() - flush node
+ * @node: pointer on node object
+ *
+ * This method tries to flush node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_shared_dict_btree_flush_node(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_btree *tree;
+	u64 fs_feature_compat;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+
+	SSDFS_DBG("node %p, node_id %u\n",
+		  node, node->node_id);
+
+	ssdfs_check_shdict_btree_node_consistency(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	tree = node->tree;
+	if (!tree) {
+		SSDFS_ERR("node hasn't pointer on tree\n");
+		return -ERANGE;
+	}
+
+	if (tree->type != SSDFS_SHARED_DICTIONARY_BTREE) {
+		SSDFS_WARN("invalid tree type %#x\n",
+			   tree->type);
+		return -ERANGE;
+	}
+
+	fsi = node->tree->fsi;
+
+	spin_lock(&fsi->volume_state_lock);
+	fs_feature_compat = fsi->fs_feature_compat;
+	spin_unlock(&fsi->volume_state_lock);
+
+	if (fs_feature_compat & SSDFS_HAS_SHARED_DICT_COMPAT_FLAG) {
+		err = ssdfs_btree_common_node_flush(node);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to flush node: "
+				  "node_id %u, height %u, err %d\n",
+				  node->node_id,
+				  atomic_read(&node->height),
+				  err);
+		}
+	} else {
+		err = -EFAULT;
+		SSDFS_CRIT("shared dictionary tree is absent\n");
+	}
+
+	ssdfs_debug_btree_node_object(node);
+
+	return err;
+}
+
+/******************************************************************************
+ *          SPECIALIZED SHARED DICTIONARY BTREE NODE OPERATIONS               *
+ ******************************************************************************/
+
+/*
+ * The lookup1 table's capacity array
+ */
+static
+const u16 lookup1_tbl_range_capacity[SSDFS_SHDIC_LTBL1_SIZE] = {
+	2,	/* 00 */
+	4,	/* 01 */
+	8,	/* 02 */
+	16,	/* 03 */
+	32,	/* 04 */
+	32,	/* 05 */
+	32,	/* 06 */
+	32,	/* 07 */
+	32,	/* 08 */
+	64,	/* 09 */
+	64,	/* 10 */
+	32,	/* 11 */
+	32,	/* 12 */
+	32,	/* 13 */
+	32,	/* 14 */
+	32,	/* 15 */
+	16,	/* 16 */
+	8,	/* 17 */
+	4,	/* 18 */
+	2,	/* 19 */
+};
+
+/*
+ * The lookup1 table's threshold array
+ */
+static
+const u16 lookup1_tbl_threshold[SSDFS_SHDIC_LTBL1_SIZE] = {
+	2,	/* 00 */
+	6,	/* 01 */
+	14,	/* 02 */
+	30,	/* 03 */
+	62,	/* 04 */
+	94,	/* 05 */
+	126,	/* 06 */
+	158,	/* 07 */
+	190,	/* 08 */
+	254,	/* 09 */
+	318,	/* 10 */
+	350,	/* 11 */
+	382,	/* 12 */
+	414,	/* 13 */
+	446,	/* 14 */
+	478,	/* 15 */
+	494,	/* 16 */
+	502,	/* 17 */
+	506,	/* 18 */
+	508,	/* 19 */
+};
+
+typedef int (*convert_hash64_to_hash_key_fn)(struct ssdfs_btree_search *search,
+					union ssdfs_shdict_search_key *value);
+
+/*
+ * ssdfs_convert_hash64_to_hash32_lo() - convert hash64 to hash32_lo
+ * @search: search object
+ * @value: search key value [out]
+ *
+ * This method tries to convert hash64 to hash32_lo.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static inline
+int ssdfs_convert_hash64_to_hash32_lo(struct ssdfs_btree_search *search,
+				      union ssdfs_shdict_search_key *value)
+{
+	u64 hash64;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search || !value);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash64 = search->request.start.hash;
+
+	if (hash64 >= U64_MAX) {
+		SSDFS_ERR("invalid hash for search\n");
+		return -ERANGE;
+	}
+
+	value->hash_lo = cpu_to_le32(SSDFS_HASH32_LO(hash64));
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("hash64 %#llx, value->hash_lo %#x\n",
+		  hash64, le32_to_cpu(value->hash_lo));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_convert_hash64_to_hash64_key() - convert hash64 to hash64 key
+ * @search: search object
+ * @value: search key value [out]
+ *
+ * This method tries to convert hash64 to hash64 key.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static inline
+int ssdfs_convert_hash64_to_hash64_key(struct ssdfs_btree_search *search,
+					union ssdfs_shdict_search_key *value)
+{
+	u64 hash64;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search || !value);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash64 = search->request.start.hash;
+
+	if (hash64 >= U64_MAX) {
+		SSDFS_ERR("invalid hash for search\n");
+		return -ERANGE;
+	}
+
+	value->hash = cpu_to_le64(hash64);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("hash64 %#llx, value->hash %#llx\n",
+		  hash64, le64_to_cpu(value->hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+typedef bool (*is_search_key_valid_fn)(union ssdfs_shdict_search_key *value);
+
+/*
+ * is_ssdfs_hash32_lo_valid() - check that hash32_lo is valid
+ * @value: search key value
+ */
+static inline
+bool is_ssdfs_hash32_lo_valid(union ssdfs_shdict_search_key *value)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!value);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return le32_to_cpu(value->hash_lo) < U32_MAX;
+}
+
+/*
+ * is_ssdfs_hash64_valid() - check that hash64 is valid
+ * @value: search key value
+ */
+static inline
+bool is_ssdfs_hash64_valid(union ssdfs_shdict_search_key *value)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!value);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return le64_to_cpu(value->hash) < U64_MAX;
+}
+
+typedef int (*search_key_compare_fn)(union ssdfs_shdict_search_key *value1,
+				     union ssdfs_shdict_search_key *value2);
+
+/*
+ * ssdfs_hash32_lo_compare() - compare hash32_lo values
+ * @value1: first search key value
+ * @value2: second search key value
+ *
+ * This method compares two hash32_lo values.
+ *
+ * RETURN:
+ * -1 - key1 < key2
+ *  0 - key1 == key2
+ *  1 - key1 > key2
+ */
+static inline
+int ssdfs_hash32_lo_compare(union ssdfs_shdict_search_key *value1,
+			    union ssdfs_shdict_search_key *value2)
+{
+	u32 hash1, hash2;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!value1 || !value2);
+
+	SSDFS_DBG("value1->name.hash_lo %#x (%#x), "
+		  "value2->name.hash_lo %#x (%#x)\n",
+		  value1->hash_lo,
+		  le32_to_cpu(value1->hash_lo),
+		  value2->hash_lo,
+		  le32_to_cpu(value2->hash_lo));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash1 = le32_to_cpu(value1->hash_lo);
+	hash2 = le32_to_cpu(value2->hash_lo);
+
+	if (hash1 == hash2)
+		return 0;
+	else if (hash1 < hash2)
+		return -1;
+	else
+		return 1;
+}
+
+/*
+ * ssdfs_hash64_compare() - compare hash64 values
+ * @value1: first search key value
+ * @value2: second search key value
+ *
+ * This method compares two hash32_hi values.
+ *
+ * RETURN:
+ * -1 - key1 < key2
+ *  0 - key1 == key2
+ *  1 - key1 > key2
+ */
+static inline
+int ssdfs_hash64_compare(union ssdfs_shdict_search_key *value1,
+			 union ssdfs_shdict_search_key *value2)
+{
+	u64 hash1, hash2;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!value1 || !value2);
+
+	SSDFS_DBG("value1->hash %#llx (%#llx), "
+		  "value2->hash %#llx (%#llx)\n",
+		  value1->hash,
+		  le64_to_cpu(value1->hash),
+		  value2->hash,
+		  le64_to_cpu(value2->hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash1 = le64_to_cpu(value1->hash);
+	hash2 = le64_to_cpu(value2->hash);
+
+	if (hash1 == hash2)
+		return 0;
+	else if (hash1 < hash2)
+		return -1;
+	else
+		return 1;
+}
+
+typedef int (*get_search_key_fn)(struct ssdfs_btree_node *node,
+				 u16 index,
+				 union ssdfs_shdict_search_key *value);
+
+/*
+ * ssdfs_get_lookup1_table_search_key() - get a search key from lookup1 table
+ * @node: node object
+ * @index: index of the item in the lookup1 table
+ * @value: search key value [out]
+ *
+ * This method tries to retrieve the descriptor from the lookup1 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_get_lookup1_table_search_key(struct ssdfs_btree_node *node,
+					u16 index,
+					union ssdfs_shdict_search_key *value)
+{
+	struct ssdfs_shdict_ltbl1_item *lookup_table;
+	int array_size = SSDFS_SHDIC_LTBL1_SIZE;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !value);
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (index >= array_size) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u >= array_size %d\n",
+			  index, array_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	lookup_table = node->raw.dict_header.lookup_table1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("LOOKUP1 TABLE DUMP\n");
+	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+			     lookup_table,
+			     sizeof(struct ssdfs_shdict_ltbl1_item) *
+				array_size);
+	SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	ssdfs_memcpy(value,
+		     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+		     &lookup_table[index],
+		     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+		     sizeof(struct ssdfs_shdict_ltbl1_item));
+	return 0;
+}
+
+/*
+ * ssdfs_get_lookup2_descriptor() - get the lookup2 descriptor
+ * @node: node object
+ * @area: pointer on lookup2 table's area descriptor
+ * @index: index of the item in the lookup2 table
+ * @desc: pointer on lookup2 table's item value [out]
+ *
+ * This method tries to retrieve the descriptor from the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_get_lookup2_descriptor(struct ssdfs_btree_node *node,
+				 struct ssdfs_btree_node_index_area *area,
+				 u16 index,
+				 struct ssdfs_shdict_ltbl2_item *desc)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	size_t item_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	u32 area_offset;
+	u32 area_size;
+	u16 items_count;
+	u32 item_offset;
+	u32 src_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !area || !desc);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("index %u\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	area_offset = area->offset;
+	area_size = area->area_size;
+	items_count = area->index_count;
+
+	if (index >= items_count) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u >= items_count %u\n",
+			  index, items_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	item_offset = (u32)index * item_size;
+	if (item_offset >= area_size) {
+		SSDFS_ERR("item_offset %u >= area_size %u\n",
+			  item_offset, area_size);
+		return -ERANGE;
+	}
+
+	item_offset += area_offset;
+	if (item_offset >= node->node_size) {
+		SSDFS_ERR("item_offset %u >= node_size %u\n",
+			  item_offset, node->node_size);
+		return -ERANGE;
+	}
+
+	err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert offset into folio: "
+			  "item_offset %u, err %d\n",
+			  item_offset, err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid folio_index: "
+			  "index %d, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(folio_batch_count(batch) == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	src_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_from_batch(desc, 0, item_size,
+				      batch, src_offset,
+				      item_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_get_lookup2_table_search_key() - get a search key from lookup2 table
+ * @node: node object
+ * @index: index of the item in the lookup2 table
+ * @value: search key value [out]
+ *
+ * This method tries to retrieve the descriptor from the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_get_lookup2_table_search_key(struct ssdfs_btree_node *node,
+					u16 index,
+					union ssdfs_shdict_search_key *value)
+{
+	struct ssdfs_btree_node_index_area lookup_tbl_area;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !value);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("index %u\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+	ssdfs_memcpy(&lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	up_read(&node->header_lock);
+
+	return ssdfs_get_lookup2_descriptor(node, &lookup_tbl_area, index,
+				(struct ssdfs_shdict_ltbl2_item *)value);
+}
+
+/*
+ * ssdfs_set_lookup2_descriptor() - set the lookup2 descriptor
+ * @node: node object
+ * @area: pointer on lookup2 table's area descriptor
+ * @index: index of the item in the lookup2 table
+ * @desc: pointer on prepared descriptor
+ *
+ * This method tries to save the descriptor into the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_set_lookup2_descriptor(struct ssdfs_btree_node *node,
+				 struct ssdfs_btree_node_index_area *area,
+				 u16 index,
+				 struct ssdfs_shdict_ltbl2_item *desc)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	size_t item_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	u32 area_offset;
+	u32 area_size;
+	u16 items_count;
+	u32 item_offset;
+	u32 dst_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !area || !desc);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("index %u\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	area_offset = area->offset;
+	area_size = area->area_size;
+	items_count = area->index_count;
+
+	if (index > items_count) {
+		SSDFS_ERR("index %u > items_count %u\n",
+			  index, items_count);
+		return -ERANGE;
+	}
+
+	item_offset = (u32)index * item_size;
+	if (item_offset >= area_size) {
+		SSDFS_ERR("item_offset %u >= area_size %u\n",
+			  item_offset, area_size);
+		return -ERANGE;
+	}
+
+	item_offset += area_offset;
+	if (item_offset >= node->node_size) {
+		SSDFS_ERR("item_offset %u >= node_size %u\n",
+			  item_offset, node->node_size);
+		return -ERANGE;
+	}
+
+	err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert offset into folio: "
+			  "item_offset %u, err %d\n",
+			  item_offset, err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid folio_index: "
+			  "index %d, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(folio_batch_count(batch) == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	dst_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_to_batch(batch, dst_offset,
+				    desc, 0, item_size,
+				    item_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_get_hash_descriptor() - get the hash descriptor
+ * @node: node object
+ * @area: pointer on hash table's area descriptor
+ * @index: index of the item in the hash table
+ * @desc: pointer on hash table's item value [out]
+ *
+ * This method tries to retrieve the descriptor from the hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_get_hash_descriptor(struct ssdfs_btree_node *node,
+			      struct ssdfs_btree_node_index_area *area,
+			      u16 index,
+			      struct ssdfs_shdict_htbl_item *desc)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	size_t item_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u32 area_offset;
+	u32 area_size;
+	u16 items_count;
+	u32 item_offset;
+	u32 src_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !area || !desc);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("index %u\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	area_offset = area->offset;
+	area_size = area->area_size;
+	items_count = area->index_count;
+
+	if (index >= items_count) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u >= items_count %u\n",
+			  index, items_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	item_offset = (u32)index * item_size;
+	if (item_offset >= area_size) {
+		SSDFS_ERR("item_offset %u >= area_size %u\n",
+			  item_offset, area_size);
+		return -ERANGE;
+	}
+
+	item_offset += area_offset;
+	if (item_offset >= node->node_size) {
+		SSDFS_ERR("item_offset %u >= node_size %u\n",
+			  item_offset, node->node_size);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("area_offset %u, area_size %u, "
+		  "items_count %u, index %u, "
+		  "item_offset %u, item_size %zu\n",
+		  area_offset, area_size,
+		  items_count, index,
+		  item_offset, item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert offset into folio: "
+			  "item_offset %u, err %d\n",
+			  item_offset, err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid folio_index: "
+			  "index %d, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(folio_batch_count(batch) == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	src_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_from_batch(desc, 0, item_size,
+				      batch, src_offset,
+				      item_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("item_offset %u, hash %#llx, str_offset %u\n",
+		  item_offset,
+		  le64_to_cpu(desc->hash),
+		  le16_to_cpu(desc->str_offset));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_get_hash_table_search_key() - get a search key from hash table
+ * @node: node object
+ * @index: index of the item in the hash table
+ * @value: search key value [out]
+ *
+ * This method tries to retrieve the descriptor from the hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_get_hash_table_search_key(struct ssdfs_btree_node *node,
+				    u16 index,
+				    union ssdfs_shdict_search_key *value)
+{
+	struct ssdfs_btree_node_index_area hash_tbl_area;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !value);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("index %u\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+	ssdfs_memcpy(&hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	up_read(&node->header_lock);
+
+	return ssdfs_get_hash_descriptor(node, &hash_tbl_area, index,
+				(struct ssdfs_shdict_htbl_item *)value);
+}
+
+/*
+ * ssdfs_set_hash_descriptor() - set the hash descriptor
+ * @node: node object
+ * @area: pointer on hash table's area descriptor
+ * @index: index of the item in the hash table
+ * @desc: pointer on prepared descriptor
+ *
+ * This method tries to save the descriptor into the hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_set_hash_descriptor(struct ssdfs_btree_node *node,
+			      struct ssdfs_btree_node_index_area *area,
+			      u16 index,
+			      struct ssdfs_shdict_htbl_item *desc)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	size_t item_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u32 area_offset;
+	u32 area_size;
+	u16 items_count;
+	u32 item_offset;
+	u32 dst_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !area || !desc);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("index %u\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	area_offset = area->offset;
+	area_size = area->area_size;
+	items_count = area->index_count;
+
+	if (index > items_count) {
+		SSDFS_ERR("index %u > items_count %u\n",
+			  index, items_count);
+		return -ERANGE;
+	}
+
+	item_offset = (u32)index * item_size;
+	if (item_offset >= area_size) {
+		SSDFS_ERR("item_offset %u >= area_size %u\n",
+			  item_offset, area_size);
+		return -ERANGE;
+	}
+
+	item_offset += area_offset;
+	if (item_offset >= node->node_size) {
+		SSDFS_ERR("item_offset %u >= node_size %u\n",
+			  item_offset, node->node_size);
+		return -ERANGE;
+	}
+
+	err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert offset into folio: "
+			  "item_offset %u, err %d\n",
+			  item_offset, err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (folio.desc.folio_index >= node->content.count) {
+		SSDFS_ERR("invalid folio_index: "
+			  "index %d, blks_count %u\n",
+			  folio.desc.folio_index,
+			  node->content.count);
+		return -ERANGE;
+	}
+
+	batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(folio_batch_count(batch) == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	dst_offset = folio.desc.offset - folio.desc.folio_offset;
+
+	err = ssdfs_memcpy_to_batch(batch, dst_offset,
+				    desc, 0, item_size,
+				    item_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy: err %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+typedef int (*correct_lower_index_fn)(int index);
+
+static inline
+int ssdfs_correct_identity_search_lower_index(int index)
+{
+	return index + 1;
+}
+
+static inline
+int ssdfs_correct_range_search_lower_index(int index)
+{
+	return index;
+}
+
+static inline
+int ssdfs_check_lower_bound(union ssdfs_shdict_search_key *key,
+			    union ssdfs_shdict_search_key *lower_bound,
+			    int index,
+			    is_search_key_valid_fn is_valid,
+			    search_key_compare_fn key_compare,
+			    int *upper_index,
+			    u16 *found_index,
+			    union ssdfs_shdict_search_key *found_key)
+{
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	int res;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!key || !lower_bound || !upper_index);
+	BUG_ON(!found_index || !found_key);
+	SSDFS_DBG("index %d\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!is_valid(lower_bound)) {
+		*upper_index = index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("upper_index %d\n",
+			  *upper_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+	} else {
+		res = key_compare(key, lower_bound);
+		if (res < 0) {
+			*upper_index = index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("upper_index %d\n",
+				  *upper_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		} else if (res == 0) {
+			*found_index = index;
+			ssdfs_memcpy(found_key, 0, key_size,
+				     lower_bound, 0, key_size,
+				     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("key is equal to lower_bound: "
+				  "found_index %u\n",
+				  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return -EEXIST;
+		} else {
+			SSDFS_DBG("needs to check upper bound\n");
+			return -EAGAIN;
+		}
+	}
+
+	return 0;
+}
+
+static inline
+int ssdfs_check_upper_bound(union ssdfs_shdict_search_key *key,
+			    union ssdfs_shdict_search_key *lower_bound,
+			    union ssdfs_shdict_search_key *upper_bound,
+			    int index, int upper_index,
+			    is_search_key_valid_fn is_valid,
+			    search_key_compare_fn key_compare,
+			    correct_lower_index_fn correct_lower_index,
+			    int *lower_index,
+			    u16 *found_index,
+			    union ssdfs_shdict_search_key *found_key)
+{
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	int res;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!key || !lower_bound || !upper_bound);
+	BUG_ON(!lower_index || !found_index || !found_key);
+	SSDFS_DBG("index %d\n", index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!is_valid(upper_bound)) {
+		*found_index = index;
+		ssdfs_memcpy(found_key, 0, key_size,
+			     lower_bound, 0, key_size,
+			     key_size);
+		SSDFS_DBG("invalid upper_bound\n");
+		return -ENODATA;
+	} else {
+		res = key_compare(key, upper_bound);
+		if (res < 0) {
+			if (index > 0 && (index + 1) < upper_index) {
+				*lower_index = correct_lower_index(index);
+
+#ifdef CONFIG_SSDFS_DEBUG
+				SSDFS_DBG("lower_index %d\n",
+					  *lower_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			} else {
+				*found_index = index;
+				ssdfs_memcpy(found_key, 0, key_size,
+					     lower_bound, 0, key_size,
+					     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+				SSDFS_DBG("no data: found_index %u\n",
+					  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+				return -ENODATA;
+			}
+		} else if (res == 0) {
+			*found_index = index + 1;
+			ssdfs_memcpy(found_key, 0, key_size,
+				     upper_bound, 0, key_size,
+				     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("key found: found_index %u\n",
+				  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return -EEXIST;
+		} else {
+			*lower_index = correct_lower_index(index);
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("lower_index %d\n",
+				  *lower_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_node_find_index_nolock() - find index in the table
+ * @node: node object
+ * @search: search object
+ * @start_index: index to start the search
+ * @range_len: maximum number of items for search
+ * @table_size: number of items in the table
+ * @hash64_to_key: pointer on function that convert hash64 to key
+ * @get_key: pointer on function that extract descriptor from the table
+ * @is_valid: pointer on function that check the validity of the key
+ * @key_compare: pointer on function that is able to compare keys
+ * @correct_lower_index: pointer on fuction to correct lower index
+ * @found_index: pointer on the found index [out]
+ * @found_key: pointer on the found key [out]
+ *
+ * This method is trying to find the search key for the requested
+ * hash value.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - no such data in the node.
+ * %-EEXIST     - exactly the requested data was found.
+ */
+static
+int ssdfs_shared_dict_node_find_index_nolock(struct ssdfs_btree_node *node,
+				    struct ssdfs_btree_search *search,
+				    u16 start_index, u16 range_len,
+				    int table_size,
+				    convert_hash64_to_hash_key_fn hash64_to_key,
+				    get_search_key_fn get_key,
+				    is_search_key_valid_fn is_valid,
+				    search_key_compare_fn key_compare,
+				    correct_lower_index_fn correct_lower_index,
+				    u16 *found_index,
+				    union ssdfs_shdict_search_key *found_key)
+{
+	union ssdfs_shdict_search_key key, lower_bound, upper_bound;
+	int index, lower_index, upper_index;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	int res;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !found_index || !found_key);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_index %u, range_len %u, table_size %d, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  start_index, range_len, table_size,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (table_size < 0) {
+		SSDFS_ERR("invalid table_size %d\n",
+			  table_size);
+		return -EINVAL;
+	}
+
+	if ((start_index + range_len) > table_size) {
+		SSDFS_ERR("invalid request: "
+			  "start_index %u, range_len %u, "
+			  "table_size %d\n",
+			  start_index, range_len, table_size);
+		return -ERANGE;
+	}
+
+	*found_index = U16_MAX;
+	memset(found_key, 0xFF, key_size);
+
+	err = hash64_to_key(search, &key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert hash to key: err %d\n", err);
+		return err;
+	}
+
+	lower_index = start_index;
+	err = get_key(node, lower_index, &lower_bound);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get key: index %u, err %d\n",
+			  lower_index, err);
+		return err;
+	}
+
+	if (!is_valid(&lower_bound)) {
+		*found_index = lower_index;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("lower_bound is invalid: found_index %u\n",
+			  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	res = key_compare(&key, &lower_bound);
+	if (res < 0) {
+		*found_index = lower_index;
+		ssdfs_memcpy(found_key, 0, key_size,
+			     &lower_bound, 0, key_size,
+			     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("search key is lesser than lower_bound: "
+			  "found_index %u\n", *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	} else if (res == 0) {
+		*found_index = lower_index;
+		ssdfs_memcpy(found_key, 0, key_size,
+			     &lower_bound, 0, key_size,
+			     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("search key is equal to lower_bound: "
+			  "found_index %u\n", *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -EEXIST;
+	}
+
+	upper_index = start_index + range_len - 1;
+	err = get_key(node, upper_index, &upper_bound);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get key: index %u, err %d\n",
+			  upper_index, err);
+		return err;
+	}
+
+	if (!is_valid(&upper_bound)) {
+		/*
+		 * continue to search
+		 */
+	} else {
+		res = key_compare(&key, &upper_bound);
+		if (res == 0) {
+			*found_index = upper_index;
+			ssdfs_memcpy(found_key, 0, key_size,
+				     &upper_bound, 0, key_size,
+				     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("search key is equal to upper_bound: "
+				  "found_index %u\n", *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return -EEXIST;
+		} else if (res > 0) {
+			*found_index = upper_index;
+			ssdfs_memcpy(found_key, 0, key_size,
+				     &upper_bound, 0, key_size,
+				     key_size);
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("search key is bigger than upper_bound: "
+				  "found_index %u\n", *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return -ENODATA;
+		}
+	}
+
+	upper_index--;
+
+	while (lower_index < upper_index) {
+		int diff = upper_index - lower_index;
+
+		index = lower_index + (diff / 2);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("lower_index %d, upper_index %d, "
+			  "diff %d, index %d\n",
+			  lower_index, upper_index, diff, index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = get_key(node, index, &lower_bound);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get key: index %u, err %d\n",
+				  index, err);
+			return err;
+		}
+
+		err = get_key(node, index + 1, &upper_bound);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get key: index %u, err %d\n",
+				  index + 1, err);
+			return err;
+		}
+
+		err = ssdfs_check_lower_bound(&key, &lower_bound, index,
+					      is_valid, key_compare,
+					      &upper_index, found_index,
+					      found_key);
+		if (err == -EEXIST) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("index %u\n",
+				  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return err;
+		} else if (err == -EAGAIN) {
+			err = ssdfs_check_upper_bound(&key,
+						      &lower_bound,
+						      &upper_bound,
+						      index,
+						      upper_index,
+						      is_valid,
+						      key_compare,
+						      correct_lower_index,
+						      &lower_index,
+						      found_index,
+						      found_key);
+			if (err == -EEXIST || err == -ENODATA) {
+				/* finish search */
+#ifdef CONFIG_SSDFS_DEBUG
+				SSDFS_DBG("index %u\n",
+					  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+				return err;
+			}
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("lower_index %d, upper_index %d\n",
+			  lower_index, upper_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+	};
+
+	if (lower_index > upper_index) {
+		SSDFS_ERR("lower_index %d > upper_index %d\n",
+			  lower_index, upper_index);
+		return -ERANGE;
+	}
+
+	*found_index = lower_index;
+
+	err = get_key(node, *found_index, &lower_bound);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get key: index %u, err %d\n",
+			  *found_index, err);
+		return err;
+	}
+
+	ssdfs_memcpy(found_key, 0, key_size,
+		     &lower_bound, 0, key_size,
+		     key_size);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("no data: index %u\n",
+		  *found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_shared_dict_node_find_lookup1_index() - find lookup1 index
+ * @node: node object
+ * @search: search object
+ * @index: lookup index [out]
+ *
+ * This method tries to find a lookup1 index for requested items.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - lookup1 index doesn't exist for requested hash.
+ */
+static
+int ssdfs_shared_dict_node_find_lookup1_index(struct ssdfs_btree_node *node,
+					      struct ssdfs_btree_search *search,
+					      u16 *index)
+{
+	union ssdfs_shdict_search_key found;
+	struct ssdfs_name_string *name;
+	int array_size = SSDFS_SHDIC_LTBL1_SIZE;
+#ifdef CONFIG_SSDFS_DEBUG
+	int i;
+#endif /* CONFIG_SSDFS_DEBUG */
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !index);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+for (i = 0; i < array_size; i++) {
+	err = ssdfs_get_lookup1_table_search_key(node, i, &found);
+	if (err)
+		break;
+
+	SSDFS_DBG("LTBL1 item[%d]: hash_lo %#x, "
+		  "start_index %u, range_len %u\n",
+		  i,
+		  le32_to_cpu(found.ltbl1_item.hash_lo),
+		  le16_to_cpu(found.ltbl1_item.start_index),
+		  le16_to_cpu(found.ltbl1_item.range_len));
+}
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_shared_dict_node_find_index_nolock(node, search,
+					0, array_size, array_size,
+					ssdfs_convert_hash64_to_hash32_lo,
+					ssdfs_get_lookup1_table_search_key,
+					is_ssdfs_hash32_lo_valid,
+					ssdfs_hash32_lo_compare,
+					ssdfs_correct_range_search_lower_index,
+					index, &found);
+
+	up_read(&node->header_lock);
+
+	switch (err) {
+	case -EEXIST:
+		err = 0;
+		/* FALLTHRU */
+		fallthrough;
+	case -ENODATA:
+		/* FALLTHRU */
+		fallthrough;
+	default:
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(*index >= array_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("unexpected name buffer's state\n");
+			return -ERANGE;
+		}
+
+		name = search->result.name_buf.place.name;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		name->lookup.index = *index;
+		ssdfs_memcpy(&name->lookup.desc,
+			     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+			     &found,
+			     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+			     sizeof(struct ssdfs_shdict_ltbl1_item));
+		break;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("index %u, hash_lo %#x, start_index %u, range_len %u\n",
+		  *index,
+		  le32_to_cpu(name->lookup.desc.hash_lo),
+		  le16_to_cpu(name->lookup.desc.start_index),
+		  le16_to_cpu(name->lookup.desc.range_len));
+
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * ssdfs_lookup2_table_process_hash_collision() - process hash collision
+ * @node: node object
+ * @search: search object
+ * @table_size: number of items in the table
+ * @index: strings range index [out]
+ * @found: pointer on the found key [out]
+ *
+ * This method tries to process a hash collision in the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_lookup2_table_process_hash_collision(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search,
+					int table_size,
+					u16 *index,
+					union ssdfs_shdict_search_key *found)
+{
+	union ssdfs_shdict_search_key lookup2_key;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	union ssdfs_shdict_search_key hash_key;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	u64 req_hash;
+	u64 found_hash;
+	u16 lookup2_index;
+	u16 hash_index;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !index || !found);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("hash table is absent\n");
+		return -ERANGE;
+	}
+
+	SSDFS_DBG("node_id %u, table_size %d, index %u\n",
+		  node->node_id, table_size, *index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	req_hash = search->request.start.hash;
+
+	ltbl2_item = (struct ssdfs_shdict_ltbl2_item *)found;
+	found_hash = le64_to_cpu(ltbl2_item->hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("req_hash %#llx,  found_hash %#llx\n",
+		  req_hash, found_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (req_hash != found_hash) {
+		SSDFS_ERR("invalid request: req_hash %#llx, found_hash %#llx\n",
+			  req_hash, found_hash);
+		return -ERANGE;
+	}
+
+	hash_index = le16_to_cpu(ltbl2_item->hash_index);
+
+	err = ssdfs_get_hash_table_search_key(node,
+					      hash_index,
+					      &hash_key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash key: "
+			  "node_id %u, index %u, err %d\n",
+			  node->node_id, hash_index, err);
+		return err;
+	}
+
+	found_hash = le64_to_cpu(hash_key.hash);
+
+	if (req_hash < found_hash) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("position has been found: "
+			  "lookup2 index %u\n",
+			  *index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_process_hash_collision;
+	}
+
+	do {
+		lookup2_index = *index + 1;
+
+		if (lookup2_index >= table_size) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("lookup2_index %u >= table_size %d\n",
+				  lookup2_index, table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+			goto finish_process_hash_collision;
+		}
+
+		err = ssdfs_get_lookup2_table_search_key(node,
+							 lookup2_index,
+							 &lookup2_key);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, lookup2_index, err);
+			return err;
+		}
+
+		if (!is_ssdfs_hash64_valid(&lookup2_key)) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("lookup2_key is not valid: "
+				  "lookup2_index %u\n",
+				  lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			goto finish_process_hash_collision;
+		}
+
+		ltbl2_item = (struct ssdfs_shdict_ltbl2_item *)&lookup2_key;
+		found_hash = le64_to_cpu(ltbl2_item->hash);
+
+		if (req_hash == found_hash) {
+			*index = lookup2_index;
+
+			ssdfs_memcpy(found, 0, key_size,
+				     &lookup2_key, 0, key_size,
+				     key_size);
+		} else if (req_hash < found_hash) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("position has been found: "
+				  "lookup2 index %u\n",
+				  *index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			goto finish_process_hash_collision;
+		} else {
+			SSDFS_ERR("corrupted lookup2 table state: "
+				  "req_hash %#llx > found_hash %#llx\n",
+				  req_hash, found_hash);
+			return -ERANGE;
+		}
+
+		hash_index = le16_to_cpu(ltbl2_item->hash_index);
+
+		err = ssdfs_get_hash_table_search_key(node,
+						      hash_index,
+						      &hash_key);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, hash_index, err);
+			return err;
+		}
+
+		found_hash = le64_to_cpu(hash_key.hash);
+
+		if (req_hash < found_hash) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("position has been found: "
+				  "lookup2 index %u\n",
+				  *index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			goto finish_process_hash_collision;
+		}
+	} while (lookup2_index < table_size);
+
+finish_process_hash_collision:
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_node_find_lookup2_index() - find lookup2 index
+ * @node: node object
+ * @search: search object
+ * @index: strings range index [out]
+ *
+ * This method tries to find a lookup2 index for requested items.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOMEM     - fail to allocate the memory.
+ * %-ENODATA    - lookup2 index doesn't exist for requested hash.
+ */
+static
+int ssdfs_shared_dict_node_find_lookup2_index(struct ssdfs_btree_node *node,
+					      struct ssdfs_btree_search *search,
+					      u16 *index)
+{
+	union ssdfs_shdict_search_key found;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	struct ssdfs_btree_search_buffer *buf;
+	struct ssdfs_name_string *name;
+	size_t ldesc_size = sizeof(struct ssdfs_lookup_descriptor);
+	size_t ltbl2_item_len = sizeof(struct ssdfs_shdict_ltbl2_item);
+	int table_size;
+	int array_size;
+	u16 start_index;
+	u16 range_len;
+	u16 found_items;
+	u64 req_hash;
+	u64 found_hash;
+	u16 i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !index);
+	BUG_ON(*index >= SSDFS_SHDIC_LTBL1_SIZE);
+
+	SSDFS_DBG("type %#x, flags %#x, index %u, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  *index,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->full_lock);
+	down_read(&node->header_lock);
+
+	table_size = node->lookup_tbl_area.index_capacity;
+
+	array_size = lookup1_tbl_range_capacity[*index];
+	buf = &search->result.name_buf;
+	start_index = le16_to_cpu(buf->place.name->lookup.desc.start_index);
+	range_len = le16_to_cpu(buf->place.name->lookup.desc.range_len);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("table_size %d, array_size %d, "
+		  "start_index %u, range_len %u\n",
+		  table_size, array_size,
+		  start_index, range_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (range_len > array_size) {
+		err = -ERANGE;
+		SSDFS_ERR("invalid request: "
+			  "range_len %u > array_size %d\n",
+			  range_len, array_size);
+		goto finish_lookup1_tbl_check;
+	}
+
+	if ((start_index + range_len) > table_size) {
+		err = -ERANGE;
+		SSDFS_ERR("invalid request: "
+			  "start_index %u, range_len %u, "
+			  "table_size %d\n",
+			  start_index, range_len, table_size);
+		goto finish_lookup1_tbl_check;
+	}
+
+	req_hash = search->request.start.hash;
+
+	err = ssdfs_get_lookup2_table_search_key(node,
+						 start_index,
+						 &found);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get lookup2 key: "
+			  "node_id %u, index %u, err %d\n",
+			  node->node_id, start_index, err);
+		goto finish_lookup1_tbl_check;
+	}
+
+	found_hash = le64_to_cpu(found.hash);
+
+	while (req_hash < found_hash) {
+		if (*index > 0)
+			--(*index);
+		else
+			break;
+
+		err = ssdfs_get_lookup1_table_search_key(node,
+							 *index,
+							 &found);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup1 key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, *index, err);
+			goto finish_lookup1_tbl_check;
+		}
+
+		name = search->result.name_buf.place.name;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		name->lookup.index = *index;
+		ssdfs_memcpy(&name->lookup.desc,
+			     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+			     &found,
+			     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+			     sizeof(struct ssdfs_shdict_ltbl1_item));
+
+		array_size = lookup1_tbl_range_capacity[*index];
+		buf = &search->result.name_buf;
+		start_index =
+		    le16_to_cpu(buf->place.name->lookup.desc.start_index);
+		range_len =
+		    le16_to_cpu(buf->place.name->lookup.desc.range_len);
+
+		if (range_len > array_size) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid request: "
+				  "range_len %u > array_size %d\n",
+				  range_len, array_size);
+			goto finish_lookup1_tbl_check;
+		}
+
+		if ((start_index + range_len) > table_size) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid request: "
+				  "start_index %u, range_len %u, "
+				  "table_size %d\n",
+				  start_index, range_len, table_size);
+			goto finish_lookup1_tbl_check;
+		}
+
+		err = ssdfs_get_lookup2_table_search_key(node,
+							 start_index,
+							 &found);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, start_index, err);
+			goto finish_lookup1_tbl_check;
+		}
+
+		found_hash = le64_to_cpu(found.hash);
+	}
+
+	do {
+		union ssdfs_shdict_search_key found_lookup1;
+		u16 upper_lookup1_index = *index + 1;
+		u16 upper_lookup2_index;
+
+		if (upper_lookup1_index >= SSDFS_SHDIC_LTBL1_SIZE)
+			break;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u, upper_lookup1_index %u\n",
+			  *index, upper_lookup1_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_get_lookup1_table_search_key(node,
+							 upper_lookup1_index,
+							 &found_lookup1);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup1 key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, upper_lookup1_index, err);
+			goto finish_lookup1_tbl_check;
+		}
+
+		if (!is_ssdfs_hash32_lo_valid(&found_lookup1))
+			break;
+
+		upper_lookup2_index =
+			le16_to_cpu(found_lookup1.ltbl1_item.start_index);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("start_index %u, upper_lookup2_index %u\n",
+			  start_index, upper_lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_get_lookup2_table_search_key(node,
+							 upper_lookup2_index,
+							 &found);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, upper_lookup2_index, err);
+			goto finish_lookup1_tbl_check;
+		}
+
+		found_hash = le64_to_cpu(found.hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("req_hash %#llx, found_hash %#llx\n",
+			  req_hash, found_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (req_hash < found_hash)
+			break;
+
+		*index = upper_lookup1_index;
+		name = search->result.name_buf.place.name;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		name->lookup.index = *index;
+		ssdfs_memcpy(&name->lookup.desc,
+			     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+			     &found_lookup1,
+			     0, sizeof(struct ssdfs_shdict_ltbl1_item),
+			     sizeof(struct ssdfs_shdict_ltbl1_item));
+
+		array_size = lookup1_tbl_range_capacity[*index];
+		buf = &search->result.name_buf;
+		start_index =
+		    le16_to_cpu(buf->place.name->lookup.desc.start_index);
+		range_len =
+		    le16_to_cpu(buf->place.name->lookup.desc.range_len);
+
+		if (range_len > array_size) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid request: "
+				  "range_len %u > array_size %d\n",
+				  range_len, array_size);
+			goto finish_lookup1_tbl_check;
+		}
+
+		if ((start_index + range_len) > table_size) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid request: "
+				  "start_index %u, range_len %u, "
+				  "table_size %d\n",
+				  start_index, range_len, table_size);
+			goto finish_lookup1_tbl_check;
+		}
+	} while (req_hash > found_hash);
+
+	array_size = min_t(int, array_size, table_size - start_index);
+
+finish_lookup1_tbl_check:
+	up_read(&node->header_lock);
+
+	if (unlikely(err))
+		goto finish_index_search;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_index %u, range_len %u, array_size %d\n",
+		  start_index, range_len, array_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_shared_dict_node_find_index_nolock(node, search,
+				start_index, array_size, table_size,
+				ssdfs_convert_hash64_to_hash64_key,
+				ssdfs_get_lookup2_table_search_key,
+				is_ssdfs_hash64_valid,
+				ssdfs_hash64_compare,
+				ssdfs_correct_identity_search_lower_index,
+				index, &found);
+
+	if (err == -EEXIST) {
+		err = ssdfs_lookup2_table_process_hash_collision(node, search,
+								 table_size,
+								 index,
+								 &found);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to correct hash collision: "
+				  "index %u, err %d\n",
+				  *index, err);
+			goto finish_index_search;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(*index >= table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+			/* expected state */
+			break;
+
+		default:
+			err = -ERANGE;
+			SSDFS_ERR("unexpected name buffer's state\n");
+			goto finish_index_search;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ltbl2_item = (struct ssdfs_shdict_ltbl2_item *)&found;
+		found_items = min_t(u16, (u16)ltbl2_item->str_count,
+				    (u16)search->request.count);
+
+		if (found_items == 0) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid found_items %u\n", found_items);
+			goto finish_index_search;
+		} else if (found_items > 1) {
+			err = ssdfs_btree_search_alloc_result_name(search,
+					(size_t)found_items *
+					    sizeof(struct ssdfs_name_string));
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to allocate buffer\n");
+				goto finish_index_search;
+			}
+
+			for (i = 0; i < found_items; i++) {
+				name = &buf->place.name[i];
+				ssdfs_memcpy(&name->lookup,
+					     0, ldesc_size,
+					     &search->name.string.lookup,
+					     0, ldesc_size,
+					     ldesc_size);
+
+				name->strings_range.index = *index + i;
+				ssdfs_memcpy(&name->strings_range.desc,
+					     0, ltbl2_item_len,
+					     &found,
+					     0, ltbl2_item_len,
+					     ltbl2_item_len);
+			}
+		} else {
+			buf->place.name->strings_range.index = *index;
+			ssdfs_memcpy(&buf->place.name->strings_range.desc,
+				     0, ltbl2_item_len,
+				     &found,
+				     0, ltbl2_item_len,
+				     ltbl2_item_len);
+		}
+	}
+
+finish_index_search:
+	up_read(&node->full_lock);
+
+	switch (err) {
+	case -ENODATA:
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(*index >= table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("unexpected name buffer's state\n");
+			return -ERANGE;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		buf->place.name->strings_range.index = *index;
+		ssdfs_memcpy(&buf->place.name->strings_range.desc,
+			     0, ltbl2_item_len,
+			     &found,
+			     0, ltbl2_item_len,
+			     ltbl2_item_len);
+		break;
+
+	default:
+		/* do nothing */
+		break;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("index %u\n", *index);
+
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_node_process_found_hash() - process found hash
+ * @node: node object
+ * @search: search object
+ * @found: found key
+ * @index: hash index
+ * @name: name string descriptor [out]
+ *
+ * This method tries to prepare name string descriptor.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shared_dict_node_process_found_hash(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search,
+					union ssdfs_shdict_search_key *found,
+					u16 index,
+					struct ssdfs_name_string *name)
+{
+	struct ssdfs_strings_range_descriptor *str_range;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	union ssdfs_shdict_search_key prefix;
+	union ssdfs_shdict_search_key lookup2_key;
+	union ssdfs_shdict_search_key left_name;
+	union ssdfs_shdict_search_key right_name;
+	union ssdfs_shdict_search_key key = {0};
+	struct ssdfs_btree_search_buffer *buf;
+	u16 lookup2_index;
+	u16 prefix_index;
+	u16 calculated_index;
+	int res;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !found || !name);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p, index %u\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child, index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	buf = &search->result.name_buf;
+	str_range = &buf->place.name->strings_range;
+	prefix_index = le16_to_cpu(str_range->desc.hash_index);
+
+	calculated_index = prefix_index;
+	calculated_index += str_range->desc.str_count;
+
+	if (calculated_index < index) {
+		lookup2_index = str_range->index;
+
+		do {
+			lookup2_index++;
+
+			err = ssdfs_get_lookup2_table_search_key(node,
+								 lookup2_index,
+								 &lookup2_key);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to get lookup2 key: "
+					  "node_id %u, index %u, err %d\n",
+					  node->node_id, lookup2_index, err);
+				return err;
+			}
+
+			ltbl2_item =
+				(struct ssdfs_shdict_ltbl2_item *)&lookup2_key;
+
+			prefix_index = le16_to_cpu(ltbl2_item->hash_index);
+
+			calculated_index = prefix_index;
+			calculated_index += ltbl2_item->str_count;
+		} while (calculated_index < index);
+
+		buf->place.name->strings_range.index = lookup2_index;
+		ssdfs_memcpy(&buf->place.name->strings_range.desc,
+			     0, sizeof(struct ssdfs_shdict_ltbl2_item),
+			     &lookup2_key,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_ltbl2_item));
+
+		err = ssdfs_get_hash_table_search_key(node, prefix_index,
+						      &prefix);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash item: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, prefix_index, err);
+			return err;
+		}
+
+		name->prefix.index = prefix_index;
+		ssdfs_memcpy(&name->prefix.desc,
+			     0, sizeof(struct ssdfs_shdict_htbl_item),
+			     &prefix,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_htbl_item));
+	} else {
+		err = ssdfs_get_hash_table_search_key(node, prefix_index,
+						      &prefix);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash item: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, str_range->index, err);
+			return err;
+		}
+
+		name->prefix.index = prefix_index;
+		ssdfs_memcpy(&name->prefix.desc,
+			     0, sizeof(struct ssdfs_shdict_htbl_item),
+			     &prefix,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_htbl_item));
+	}
+
+	switch (name->prefix.desc.type) {
+	case SSDFS_FULL_NAME:
+		name->right_name.index = index;
+		ssdfs_memcpy(&name->right_name.desc,
+			     0, sizeof(struct ssdfs_shdict_htbl_item),
+			     found,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_htbl_item));
+		break;
+
+	case SSDFS_NAME_PREFIX:
+		if (index == prefix_index) {
+			/* switch from prefix to name */
+			index++;
+		}
+
+		err = ssdfs_get_hash_table_search_key(node, index,
+						      &right_name);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash item: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, index, err);
+			return err;
+		}
+
+		err = ssdfs_convert_hash64_to_hash64_key(search, &key);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to convert hash to key: err %d\n",
+				  err);
+			return err;
+		}
+
+		res = ssdfs_hash64_compare(&key, &right_name);
+		if (res > 0 && (index + 1) < calculated_index) {
+			index++;
+
+			err = ssdfs_get_hash_table_search_key(node, index,
+							      &right_name);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to get hash item: "
+					  "node_id %u, index %u, err %d\n",
+					  node->node_id, index, err);
+				return err;
+			}
+		}
+
+		name->right_name.index = index;
+		ssdfs_memcpy(&name->right_name.desc,
+			     0, sizeof(struct ssdfs_shdict_htbl_item),
+			     &right_name,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_htbl_item));
+		break;
+
+	default:
+		SSDFS_ERR("invalid prefix type %#x\n",
+			  name->prefix.desc.type);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(index < prefix_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if ((index - prefix_index) > 1) {
+		u16 left_name_index = index - 1;
+
+		err = ssdfs_get_hash_table_search_key(node, left_name_index,
+						      &left_name);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash item: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, left_name_index, err);
+			return err;
+		}
+
+		name->left_name.index = left_name_index;
+		ssdfs_memcpy(&name->left_name.desc,
+			     0, sizeof(struct ssdfs_shdict_htbl_item),
+			     &left_name,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_htbl_item));
+	} else {
+		err = ssdfs_get_hash_table_search_key(node, index,
+						      &left_name);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash item: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, index, err);
+			return err;
+		}
+
+		name->left_name.index = index;
+		ssdfs_memcpy(&name->left_name.desc,
+			     0, sizeof(struct ssdfs_shdict_htbl_item),
+			     &left_name,
+			     0, sizeof(union ssdfs_shdict_search_key),
+			     sizeof(struct ssdfs_shdict_htbl_item));
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_node_find_hash_index() - find hash index
+ * @node: node object
+ * @search: search object
+ * @index: hash index [out]
+ *
+ * This method tries to find a hash index for requested items.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - hash index doesn't exist for requested hash.
+ */
+static
+int ssdfs_shared_dict_node_find_hash_index(struct ssdfs_btree_node *node,
+					   struct ssdfs_btree_search *search,
+					   u16 *index)
+{
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	union ssdfs_shdict_search_key found;
+	struct ssdfs_btree_search_buffer *buf;
+	struct ssdfs_name_string *name;
+	int table_size;
+	u16 hashes_count;
+	u16 start_index;
+	u16 range_len;
+	u32 found_items;
+	u16 cur_index;
+	u16 i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !index);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+	table_size = node->hash_tbl_area.index_capacity;
+	hashes_count = node->hash_tbl_area.index_count;
+	up_read(&node->header_lock);
+
+	buf = &search->result.name_buf;
+	ltbl2_item = &buf->place.name->strings_range.desc;
+	start_index = le16_to_cpu(ltbl2_item->hash_index);
+	range_len = ltbl2_item->str_count;
+
+	if ((start_index + range_len) > table_size) {
+		SSDFS_ERR("invalid request: "
+			  "start_index %u, range_len %u, "
+			  "table_size %d\n",
+			  start_index, range_len, table_size);
+		return -ERANGE;
+	}
+
+	down_read(&node->full_lock);
+
+	err = ssdfs_shared_dict_node_find_index_nolock(node, search,
+				start_index, range_len, table_size,
+				ssdfs_convert_hash64_to_hash64_key,
+				ssdfs_get_hash_table_search_key,
+				is_ssdfs_hash64_valid,
+				ssdfs_hash64_compare,
+				ssdfs_correct_identity_search_lower_index,
+				index, &found);
+
+	if (err == -EEXIST) {
+		err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(*index >= table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+			/* expected state */
+			break;
+
+		default:
+			err = -ERANGE;
+			SSDFS_ERR("unexpected name buffer's state\n");
+			goto finish_index_search;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		found_items = search->result.name_buf.size /
+				sizeof(struct ssdfs_name_string);
+
+		if (found_items == 0) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid found_items %u\n", found_items);
+			goto finish_index_search;
+		}
+
+		if (table_size == 0) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid table_size %d\n", table_size);
+			goto finish_index_search;
+		}
+
+		found_items = min_t(u32, found_items, (u32)table_size);
+
+		for (i = 0; i < found_items; i++) {
+			cur_index = *index + i;
+
+			name = &buf->place.name[i];
+
+			err = ssdfs_shared_dict_node_process_found_hash(node,
+								search, &found,
+								cur_index,
+								name);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to process found hash: "
+					  "node_id %u, cur_index %u, err %d\n",
+					  node->node_id, cur_index, err);
+				goto finish_index_search;
+			}
+		}
+	} else if (err == -ENODATA) {
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(*index >= table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+			/* expected state */
+			break;
+
+		default:
+			SSDFS_ERR("unexpected name buffer's state\n");
+			return -ERANGE;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		name = &buf->place.name[0];
+
+		err = ssdfs_shared_dict_node_process_found_hash(node,
+							search, &found,
+							*index, name);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to process found hash: "
+				  "node_id %u, err %d\n",
+				  node->node_id, err);
+			goto finish_index_search;
+		}
+
+		/* recover error code -> node hasn't requested hash */
+		err = -ENODATA;
+	}
+
+finish_index_search:
+	up_read(&node->full_lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("index %u\n", *index);
+
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * __ssdfs_extract_string() - extract string from the items area
+ * @node: node object
+ * @items_area_offset: items area offset
+ * @items_area_size: items area size
+ * @desc: hash descriptor
+ * @buf: buffer for the string [out]
+ *
+ * The method is trying to retrieve the string for @desc
+ * from the items area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int __ssdfs_extract_string(struct ssdfs_btree_node *node,
+			   u32 items_area_offset,
+			   u32 items_area_size,
+			   struct ssdfs_shdict_htbl_item *desc,
+			   unsigned char *buf)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	u32 item_offset;
+	u32 src_offset;
+	u32 upper_bound;
+	u32 copied_len = 0;
+	u32 cur_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !desc || !buf);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u, str_offset %u, str_len %u, type %#x\n",
+		  node->node_id,
+		  le16_to_cpu(desc->str_offset),
+		  desc->str_len,
+		  desc->type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	if (desc->str_len == 0 || desc->str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid string lenght\n");
+		return -ERANGE;
+	}
+
+	while (copied_len < desc->str_len) {
+		item_offset = le16_to_cpu(desc->str_offset);
+		if ((item_offset + desc->str_len) >= items_area_size) {
+			SSDFS_ERR("item_offset %u, str_len %u, area_size %u\n",
+				  item_offset, desc->str_len, items_area_size);
+			return -ERANGE;
+		}
+
+		item_offset += items_area_offset;
+		if (item_offset >= node->node_size) {
+			SSDFS_ERR("item_offset %u >= node_size %u\n",
+				  item_offset, node->node_size);
+			return -ERANGE;
+		}
+
+		item_offset += copied_len;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("str_offset %u, str_len %u, "
+			  "area_offset %u, area_size %u, "
+			  "copied_len %u, item_offset %u\n",
+			  le16_to_cpu(desc->str_offset),
+			  desc->str_len,
+			  items_area_offset, items_area_size,
+			  copied_len, item_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to convert offset into folio: "
+				  "item_offset %u, err %d\n",
+				  item_offset, err);
+			return err;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (folio.desc.folio_index >= node->content.count) {
+			SSDFS_ERR("invalid folio_index: "
+				  "index %d, blks_count %u\n",
+				  folio.desc.folio_index,
+				  node->content.count);
+			return -ERANGE;
+		}
+
+		batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(folio_batch_count(batch) == 0);
+		BUG_ON(folio.desc.folio_offset > folio.desc.offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		src_offset = folio.desc.offset - folio.desc.folio_offset;
+		upper_bound = folio.desc.folio_offset;
+		upper_bound += folio.desc.page_offset;
+		upper_bound += PAGE_SIZE;
+		cur_len = min_t(u32, (u32)desc->str_len - copied_len,
+				     (u32)upper_bound - item_offset);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("folio.desc.offset %llu, "
+			  "folio.desc.folio_offset %llu, "
+			  "src_offset %u, desc->str_len %u, "
+			  "copied_len %u, item_offset %u, "
+			  "upper_bound %u, cur_len %u\n",
+			  folio.desc.offset,
+			  folio.desc.folio_offset,
+			  src_offset, desc->str_len,
+			  copied_len, item_offset,
+			  upper_bound, cur_len);
+
+		BUG_ON(cur_len == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_memcpy_from_batch(buf,
+					      copied_len,
+					      SSDFS_MAX_NAME_LEN,
+					      batch, src_offset,
+					      cur_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to copy: err %d\n", err);
+			return err;
+		}
+
+		copied_len += cur_len;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("finished\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_extract_string() - extract string from the items area
+ * @node: node object
+ * @desc: hash descriptor
+ * @buf: buffer for the string [out]
+ *
+ * The method is trying to retrieve the string for @desc
+ * from the items area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_extract_string(struct ssdfs_btree_node *node,
+			 struct ssdfs_shdict_htbl_item *desc,
+			 unsigned char *buf)
+{
+	u32 area_offset;
+	u32 area_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !desc || !buf);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u, str_offset %u, str_len %u, type %#x\n",
+		  node->node_id,
+		  le16_to_cpu(desc->str_offset),
+		  desc->str_len,
+		  desc->type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	up_read(&node->header_lock);
+
+	return __ssdfs_extract_string(node, area_offset, area_size, desc, buf);
+}
+
+/*
+ * ssdfs_extract_name() - extract name from the node
+ * @node: node object
+ * @name: name string descriptor with buffer [in|out]
+ *
+ * The method is trying to retrieve the name from the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EIO        - node is corrupted probably.
+ */
+static
+int ssdfs_extract_name(struct ssdfs_btree_node *node,
+			struct ssdfs_name_string *name)
+{
+	u8 str_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !name);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	name->hash = le64_to_cpu(name->right_name.desc.hash);
+
+	switch (name->right_name.desc.type) {
+	case SSDFS_NAME_SUFFIX:
+		switch (name->prefix.desc.type) {
+		case SSDFS_NAME_PREFIX:
+			/* expected type */
+			break;
+
+		default:
+			SSDFS_ERR("invalid prefix type %#x\n",
+				  name->prefix.desc.type);
+			return -ERANGE;
+		}
+
+		str_len = name->prefix.desc.str_len;
+		if (str_len >= SSDFS_MAX_NAME_LEN) {
+			SSDFS_ERR("invalid prefix len %u\n",
+				  str_len);
+			return -EIO;
+		}
+
+		err = ssdfs_extract_string(node, &name->prefix.desc,
+					   name->str);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract prefix: err %d\n",
+				  err);
+			return err;
+		}
+
+		name->len = str_len;
+
+		str_len = name->right_name.desc.str_len;
+		if ((name->len + str_len) >= SSDFS_MAX_NAME_LEN) {
+			SSDFS_ERR("invalid suffix len %u\n",
+				  str_len);
+			return -EIO;
+		}
+
+		err = ssdfs_extract_string(node, &name->right_name.desc,
+					   name->str + name->len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract suffix: err %d\n",
+				  err);
+			return err;
+		}
+
+		name->len += str_len;
+		break;
+
+	case SSDFS_FULL_NAME:
+		str_len = name->right_name.desc.str_len;
+		if (str_len >= SSDFS_MAX_NAME_LEN) {
+			SSDFS_ERR("invalid suffix len %u\n",
+				  str_len);
+			return -EIO;
+		}
+
+		err = ssdfs_extract_string(node, &name->right_name.desc,
+					   name->str);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract suffix: err %d\n",
+				  err);
+			return err;
+		}
+
+		name->len = str_len;
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  name->right_name.desc.type);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_extract_range_by_hash_index() - extract the names for the hash range
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method is trying to extract the names for the hash range.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EAGAIN     - node contains not all names.
+ */
+static
+int ssdfs_extract_range_by_hash_index(struct ssdfs_btree_node *node,
+				      struct ssdfs_btree_search *search)
+{
+	struct ssdfs_name_string *name;
+	u32 found_items;
+	u32 index;
+	u32 i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	found_items = search->result.name_buf.size /
+			sizeof(struct ssdfs_name_string);
+
+	if (found_items == 0) {
+		SSDFS_ERR("invalid found_items %u\n", found_items);
+		return -ERANGE;
+	}
+
+	down_read(&node->full_lock);
+
+	for (i = 0; i < found_items; i++) {
+		name = &search->result.name_buf.place.name[i];
+
+		err = ssdfs_extract_name(node, name);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract name: "
+				  "index %u, err %d\n",
+				  i, err);
+			goto finish_extract_range;
+		} else
+			search->result.name_buf.items_count++;
+
+		if (name->hash < search->request.start.hash ||
+		    name->hash > search->request.end.hash) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("hash is out of range: "
+				  "hash %llx, start_hash %llx, end_hash %llx\n",
+				  name->hash,
+				  search->request.start.hash,
+				  search->request.end.hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+			break;
+		}
+	}
+
+	search->result.state = SSDFS_BTREE_SEARCH_VALID_ITEM;
+	search->result.start_index = name->right_name.index;
+	search->result.count = found_items;
+
+	search->result.flags |= SSDFS_BTREE_SEARCH_RESULT_HAS_NAME;
+	index = search->result.name_buf.items_count - 1;
+	name = &search->result.name_buf.place.name[index];
+	if (search->request.end.hash > name->hash)
+		err = -EAGAIN;
+
+finish_extract_range:
+	up_read(&node->full_lock);
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_find_range() - find a range of items into node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to find a range of items into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - requested range is out of the node.
+ * %-ENOMEM     - unable to allocate memory.
+ */
+static
+int ssdfs_shared_dict_btree_node_find_range(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	int state;
+	u32 area_offset;
+	u32 area_size;
+	u16 items_count;
+	u16 items_capacity;
+	u16 item_size;
+	u32 free_space;
+	bool have_enough_space;
+	u64 start_hash;
+	u64 end_hash;
+	u16 index;
+	int err = 0, res = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p, request.count %u, "
+		  "result.count %u\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child, search->request.count,
+		  search->result.count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+	state = atomic_read(&node->items_area.state);
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	items_count = node->items_area.items_count;
+	items_capacity = node->items_area.items_capacity;
+	item_size = node->items_area.item_size;
+	start_hash = node->items_area.start_hash;
+	end_hash = node->items_area.end_hash;
+	up_read(&node->header_lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("request (start_hash %#llx, end_hash %#llx), "
+		  "items_area (start_hash %#llx, end_hash %#llx)\n",
+		  search->request.start.hash, search->request.end.hash,
+		  start_hash, end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (state != SSDFS_BTREE_NODE_ITEMS_AREA_EXIST) {
+		SSDFS_ERR("invalid area state %#x\n",
+			  state);
+		return -ERANGE;
+	}
+
+	if (items_capacity == 0 || items_count > items_capacity) {
+		SSDFS_ERR("corrupted node description: "
+			  "items_count %u, items_capacity %u\n",
+			  items_count,
+			  items_capacity);
+		return -ERANGE;
+	}
+
+	if (search->request.count == 0) {
+		SSDFS_ERR("invalid request: "
+			  "request.count %u\n",
+			  search->request.count);
+		return -ERANGE;
+	}
+
+	have_enough_space = free_space > item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("free_space %u, item_size %u, have_enough_space %#x\n",
+		  free_space, item_size, have_enough_space);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (RANGE_WITHOUT_INTERSECTION(search->request.start.hash,
+					   search->request.end.hash,
+					   start_hash, end_hash)) {
+	case 0:
+		/* ranges have intersection */
+		break;
+
+	case -1: /* range1 < range2 */
+		search->result.err = -ENODATA;
+		search->result.start_index = 0;
+		search->result.count = search->request.count;
+		search->result.search_cno =
+			ssdfs_current_cno(node->tree->fsi->sb);
+		search->result.name_buf.state =
+			SSDFS_BTREE_SEARCH_INLINE_BUFFER;
+		memset(&search->name,
+			0, sizeof(struct ssdfs_name_string));
+		search->result.name_buf.place.ptr = &search->name.string;
+		search->result.name_buf.size =
+				sizeof(struct ssdfs_name_string);
+		search->result.name_buf.item_size =
+				sizeof(struct ssdfs_name_string);
+		search->result.name_buf.items_count = 0;
+		ssdfs_btree_search_free_result_buf(search);
+
+		if (have_enough_space) {
+			res = -ENODATA;
+			search->result.state =
+				SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND;
+			SSDFS_DBG("possible place has been found\n");
+		} else {
+			search->result.state =
+				SSDFS_BTREE_SEARCH_PLEASE_ADD_NODE;
+			return -ENODATA;
+		}
+		break;
+
+	case 1: /* range1 > range2 */
+		search->result.err = -ENODATA;
+		search->result.start_index = items_count;
+		search->result.count = search->request.count;
+		search->result.search_cno =
+			ssdfs_current_cno(node->tree->fsi->sb);
+		search->result.name_buf.state =
+			SSDFS_BTREE_SEARCH_INLINE_BUFFER;
+		memset(&search->name,
+			0, sizeof(struct ssdfs_name_string));
+		search->result.name_buf.place.ptr = &search->name.string;
+		search->result.name_buf.size =
+				sizeof(struct ssdfs_name_string);
+		search->result.name_buf.item_size =
+				sizeof(struct ssdfs_name_string);
+		search->result.name_buf.items_count = 0;
+		ssdfs_btree_search_free_result_buf(search);
+
+		if (have_enough_space) {
+			res = -ENODATA;
+			search->result.state =
+				SSDFS_BTREE_SEARCH_OUT_OF_RANGE;
+			SSDFS_DBG("search is out of range\n");
+		} else {
+			search->result.state =
+				SSDFS_BTREE_SEARCH_PLEASE_ADD_NODE;
+			return -ENODATA;
+		}
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (res != -ENODATA &&
+	    !RANGE_HAS_PARTIAL_INTERSECTION(search->request.start.hash,
+					    search->request.end.hash,
+					    start_hash, end_hash)) {
+		SSDFS_ERR("invalid request: "
+			  "request (start_hash %llx, end_hash %llx), "
+			  "node (start_hash %llx, end_hash %llx)\n",
+			  search->request.start.hash,
+			  search->request.end.hash,
+			  start_hash, end_hash);
+		return -ERANGE;
+	}
+
+	if (items_count == 0) {
+		search->result.state =
+			SSDFS_BTREE_SEARCH_OUT_OF_RANGE;
+
+		search->result.err = -ENODATA;
+		search->result.start_index = 0;
+		search->result.count = search->request.count;
+		search->result.search_cno =
+			ssdfs_current_cno(node->tree->fsi->sb);
+		search->result.name_buf.state =
+			SSDFS_BTREE_SEARCH_INLINE_BUFFER;
+		memset(&search->name,
+			0, sizeof(struct ssdfs_name_string));
+		search->result.name_buf.place.ptr = &search->name.string;
+		search->result.name_buf.size =
+				sizeof(struct ssdfs_name_string);
+		search->result.name_buf.item_size =
+				sizeof(struct ssdfs_name_string);
+		search->result.name_buf.items_count = 0;
+		ssdfs_btree_search_free_result_buf(search);
+		return -ENODATA;
+	}
+
+	/* Temporary prepare inline buffer for one name */
+	search->result.name_buf.state = SSDFS_BTREE_SEARCH_INLINE_BUFFER;
+	search->result.name_buf.place.ptr = &search->name.string;
+		search->result.name_buf.size = sizeof(struct ssdfs_name_string);
+	search->result.name_buf.item_size = sizeof(struct ssdfs_name_string);
+	search->result.name_buf.items_count = 0;
+
+	err = ssdfs_shared_dict_node_find_lookup1_index(node, search,
+							&index);
+	if (err == -ENODATA) {
+		/*
+		 * continue logic
+		 */
+		res = -ENODATA;
+		SSDFS_DBG("possible place has been found\n");
+		SSDFS_DBG("request.count %u, result.count %u\n",
+			  search->request.count,
+			  search->result.count);
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to find the lookup1 index: "
+			  "start_hash %llx, end_hash %llx, err %d\n",
+			  search->request.start.hash,
+			  search->request.end.hash,
+			  err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(index >= SSDFS_SHDIC_LTBL1_SIZE);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_shared_dict_node_find_lookup2_index(node, search,
+							&index);
+	if (err == -ENODATA) {
+		/*
+		 * Continue to find the hash
+		 */
+		res = -ENODATA;
+		SSDFS_DBG("possible place has been found\n");
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to find the lookup2 index: "
+			  "start_hash %llx, end_hash %llx, err %d\n",
+			  search->request.start.hash,
+			  search->request.end.hash,
+			  err);
+		return err;
+	} else {
+		/*
+		 * Lookup1 index defines range of indexes
+		 * in lookup2 table. If lookup2 index has been found
+		 * then -ENODATA needs to be reset.
+		 */
+		res = 0;
+	}
+
+	err = ssdfs_shared_dict_node_find_hash_index(node, search,
+						     &index);
+	if (err == -ENODATA) {
+		res = -ENODATA;
+		search->result.state =
+			SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND;
+		search->result.err = -ENODATA;
+		search->result.start_index = index;
+		search->result.count = search->request.count;
+		search->result.search_cno =
+			ssdfs_current_cno(node->tree->fsi->sb);
+		ssdfs_btree_search_free_result_buf(search);
+		SSDFS_DBG("possible place has been found\n");
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to find the hash index: "
+			  "start_hash %llx, end_hash %llx, err %d\n",
+			  search->request.start.hash,
+			  search->request.end.hash,
+			  err);
+		return err;
+	}
+
+	err = ssdfs_extract_range_by_hash_index(node, search);
+	search->result.search_cno = ssdfs_current_cno(node->tree->fsi->sb);
+
+	if (err == -ENODATA) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find: "
+			  "request (start_hash %#llx, end_hash %#llx), "
+			  "items_area (start_hash %#llx, end_hash %#llx)\n",
+			  search->request.start.hash,
+			  search->request.end.hash,
+			  start_hash, end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		search->result.state =
+			SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND;
+		search->result.err = -ENODATA;
+		search->result.start_index = index;
+		search->result.count = search->request.count;
+		search->result.search_cno =
+			ssdfs_current_cno(node->tree->fsi->sb);
+		ssdfs_btree_search_free_result_buf(search);
+
+		return err;
+	} else if (err == -EAGAIN) {
+		search->result.state = SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND;
+
+		if (res == -ENODATA) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("unable to find: "
+				  "request (start_hash %#llx, "
+				  "end_hash %#llx), "
+				  "items_area (start_hash %#llx, "
+				  "end_hash %#llx)\n",
+				  search->request.start.hash,
+				  search->request.end.hash,
+				  start_hash, end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return res;
+		} else {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("node contains not all requested names: "
+				  "node (start_hash %llx, end_hash %llx), "
+				  "request (start_hash %llx, end_hash %llx)\n",
+				  start_hash, end_hash,
+				  search->request.start.hash,
+				  search->request.end.hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return err;
+		}
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to extract range: "
+			  "node (start_hash %llx, end_hash %llx), "
+			  "request (start_hash %llx, end_hash %llx), "
+			  "err %d\n",
+			  start_hash, end_hash,
+			  search->request.start.hash,
+			  search->request.end.hash,
+			  err);
+		ssdfs_debug_btree_node_object(node);
+		return err;
+	} else {
+		if (res == -ENODATA) {
+			search->result.state =
+				SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND;
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("unable to find: "
+				  "request (start_hash %#llx, "
+				  "end_hash %#llx), "
+				  "items_area (start_hash %#llx, "
+				  "end_hash %#llx)\n",
+				  search->request.start.hash,
+				  search->request.end.hash,
+				  start_hash, end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return res;
+		}
+	}
+
+	search->request.flags &= ~SSDFS_BTREE_SEARCH_INLINE_BUF_HAS_NEW_ITEM;
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_find_item() - find item into node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to find an item into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shared_dict_btree_node_find_item(struct ssdfs_btree_node *node,
+					   struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search->request.count != 1 ||
+	    search->request.start.hash != search->request.end.hash) {
+		SSDFS_ERR("invalid request state: "
+			  "count %d, start_hash %llx, end_hash %llx\n",
+			  search->request.count,
+			  search->request.start.hash,
+			  search->request.end.hash);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_check_shdict_btree_node_consistency(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return ssdfs_shared_dict_btree_node_find_range(node, search);
+}
+
+static
+int ssdfs_shared_dict_btree_node_allocate_item(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("operation is unavailable\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+	return -EOPNOTSUPP;
+}
+
+static
+int ssdfs_shared_dict_btree_node_allocate_range(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("operation is unavailable\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+	return -EOPNOTSUPP;
+}
+
+/*
+ * ssdfs_check_items_area() - check items area
+ * @node: pointer on node object
+ * @area: pointer on items area descriptor [in]
+ *
+ * This method tries to check the items area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ * %-ENOSPC     - node hasn't free items.
+ */
+static
+int ssdfs_check_items_area(struct ssdfs_btree_node *node,
+			   struct ssdfs_btree_node_items_area *area)
+{
+	u16 free_items;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !area);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (area->area_size == 0 ||
+	    area->area_size >= node->node_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid area_size %u\n",
+			  area->area_size);
+		return -EFAULT;
+	}
+
+	if ((area->offset + area->area_size) > node->node_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid area: offset %u, "
+			  "area_size %u, node_size %u\n",
+			  area->offset, area->area_size,
+			  node->node_size);
+		return -EFAULT;
+	}
+
+	if (area->items_capacity == 0 ||
+	    area->items_capacity < area->items_count) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid items accounting: "
+			  "node_id %u, items_capacity %u, items_count %u\n",
+			  node->node_id, area->items_capacity,
+			  area->items_count);
+		return -EFAULT;
+	}
+
+	if (area->min_item_size != SSDFS_DENTRY_INLINE_NAME_MAX_LEN ||
+	    area->max_item_size != SSDFS_MAX_NAME_LEN) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("min_item_size %u, max_item_size %u\n",
+			  area->min_item_size, area->max_item_size);
+		return -EFAULT;
+	}
+
+	if (area->free_space > area->area_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("free_space %u > area_size %u\n",
+			  area->free_space, area->area_size);
+		return -EFAULT;
+	}
+
+	free_items = area->items_capacity - area->items_count;
+	if (unlikely(free_items < 0)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_WARN("invalid free_items %d\n",
+			   free_items);
+		return -EFAULT;
+	}
+
+	if (((u64)free_items * area->min_item_size) > area->free_space) {
+		SSDFS_DBG("node_id %u, items_capacity %u, items_count %u, "
+			  "item_size %u, free_items %d, min_items_size %u, "
+			  "free_space %u\n",
+			  node->node_id, area->items_capacity,
+			  area->items_count, area->item_size,
+			  free_items, area->min_item_size,
+			  area->free_space);
+	}
+
+	if (area->free_space < area->item_size) {
+		SSDFS_DBG("node %u hasn't free space\n", node->node_id);
+		return -ENOSPC;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_check_lookup2_table_area() - check lookup2 area
+ * @node: pointer on node object
+ * @area: pointer on lookup2 area descriptor [in]
+ *
+ * This method tries to check the lookup2 area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_check_lookup2_table_area(struct ssdfs_btree_node *node,
+				   struct ssdfs_btree_node_index_area *area)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !area);
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (area->index_capacity == 0 && area->index_count == 0) {
+		if (area->area_size != 0) {
+			atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+			SSDFS_ERR("invalid area: offset %u, area_size %u, "
+				  "index_size %u, index_count %u, "
+				  "index_capacity %u\n",
+				  area->offset, area->area_size,
+				  area->index_size, area->index_count,
+				  area->index_capacity);
+			return -EFAULT;
+		}
+	} else {
+		if (area->area_size == 0 ||
+		    area->area_size >= node->node_size) {
+			atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+			SSDFS_ERR("invalid area: offset %u, area_size %u, "
+				  "index_size %u, index_count %u, "
+				  "index_capacity %u\n",
+				  area->offset, area->area_size,
+				  area->index_size, area->index_count,
+				  area->index_capacity);
+			return -EFAULT;
+		}
+	}
+
+	if ((area->offset + area->area_size) > node->node_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid area: offset %u, "
+			  "area_size %u, node_size %u\n",
+			  area->offset, area->area_size,
+			  node->node_size);
+		return -EFAULT;
+	}
+
+	if (area->index_size != sizeof(struct ssdfs_shdict_ltbl2_item)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid index size %u\n",
+			  area->index_size);
+		return -EFAULT;
+	}
+
+	if (area->index_capacity != 0 || area->index_count != 0) {
+		if (area->index_capacity == 0 ||
+		    area->index_capacity < area->index_count) {
+			atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+			SSDFS_ERR("invalid indexes accounting: "
+				  "node_id %u, index_capacity %u, "
+				  "index_count %u\n",
+				  node->node_id, area->index_capacity,
+				  area->index_count);
+			return -EFAULT;
+		}
+	}
+
+	if (((u32)area->index_capacity * area->index_size) > area->area_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid index capacity: "
+			  "node_id %u, index_capacity %u, "
+			  "index_size %u, area_size %u\n",
+			  node->node_id, area->index_capacity,
+			  area->index_size, area->area_size);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_check_hash_table_area() - check hash table's area
+ * @node: pointer on node object
+ * @area: pointer on hash table's area descriptor [in]
+ *
+ * This method tries to check the hash table's area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_check_hash_table_area(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_node_index_area *area)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+#ifdef CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK
+	int i;
+#endif /* CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK */
+
+	BUG_ON(!node || !area);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (area->index_capacity == 0 && area->index_count == 0) {
+		if (area->area_size != 0) {
+			atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+			SSDFS_ERR("invalid area: offset %u, area_size %u, "
+				  "index_size %u, index_count %u, "
+				  "index_capacity %u\n",
+				  area->offset, area->area_size,
+				  area->index_size, area->index_count,
+				  area->index_capacity);
+			return -EFAULT;
+		}
+	} else {
+		if (area->area_size == 0 ||
+		    area->area_size >= node->node_size) {
+			atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+			SSDFS_ERR("invalid area: offset %u, area_size %u, "
+				  "index_size %u, index_count %u, "
+				  "index_capacity %u\n",
+				  area->offset, area->area_size,
+				  area->index_size, area->index_count,
+				  area->index_capacity);
+			return -EFAULT;
+		}
+	}
+
+	if ((area->offset + area->area_size) > node->node_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid area: offset %u, "
+			  "area_size %u, node_size %u\n",
+			  area->offset, area->area_size,
+			  node->node_size);
+		return -EFAULT;
+	}
+
+	if (area->index_size != sizeof(struct ssdfs_shdict_htbl_item)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid index size %u\n",
+			  area->index_size);
+		return -EFAULT;
+	}
+
+	if (area->index_capacity != 0 || area->index_count != 0) {
+		if (area->index_capacity == 0 ||
+		    area->index_capacity < area->index_count) {
+			atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+			SSDFS_ERR("invalid indexes accounting: "
+				  "node_id %u, index_capacity %u, "
+				  "index_count %u\n",
+				  node->node_id, area->index_capacity,
+				  area->index_count);
+			return -EFAULT;
+		}
+	}
+
+	if (((u32)area->index_capacity * area->index_size) > area->area_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid index capacity: "
+			  "node_id %u, index_capacity %u, "
+			  "index_size %u, area_size %u\n",
+			  node->node_id, area->index_capacity,
+			  area->index_size, area->area_size);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+#ifdef CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK
+	for (i = 0; i < area->index_count; i++) {
+		struct ssdfs_shdict_htbl_item desc;
+		unsigned char name[SSDFS_MAX_NAME_LEN] = {0};
+		u64 found_hash;
+		u64 calculated_hash;
+		int err;
+
+		err = ssdfs_get_hash_descriptor(node, area, i, &desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash key: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, i, err);
+			return err;
+		}
+
+		found_hash = le64_to_cpu(desc.hash);
+
+		err = __ssdfs_extract_string(node,
+					     node->items_area.offset,
+					     node->items_area.area_size,
+					     &desc, name);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract name string: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, i, err);
+			return err;
+		}
+
+		calculated_hash = __ssdfs_generate_name_hash(name,
+					    desc.str_len,
+					    SSDFS_DENTRY_INLINE_NAME_MAX_LEN);
+		if (calculated_hash == U64_MAX) {
+			SSDFS_ERR("fail to generate hash: "
+				  "node_id %u, index %u\n",
+				  node->node_id, i);
+			return -ERANGE;
+		}
+
+		if (found_hash != calculated_hash) {
+			SSDFS_ERR("node is corrupted: "
+				  "node_id %u, index %u, "
+				  "found_hash %#llx, calculated_hash %#llx, "
+				  "name %s\n",
+				  node->node_id, i,
+				  found_hash, calculated_hash,
+				  name);
+			BUG();
+		}
+	}
+#endif /* CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK */
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * is_ssdfs_left_full_name() - check that left name is full name
+ */
+static inline
+bool is_ssdfs_left_full_name(struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return search->name.string.left_name.desc.type == SSDFS_FULL_NAME;
+}
+
+/*
+ * is_ssdfs_right_full_name() - check that right name is full name
+ */
+static inline
+bool is_ssdfs_right_full_name(struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return search->name.string.right_name.desc.type == SSDFS_FULL_NAME;
+}
+
+/*
+ * ssdfs_extract_intersection() - extract the intersection of two strings
+ * @node: pointer on node object
+ * @str1: descriptor of the first string
+ * @str2: pointer on the buffer of the second string
+ * @str2_len: length of the second string
+ * @len: pointer on value of found intersection [out]
+ *
+ * This method tries to extract the intersection of two strings.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_extract_intersection(struct ssdfs_btree_node *node,
+				struct ssdfs_string_descriptor *str1,
+				const char *str2, size_t str2_len,
+				u16 *len)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	void *kaddr;
+	u32 area_offset;
+	u32 area_size;
+	u32 item_offset;
+	u32 upper_bound;
+	size_t full_len, cur_len;
+	u32 page_offset;
+	u32 processed_len = 0;
+	u32 i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !str1 || !str2 || !len);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u, str1 %p, str2 %p, str2_len %zu\n",
+		  node->node_id, str1, str2, str2_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+	*len = 0;
+
+	down_read(&node->header_lock);
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	up_read(&node->header_lock);
+
+	if (!str2) {
+		SSDFS_ERR("empty str2 pointer\n");
+		return -ERANGE;
+	}
+
+	if (str1->desc.str_len == 0 || str2_len == 0) {
+		SSDFS_ERR("invalid string length: "
+			  "str1 %u, str2 %zu\n",
+			  str1->desc.str_len,
+			  str2_len);
+		return -ERANGE;
+	}
+
+	full_len = min_t(size_t,
+			(size_t)str1->desc.str_len,
+			str2_len);
+
+	if (full_len == 0) {
+		SSDFS_ERR("full_len == 0\n");
+		return -ERANGE;
+	}
+
+	while (processed_len < full_len) {
+		item_offset = le16_to_cpu(str1->desc.str_offset);
+		if ((item_offset + str1->desc.str_len) >= area_size) {
+			SSDFS_ERR("item_offset %u, str_len %u, area_size %u\n",
+				  item_offset, str1->desc.str_len, area_size);
+			return -ERANGE;
+		}
+
+		item_offset += area_offset;
+		if (item_offset >= node->node_size) {
+			SSDFS_ERR("item_offset %u >= node_size %u\n",
+				  item_offset, node->node_size);
+			return -ERANGE;
+		}
+
+		item_offset += processed_len;
+
+		err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to convert offset into folio: "
+				  "item_offset %u, err %d\n",
+				  item_offset, err);
+			return err;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (folio.desc.folio_index >= node->content.count) {
+			SSDFS_ERR("invalid folio_index: "
+				  "index %d, blks_count %u\n",
+				  folio.desc.folio_index,
+				  node->content.count);
+			return -ERANGE;
+		}
+
+		err = ssdfs_find_node_content_folio(&node->content, &folio);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to find folio: err %d\n", err);
+			return err;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!folio.ptr);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (folio_size(folio.ptr) == fsi->pagesize) {
+			page_offset = folio.desc.page_offset;
+		} else {
+			page_offset =
+			    SSDFS_PAGE_OFFSET_IN_FOLIO(folio_size(folio.ptr),
+							    folio.desc.offset);
+		}
+
+		upper_bound = folio.desc.folio_offset;
+		upper_bound += folio.desc.page_offset;
+		upper_bound += PAGE_SIZE;
+		cur_len = min_t(u32, (u32)full_len - processed_len,
+				     upper_bound - item_offset);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(cur_len == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		kaddr = kmap_local_folio(folio.ptr, page_offset);
+
+		for (i = 0; i < cur_len; i++) {
+			const char *symbol1, *symbol2;
+
+			symbol1 = (u8 *)kaddr + item_offset + i;
+			symbol2 = str2 + processed_len + i;
+
+			if (*symbol1 == *symbol2)
+				*len += 1;
+			else
+				break;
+		}
+
+		kunmap_local(kaddr);
+
+		processed_len += cur_len;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("finished: len %u\n", *len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_extract_intersection_with_left_name() - extract the intersection
+ * @node: pointer on node object
+ * @search: search object
+ * @len: pointer on value of found intersection [out]
+ *
+ * This method tries to extract the intersection of the requested
+ * name with the found left name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_extract_intersection_with_left_name(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search,
+					    u16 *len)
+{
+	struct ssdfs_btree_search_buffer *buf;
+	u8 type1, type2, type3;
+	u16 index1, index2, index3;
+	u16 found_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !len);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	*len = 0;
+	buf = &search->result.name_buf;
+
+	switch (buf->state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  buf->state);
+		return -ERANGE;
+	}
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	if (buf->items_count != 1) {
+		SSDFS_ERR("unexpected names_in_buffer %u\n",
+			  buf->items_count);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	index1 = buf->place.name->prefix.index;
+	type1 = buf->place.name->prefix.desc.type;
+	index2 = buf->place.name->left_name.index;
+	type2 = buf->place.name->left_name.desc.type;
+	index3 = buf->place.name->right_name.index;
+	type3 = buf->place.name->right_name.desc.type;
+
+	switch (buf->place.name->left_name.desc.type) {
+	case SSDFS_NAME_PREFIX:
+		if (type1 != type2) {
+			SSDFS_ERR("type1 %#x != type2 %#x\n",
+				  type1, type2);
+			return -ERANGE;
+		}
+
+		if (index1 != index2) {
+			SSDFS_ERR("index1 %u != index2 %u\n",
+				  index1, index2);
+			return -ERANGE;
+		}
+
+		if (type3 != SSDFS_NAME_SUFFIX) {
+			SSDFS_ERR("invalid right name's type %#x\n",
+				  type3);
+			return -ERANGE;
+		}
+
+		if ((index2 + 1) != index3) {
+			SSDFS_ERR("invalid right name: "
+				  "left_name.index %u, right_name.index %u\n",
+				  index2, index3);
+			return -ERANGE;
+		}
+
+		err = ssdfs_extract_intersection(node,
+					&buf->place.name->left_name,
+					search->request.start.name,
+					search->request.start.name_len,
+					&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len = found_len;
+
+		if (found_len == 0)
+			goto finish_extraction;
+
+		err = ssdfs_extract_intersection(node,
+				&buf->place.name->right_name,
+				search->request.start.name + found_len,
+				search->request.start.name_len - found_len,
+				&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len += found_len;
+		break;
+
+	case SSDFS_NAME_SUFFIX:
+		if (type1 != SSDFS_NAME_PREFIX) {
+			SSDFS_ERR("unexpected prefix type %#x\n",
+				  type1);
+			return -ERANGE;
+		}
+
+		if (index1 == index2) {
+			SSDFS_ERR("index1 %u == index2 %u\n",
+				  index1, index2);
+			return -ERANGE;
+		}
+
+		err = ssdfs_extract_intersection(node,
+					&buf->place.name->prefix,
+					search->request.start.name,
+					search->request.start.name_len,
+					&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len = found_len;
+
+		if (found_len == 0)
+			goto finish_extraction;
+
+		err = ssdfs_extract_intersection(node,
+				&buf->place.name->left_name,
+				search->request.start.name + found_len,
+				search->request.start.name_len - found_len,
+				&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len += found_len;
+		break;
+
+	case SSDFS_FULL_NAME:
+		if (type1 != SSDFS_FULL_NAME) {
+			SSDFS_ERR("unexpected prefix type %#x\n",
+				  type1);
+			return -ERANGE;
+		}
+
+		if (index1 != index2) {
+			SSDFS_ERR("index1 %u != index2 %u\n",
+				  index1, index2);
+			return -ERANGE;
+		}
+
+		err = ssdfs_extract_intersection(node,
+					&buf->place.name->left_name,
+					search->request.start.name,
+					search->request.start.name_len,
+					&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len = found_len;
+		break;
+
+	default:
+		SSDFS_ERR("unexpected name type %#x\n",
+			  buf->place.name->left_name.desc.type);
+		return -ERANGE;
+	}
+
+finish_extraction:
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("finished: len %u\n", *len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_extract_intersection_with_right_name() - extract the intersection
+ * @node: pointer on node object
+ * @search: search object
+ * @len: pointer on value of found intersection [out]
+ *
+ * This method tries to extract the intersection of the requested
+ * name with the found right name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_extract_intersection_with_right_name(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search,
+					    u16 *len)
+{
+	struct ssdfs_btree_search_buffer *buf;
+	u8 type1, type2, type3;
+	u16 index1, index2, index3;
+	u16 found_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !len);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	*len = 0;
+	buf = &search->result.name_buf;
+
+	switch (buf->state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  buf->state);
+		return -ERANGE;
+	}
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	if (buf->items_count != 1) {
+		SSDFS_ERR("unexpected names_in_buffer %u\n",
+			  buf->items_count);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	index1 = buf->place.name->prefix.index;
+	type1 = buf->place.name->prefix.desc.type;
+	index2 = buf->place.name->left_name.index;
+	type2 = buf->place.name->left_name.desc.type;
+	index3 = buf->place.name->right_name.index;
+	type3 = buf->place.name->right_name.desc.type;
+
+	switch (buf->place.name->right_name.desc.type) {
+	case SSDFS_NAME_PREFIX:
+		err = ssdfs_extract_intersection(node,
+					&buf->place.name->right_name,
+					search->request.start.name,
+					search->request.start.name_len,
+					&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len = found_len;
+		break;
+
+	case SSDFS_NAME_SUFFIX:
+		if (type2 == SSDFS_NAME_PREFIX) {
+			/* the suffix was processed already */
+			*len = 0;
+			goto finish_extraction;
+		}
+
+		if (type2 == SSDFS_NAME_SUFFIX) {
+			if (type1 != SSDFS_NAME_PREFIX) {
+				SSDFS_ERR("invalid prefix type %#x\n",
+					  type1);
+				return -ERANGE;
+			}
+
+			err = ssdfs_extract_intersection(node,
+						&buf->place.name->prefix,
+						search->request.start.name,
+						search->request.start.name_len,
+						&found_len);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to extract intersection: "
+					  "err %d\n", err);
+				return err;
+			} else if (found_len >= U16_MAX) {
+				SSDFS_ERR("invalid found_len %#x\n",
+					  found_len);
+				return -ERANGE;
+			}
+
+			*len = found_len;
+
+			if (found_len == 0)
+				goto finish_extraction;
+
+			err = ssdfs_extract_intersection(node,
+				&buf->place.name->right_name,
+				search->request.start.name + found_len,
+				search->request.start.name_len - found_len,
+				&found_len);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to extract intersection: "
+					  "err %d\n", err);
+				return err;
+			} else if (found_len >= U16_MAX) {
+				SSDFS_ERR("invalid found_len %#x\n",
+					  found_len);
+				return -ERANGE;
+			}
+
+			*len += found_len;
+			goto finish_extraction;
+		}
+
+		/* unexpected state */
+		return -ERANGE;
+
+	case SSDFS_FULL_NAME:
+		err = ssdfs_extract_intersection(node,
+					&buf->place.name->right_name,
+					search->request.start.name,
+					search->request.start.name_len,
+					&found_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: err %d\n",
+				  err);
+			return err;
+		} else if (found_len >= U16_MAX) {
+			SSDFS_ERR("invalid found_len %#x\n",
+				  found_len);
+			return -ERANGE;
+		}
+
+		*len = found_len;
+		break;
+
+	case SSDFS_UNKNOWN_NAME_TYPE:
+		*len = 0;
+		break;
+
+	default:
+		SSDFS_ERR("unexpected name type %#x\n",
+			  buf->place.name->left_name.desc.type);
+		return -ERANGE;
+	}
+
+finish_extraction:
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("finished: len %u\n", *len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * is_free_space_enough() - check that the node has enough free space
+ * @node: node object
+ * @requested_size: requested size in bytes
+ */
+static inline
+bool is_free_space_enough(struct ssdfs_btree_node *node,
+			  size_t requested_size)
+{
+	u32 free_space;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, requested_size %zu\n",
+		  node->node_id, requested_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	free_space = node->items_area.free_space;
+	return free_space >= requested_size;
+}
+
+/*
+ * ssdfs_define_item_size() - define average item size
+ * @node: node object
+ */
+static inline
+u16 ssdfs_define_item_size(struct ssdfs_btree_node *node)
+{
+	u32 area_size;
+	u32 free_space;
+	u32 used_space;
+	u16 items_count;
+	u8 min_item_size;
+	u16 max_item_size;
+	u32 item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	item_size = node->items_area.item_size;
+	items_count = node->items_area.items_count;
+	min_item_size = node->items_area.min_item_size;
+	max_item_size = node->items_area.max_item_size;
+
+	used_space = area_size - free_space;
+
+	if (items_count > 0)
+		item_size = used_space / items_count;
+
+	if (item_size < min_item_size)
+		item_size = min_item_size;
+	if (item_size > max_item_size)
+		item_size = max_item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("area_size %u, free_space %u, "
+		  "used_space %u, item_size %u, "
+		  "min_item_size %u, max_item_size %u\n",
+		  area_size, free_space, used_space,
+		  item_size, min_item_size, max_item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return (u16)item_size;
+}
+
+/*
+ * ssdfs_define_items_capacity() - define items capacity
+ * @node: node object
+ */
+static inline
+u16 ssdfs_define_items_capacity(struct ssdfs_btree_node *node)
+{
+	u32 area_size;
+	u16 item_size;
+	u16 items_count;
+	u32 items_capacity;
+	u8 min_item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	area_size = node->items_area.area_size;
+	item_size = node->items_area.item_size;
+	items_count = node->items_area.items_count;
+	min_item_size = node->items_area.min_item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("area_size %u, item_size %u, items_count %u, "
+		  "min_item_size %u\n",
+		  area_size, item_size,
+		  items_count, min_item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_capacity = node->items_area.free_space / item_size;
+	if (items_capacity == 0) {
+		node->items_area.item_size = min_item_size;
+		items_capacity = node->items_area.free_space / item_size;
+		if (items_capacity == 0) {
+			SSDFS_DBG("items_capacity %u\n",
+				  items_capacity);
+			return items_count;
+		}
+	}
+
+	items_capacity += items_count;
+	if (items_capacity >= U16_MAX) {
+		SSDFS_ERR("invalid items_capacity\n");
+		return U16_MAX;
+	}
+
+	if ((items_capacity * item_size) > area_size)
+		items_capacity = area_size / item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("free_space %u, item_size %u, items_count %u, "
+		  "min_item_size %u, items_capacity %u\n",
+		  node->items_area.free_space,
+		  item_size, items_count, min_item_size,
+		  items_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return items_capacity;
+}
+
+/*
+ * ssdfs_resize_string_area() - resize the strings area
+ * @node: pointer on node object
+ * @new_offset: new offset in bytes from the node's beginning
+ * @new_size: new size of the area in bytes
+ *
+ * This method tries to resize the strings area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - not enough free space for the resize.
+ */
+static
+int ssdfs_resize_string_area(struct ssdfs_btree_node *node,
+			     u32 new_offset, u32 new_size)
+{
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 used_space;
+	u16 items_count = 0;
+	u32 items_capacity = 0;
+	u8 min_item_size;
+	u16 max_item_size;
+	u32 diff;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, new_offset %u, new_size %u\n",
+		  node->node_id, new_offset, new_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	items_count = node->items_area.items_count;
+	min_item_size = node->items_area.min_item_size;
+	max_item_size = node->items_area.max_item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("area_offset %u, area_size %u, "
+		  "free_space %u, items_count %u, "
+		  "min_item_size %u, max_item_size %u\n",
+		  area_offset, area_size,
+		  free_space, items_count,
+		  min_item_size, max_item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if ((new_offset + new_size) > node->node_size) {
+		SSDFS_ERR("invalid request: "
+			  "new_offset %u, new_size %u, node_size %u\n",
+			  new_offset, new_size, node->node_size);
+		return -ERANGE;
+	}
+
+	if ((area_offset + area_size) > node->node_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return -ERANGE;
+	}
+
+	if (area_size < free_space) {
+		SSDFS_ERR("corrupted area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		return -ERANGE;
+	}
+
+	if (new_size == 0 && new_offset != node->node_size) {
+		SSDFS_ERR("invalid request: new_offset %u, "
+			  "new_size %u, node_size %u\n",
+			  new_offset, new_size, node->node_size);
+		return -EINVAL;
+	}
+
+	used_space = area_size - free_space;
+
+	node->items_area.item_size = ssdfs_define_item_size(node);
+
+	if (new_offset == node->node_size) {
+		node->items_area.offset = node->node_size;
+		node->items_area.area_size = 0;
+		node->items_area.free_space = 0;
+		node->items_area.item_size = 0;
+		node->items_area.min_item_size = 0;
+		node->items_area.max_item_size = 0;
+		node->items_area.items_count = 0;
+		node->items_area.items_capacity = 0;
+		node->items_area.start_hash = U64_MAX;
+		node->items_area.end_hash = U64_MAX;
+		atomic_set(&node->items_area.flags, 0);
+		atomic_set(&node->items_area.state,
+				SSDFS_BTREE_NODE_AREA_ABSENT);
+
+		node->lookup_tbl_area.offset = node->node_size;
+		node->lookup_tbl_area.area_size = 0;
+		node->lookup_tbl_area.index_size = 0;
+		node->lookup_tbl_area.index_count = 0;
+		node->lookup_tbl_area.index_capacity = 0;
+		node->lookup_tbl_area.start_hash = U64_MAX;
+		node->lookup_tbl_area.end_hash = U64_MAX;
+		atomic_set(&node->lookup_tbl_area.flags, 0);
+		atomic_set(&node->lookup_tbl_area.state,
+				SSDFS_BTREE_NODE_AREA_ABSENT);
+
+		node->hash_tbl_area.offset = node->node_size;
+		node->hash_tbl_area.area_size = 0;
+		node->hash_tbl_area.index_size = 0;
+		node->hash_tbl_area.index_count = 0;
+		node->hash_tbl_area.index_capacity = 0;
+		node->hash_tbl_area.start_hash = U64_MAX;
+		node->hash_tbl_area.end_hash = U64_MAX;
+		atomic_set(&node->hash_tbl_area.flags, 0);
+		atomic_set(&node->hash_tbl_area.state,
+				SSDFS_BTREE_NODE_AREA_ABSENT);
+
+		memset(node->raw.dict_header.lookup_table1, 0xFF,
+			sizeof(struct ssdfs_shdict_ltbl1_item) *
+						SSDFS_SHDIC_LTBL1_SIZE);
+
+		atomic_and(~SSDFS_BTREE_NODE_HAS_ITEMS_AREA, &node->flags);
+		atomic_and(~SSDFS_BTREE_NODE_HAS_L2TBL, &node->flags);
+		atomic_and(~SSDFS_BTREE_NODE_HAS_HASH_TBL, &node->flags);
+		atomic_and(~SSDFS_BTREE_NODE_HAS_L1TBL, &node->flags);
+	} else if (new_offset < area_offset) {
+		diff = area_offset - new_offset;
+
+		node->items_area.offset = new_offset;
+		node->items_area.area_size += diff;
+
+		if (used_space > 0) {
+			err = ssdfs_shift_memory_range_left(node,
+							    &node->items_area,
+							    diff,
+							    used_space,
+							    diff);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to move area: err %d\n", err);
+				return err;
+			}
+		}
+
+		node->items_area.area_size -= diff;
+	} else if (new_offset > area_offset) {
+		diff = new_offset - area_offset;
+
+		if ((area_offset + diff) > node->node_size) {
+			SSDFS_ERR("fail to shift the area: "
+				 "area_offset %u, diff %u, node_size %u\n",
+				 area_offset, diff, node->node_size);
+			return -ERANGE;
+		}
+
+		node->items_area.area_size += diff;
+
+		if (used_space > 0) {
+			err = ssdfs_shift_memory_range_right(node,
+							     &node->items_area,
+							     0,
+							     used_space,
+							     diff);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to move area: err %d\n", err);
+				return err;
+			}
+		}
+
+		node->items_area.offset = new_offset;
+		node->items_area.area_size -= diff;
+	}
+
+	if (new_size == 0) {
+		/*
+		 * Do nothing. Everything is prepared already.
+		 */
+		items_count = 0;
+		items_capacity = 0;
+	} else if (new_size > area_size) {
+		/* resize case */
+
+		items_capacity = ssdfs_define_items_capacity(node);
+		if (items_capacity >= U16_MAX) {
+			node->items_area.free_space = 0;
+			return -ENOSPC;
+		}
+
+		node->items_area.area_size = new_size;
+		node->items_area.free_space += new_size - area_size;
+
+		node->items_area.items_capacity = (u16)items_capacity;
+	} else if (new_size < area_size) {
+		/* shrink case */
+
+		if (free_space < (area_size - new_size)) {
+			SSDFS_ERR("unable to shrink: "
+				  "free_space %u, area_size %u, new_size %u\n",
+				  free_space, area_size, new_size);
+			return -ENOSPC;
+		}
+
+		items_capacity = ssdfs_define_items_capacity(node);
+		if (items_capacity >= U16_MAX) {
+			node->items_area.free_space = 0;
+			return -ENOSPC;
+		}
+
+		node->items_area.area_size = new_size;
+		node->items_area.free_space -= area_size - new_size;
+		node->items_area.items_capacity = (u16)items_capacity;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u\n",
+		  items_count, items_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_show_node_block_content() - show node content's block
+ * @node: pointer on node object
+ * @offset: offset in bytes into the node
+ */
+static inline
+void ssdfs_show_node_block_content(struct ssdfs_btree_node *node,
+				   u32 offset)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	void *kaddr;
+	u32 processed_bytes;
+	int i;
+	int err;
+
+	fsi = node->tree->fsi;
+
+	err = SSDFS_OFF2FOLIO(fsi->pagesize, offset, &folio.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert offset into folio: "
+			  "offset %u, err %d\n",
+			  offset, err);
+		return;
+	}
+
+	BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+
+	SSDFS_DBG("offset %u, folio_index %d\n",
+		  offset, folio.desc.folio_index);
+
+	batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+	for (i = 0; i < folio_batch_count(batch); i++) {
+		folio.ptr = batch->folios[i];
+
+		processed_bytes = 0;
+
+		while (processed_bytes < folio_size(folio.ptr)) {
+			kaddr = kmap_local_folio(folio.ptr, processed_bytes);
+			SSDFS_DBG("PAGE DUMP: folio_index %u, offset %u\n",
+				  i, processed_bytes);
+			print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+					     kaddr,
+					     PAGE_SIZE);
+			SSDFS_DBG("\n");
+			kunmap_local(kaddr);
+
+			processed_bytes += PAGE_SIZE;
+		}
+	}
+#endif /* CONFIG_SSDFS_DEBUG */
+}
+
+/*
+ * ssdfs_resize_hash_table() - resize the hash table's area
+ * @node: pointer on node object
+ * @new_offset: new offset in bytes from the node's beginning
+ * @new_size: new size of the area in bytes
+ *
+ * This method tries to resize the hash table's area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - not enough free space for the resize.
+ */
+static
+int ssdfs_resize_hash_table(struct ssdfs_btree_node *node,
+			    u32 new_offset, u32 new_size)
+{
+	u32 area_offset;
+	u32 area_size;
+	u32 items_count;
+	u32 items_capacity;
+	u8 item_size;
+	u32 diff;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, new_offset %u, new_size %u\n",
+		  node->node_id, new_offset, new_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash table area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+	items_count = node->hash_tbl_area.index_count;
+	items_capacity = node->hash_tbl_area.index_capacity;
+	item_size = node->hash_tbl_area.index_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("BEFORE: area_offset %u, area_size %u, "
+		  "items_count %u, items_capacity %u, "
+		  "item_size %u, start_hash %#llx, end_hash %#llx\n",
+		  area_offset, area_size,
+		  items_count, items_capacity,
+		  item_size,
+		  node->hash_tbl_area.start_hash,
+		  node->hash_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if ((new_offset + new_size) > node->node_size) {
+		SSDFS_ERR("invalid request: "
+			  "new_offset %u, new_size %u, node_size %u\n",
+			  new_offset, new_size, node->node_size);
+		return -ERANGE;
+	}
+
+	if ((area_offset + area_size) > node->node_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return -ERANGE;
+	}
+
+	if (items_count > items_capacity) {
+		SSDFS_ERR("corrupted area: "
+			  "items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	}
+
+	if (item_size != sizeof(struct ssdfs_shdict_htbl_item)) {
+		SSDFS_ERR("corrupted area: "
+			  "item_size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	if (new_size % item_size) {
+		SSDFS_ERR("unaligned new area size: "
+			  "new_size %u, item_size %u\n",
+			  new_size, item_size);
+		return -ERANGE;
+	}
+
+	if (items_count == 0)
+		node->hash_tbl_area.offset = new_offset;
+	else if (new_offset < area_offset) {
+		diff = area_offset - new_offset;
+
+		if (diff % item_size) {
+			SSDFS_ERR("unaligned new area offset: "
+				  "diff %u, item_size %u\n",
+				  diff, item_size);
+			return -ERANGE;
+		}
+
+		node->hash_tbl_area.offset = new_offset;
+		node->hash_tbl_area.area_size += diff;
+
+		err = ssdfs_shift_memory_range_left2(node, &node->hash_tbl_area,
+						     diff, area_size,
+						     diff);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to move area: err %d\n", err);
+			return err;
+		}
+
+		node->hash_tbl_area.area_size -= diff;
+	} else if (new_offset > area_offset) {
+		diff = new_offset - area_offset;
+
+		if (diff % item_size) {
+			SSDFS_ERR("unaligned new area offset: "
+				  "diff %u, item_size %u\n",
+				  diff, item_size);
+			return -ERANGE;
+		}
+
+		if (diff > area_size) {
+			SSDFS_ERR("fail to shift the area: "
+				 "area_size %u, diff %u\n",
+				 area_size, diff);
+			return -ERANGE;
+		}
+
+		err = ssdfs_shift_memory_range_right2(node,
+						&node->hash_tbl_area,
+						0, items_count * item_size,
+						diff);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to move area: err %d\n", err);
+			return err;
+		}
+
+		node->hash_tbl_area.offset = new_offset;
+	}
+
+	if (new_size > area_size) {
+		/* resize case */
+
+		node->hash_tbl_area.area_size = new_size;
+
+		items_capacity = new_size / item_size;
+		if (items_capacity >= U16_MAX) {
+			SSDFS_ERR("invalid items_capacity\n");
+			return -ERANGE;
+		}
+
+		node->hash_tbl_area.index_capacity = (u16)items_capacity;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index_capacity %u\n",
+			  node->hash_tbl_area.index_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+	} else if (new_size < area_size) {
+		/* shrink case */
+
+		if ((items_count * item_size) > new_size) {
+			SSDFS_ERR("unable to shrink: "
+				  "items_count %u, item_size %u, new_size %u\n",
+				  items_count, item_size, new_size);
+			return -ENOSPC;
+		}
+
+		node->hash_tbl_area.area_size = new_size;
+
+		items_capacity = new_size / item_size;
+
+		if (items_capacity >= U16_MAX) {
+			SSDFS_ERR("invalid items_capacity\n");
+			return -ERANGE;
+		}
+
+		if (items_count > items_capacity) {
+			SSDFS_ERR("items_count %u > items_capacity %u\n",
+				  items_count, items_capacity);
+			return -ERANGE;
+		}
+
+		node->hash_tbl_area.index_capacity = (u16)items_capacity;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index_capacity %u\n",
+			  node->hash_tbl_area.index_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+	}
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if ((area_offset + area_size) > node->node_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("AFTER: area_offset %u, area_size %u, "
+		  "items_count %u, items_capacity %u, "
+		  "item_size %u, start_hash %#llx, end_hash %#llx\n",
+		  area_offset, area_size,
+		  items_count, items_capacity,
+		  item_size,
+		  node->hash_tbl_area.start_hash,
+		  node->hash_tbl_area.end_hash);
+	ssdfs_show_node_block_content(node, area_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_resize_lookup2_table() - resize the lookup2 table's area
+ * @node: pointer on node object
+ * @new_offset: new offset in bytes from the node's beginning
+ * @new_size: new size of the area in bytes
+ *
+ * This method tries to resize the lookup2 table's area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - not enough free space for the resize.
+ */
+static
+int ssdfs_resize_lookup2_table(struct ssdfs_btree_node *node,
+				u32 new_offset, u32 new_size)
+{
+	u32 area_offset;
+	u32 area_size;
+	u32 items_count;
+	u32 items_capacity;
+	u8 item_size;
+	u32 diff;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, new_offset %u, new_size %u\n",
+		  node->node_id, new_offset, new_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup2 table area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	area_offset = node->lookup_tbl_area.offset;
+	area_size = node->lookup_tbl_area.area_size;
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+	item_size = node->lookup_tbl_area.index_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("BEFORE: area_offset %u, area_size %u, "
+		  "items_count %u, items_capacity %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  area_offset, area_size,
+		  items_count, items_capacity,
+		  node->lookup_tbl_area.start_hash,
+		  node->lookup_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if ((new_offset + new_size) > node->node_size) {
+		SSDFS_ERR("invalid request: "
+			  "new_offset %u, new_size %u, node_size %u\n",
+			  new_offset, new_size, node->node_size);
+		return -ERANGE;
+	}
+
+	if ((area_offset + area_size) > node->node_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return -ERANGE;
+	}
+
+	if (items_count > items_capacity) {
+		SSDFS_ERR("corrupted area: "
+			  "items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	}
+
+	if (item_size != sizeof(struct ssdfs_shdict_ltbl2_item)) {
+		SSDFS_ERR("corrupted area: "
+			  "item_size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	if (new_size % item_size) {
+		SSDFS_ERR("unaligned new area size: "
+			  "new_size %u, item_size %u\n",
+			  new_size, item_size);
+		return -ERANGE;
+	}
+
+	if (items_count == 0)
+		node->lookup_tbl_area.offset = new_offset;
+	else if (new_offset < area_offset) {
+		diff = area_offset - new_offset;
+
+		if (diff % item_size) {
+			SSDFS_ERR("unaligned new area offset: "
+				  "diff %u, item_size %u\n",
+				  diff, item_size);
+			return -ERANGE;
+		}
+
+		node->lookup_tbl_area.offset = new_offset;
+		node->lookup_tbl_area.area_size += diff;
+
+		err = ssdfs_shift_memory_range_left2(node,
+						     &node->lookup_tbl_area,
+						     diff, area_size,
+						     diff);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to move area: err %d\n", err);
+			return err;
+		}
+
+		node->lookup_tbl_area.area_size -= diff;
+	} else if (new_offset > area_offset) {
+		diff = new_offset - area_offset;
+
+		if (diff % item_size) {
+			SSDFS_ERR("unaligned new area offset: "
+				  "diff %u, item_size %u\n",
+				  diff, item_size);
+			return -ERANGE;
+		}
+
+		if (diff > area_size) {
+			SSDFS_ERR("fail to shift the area: "
+				 "area_size %u, diff %u\n",
+				 area_size, diff);
+			return -ERANGE;
+		}
+
+		err = ssdfs_shift_memory_range_right2(node,
+						&node->lookup_tbl_area,
+						0, items_count * item_size,
+						diff);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to move area: err %d\n", err);
+			return err;
+		}
+
+		node->lookup_tbl_area.offset = new_offset;
+	}
+
+	if (new_size > area_size) {
+		/* resize case */
+
+		node->lookup_tbl_area.area_size = new_size;
+
+		items_capacity = new_size / item_size;
+		if (items_capacity >= U16_MAX) {
+			SSDFS_ERR("invalid items_capacity\n");
+			return -ERANGE;
+		}
+
+		node->lookup_tbl_area.index_capacity = (u16)items_capacity;
+	} else if (new_size < area_size) {
+		/* shrink case */
+
+		if ((items_count * item_size) > new_size) {
+			SSDFS_ERR("unable to shrink: "
+				  "items_count %u, item_size %u, new_size %u\n",
+				  items_count, item_size, new_size);
+			return -ENOSPC;
+		}
+
+		node->lookup_tbl_area.area_size = new_size;
+
+		items_capacity = new_size / item_size;
+
+		if (items_capacity >= U16_MAX) {
+			SSDFS_ERR("invalid items_capacity\n");
+			return -ERANGE;
+		}
+
+		if (items_count > items_capacity) {
+			SSDFS_ERR("items_count %u > items_capacity %u\n",
+				  items_count, items_capacity);
+			return -ERANGE;
+		}
+
+		node->lookup_tbl_area.index_capacity = (u16)items_capacity;
+	}
+
+	area_offset = node->lookup_tbl_area.offset;
+	area_size = node->lookup_tbl_area.area_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("AFTER: area_offset %u, area_size %u, "
+		  "items_count %u, items_capacity %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  area_offset, area_size,
+		  node->lookup_tbl_area.index_count,
+		  node->lookup_tbl_area.index_capacity,
+		  node->lookup_tbl_area.start_hash,
+		  node->lookup_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if ((area_offset + area_size) > node->node_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_show_node_block_content(node, area_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+static
+bool is_ssdfs_resized_node_corrupted(struct ssdfs_btree_node *node)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	struct ssdfs_shdict_ltbl2_item ltbl2_desc;
+	struct ssdfs_shdict_htbl_item hash_desc;
+#endif /* CONFIG_SSDFS_DEBUG */
+	u32 area_offset;
+	u32 area_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+
+	if ((area_offset + area_size) != node->hash_tbl_area.offset) {
+		SSDFS_ERR("corrupted string area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return true;
+	}
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if ((area_offset + area_size) != node->lookup_tbl_area.offset) {
+		SSDFS_ERR("corrupted hash table area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return true;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	if (node->hash_tbl_area.index_count > 0) {
+		ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					  0, &hash_desc);
+
+		if (node->hash_tbl_area.start_hash !=
+						le64_to_cpu(hash_desc.hash)) {
+			SSDFS_ERR("corrupted hash table area: node_id %u, "
+				  "HASH TBL (start_hash %#llx, end_hash %#llx), "
+				  "hash[0]: %#llx\n",
+				  node->node_id,
+				  node->hash_tbl_area.start_hash,
+				  node->hash_tbl_area.end_hash,
+				  le64_to_cpu(hash_desc.hash));
+			BUG();
+		}
+
+		ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					  node->hash_tbl_area.index_count - 1,
+					  &hash_desc);
+
+		if (node->hash_tbl_area.end_hash !=
+						le64_to_cpu(hash_desc.hash)) {
+			SSDFS_ERR("corrupted hash table area: node_id %u, "
+				  "HASH TBL (start_hash %#llx, end_hash %#llx), "
+				  "hash[%u]: %#llx\n",
+				  node->node_id,
+				  node->hash_tbl_area.start_hash,
+				  node->hash_tbl_area.end_hash,
+				  node->hash_tbl_area.index_count - 1,
+				  le64_to_cpu(hash_desc.hash));
+			BUG();
+		}
+	}
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	area_offset = node->lookup_tbl_area.offset;
+	area_size = node->lookup_tbl_area.area_size;
+
+	if ((area_offset + area_size) > node->node_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u, area_size %u, node_size %u\n",
+			  area_offset, area_size, node->node_size);
+		return true;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	if (node->lookup_tbl_area.index_count > 0) {
+		ssdfs_get_lookup2_descriptor(node, &node->lookup_tbl_area,
+					     0, &ltbl2_desc);
+
+		if (node->lookup_tbl_area.start_hash !=
+						le64_to_cpu(ltbl2_desc.hash)) {
+			SSDFS_ERR("corrupted lookup2 table area: node_id %u, "
+				  "LOOKUP TBL (start_hash %#llx, end_hash %#llx), "
+				  "hash[0]: %#llx\n",
+				  node->node_id,
+				  node->lookup_tbl_area.start_hash,
+				  node->lookup_tbl_area.end_hash,
+				  le64_to_cpu(ltbl2_desc.hash));
+			BUG();
+		}
+
+		ssdfs_get_lookup2_descriptor(node, &node->lookup_tbl_area,
+					node->lookup_tbl_area.index_count - 1,
+					&ltbl2_desc);
+
+		if (node->lookup_tbl_area.end_hash !=
+						le64_to_cpu(ltbl2_desc.hash)) {
+			SSDFS_ERR("corrupted lookup2 table area: node_id %u, "
+				  "LOOKUP TBL (start_hash %#llx, end_hash %#llx), "
+				  "hash[%u]: %#llx\n",
+				  node->node_id,
+				  node->lookup_tbl_area.start_hash,
+				  node->lookup_tbl_area.end_hash,
+				  node->lookup_tbl_area.index_count - 1,
+				  le64_to_cpu(ltbl2_desc.hash));
+			BUG();
+		}
+	}
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return false;
+}
+
+/*
+ * ssdfs_copy_string_from_buffer() - copy string from the buffer into the node
+ * @node: pointer on node object
+ * @name: pointer on string's buffer
+ * @name_len: length of the string in the buffer
+ * @str_offset: string's offset in the area
+ *
+ * This method tries to copy the string from the buffer into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_copy_string_from_buffer(struct ssdfs_btree_node *node,
+				  const char *name,
+				  size_t name_len,
+				  u16 str_offset)
+{
+	struct ssdfs_fs_info *fsi;
+	struct ssdfs_smart_folio folio;
+	struct folio_batch *batch;
+	u32 area_offset;
+	u32 area_size;
+	u32 item_offset;
+	u32 dst_offset;
+	u32 upper_bound;
+	u32 copied_len = 0;
+	u32 cur_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !name);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, name_len %zu, str_offset %u\n",
+		  node->node_id, name_len, str_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	fsi = node->tree->fsi;
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+
+	if (name_len == 0 || (str_offset + name_len) > area_size) {
+		SSDFS_ERR("invalid string length: "
+			  "str_offset %u, name_len %zu, "
+			  "area_size %u\n",
+			  str_offset, name_len, area_size);
+		return -ERANGE;
+	}
+
+	while (copied_len < name_len) {
+		item_offset = str_offset;
+		if ((item_offset + name_len) >= area_size) {
+			SSDFS_ERR("item_offset %u, str_len %zu, area_size %u\n",
+				  item_offset, name_len, area_size);
+			return -ERANGE;
+		}
+
+		item_offset += area_offset;
+		if (item_offset >= node->node_size) {
+			SSDFS_ERR("item_offset %u >= node_size %u\n",
+				  item_offset, node->node_size);
+			return -ERANGE;
+		}
+
+		item_offset += copied_len;
+
+		err = SSDFS_OFF2FOLIO(fsi->pagesize, item_offset, &folio.desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to convert offset into folio: "
+				  "item_offset %u, err %d\n",
+				  item_offset, err);
+			return err;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!IS_SSDFS_OFF2FOLIO_VALID(&folio.desc));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (folio.desc.folio_index >= node->content.count) {
+			SSDFS_ERR("invalid folio_index: "
+				  "index %d, blks_count %u\n",
+				  folio.desc.folio_index,
+				  node->content.count);
+			return -ERANGE;
+		}
+
+		batch = &node->content.blocks[folio.desc.folio_index].batch;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(folio_batch_count(batch) == 0);
+		BUG_ON(folio.desc.folio_offset > folio.desc.offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		dst_offset = folio.desc.offset - folio.desc.folio_offset;
+		upper_bound = folio.desc.folio_offset;
+		upper_bound += folio.desc.page_offset;
+		upper_bound += PAGE_SIZE;
+		cur_len = min_t(u32, (u32)name_len - copied_len,
+				     upper_bound - item_offset);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(cur_len == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_memcpy_to_batch(batch, dst_offset,
+					    (char *)name, copied_len, name_len,
+					    cur_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to copy: err %d\n", err);
+			return err;
+		}
+
+		copied_len += cur_len;
+	};
+
+	return 0;
+}
+
+static
+int __ssdfs_insert_strings_blob(struct ssdfs_btree_node *node,
+				const char *string_blob,
+				size_t blob_len,
+				struct ssdfs_btree_search *search)
+{
+	struct ssdfs_string_descriptor *left_name, *right_name;
+	struct ssdfs_btree_search_buffer *buf;
+	u32 area_size;
+	u32 free_space;
+	u32 used_space;
+	u64 left_hash;
+	u64 right_hash;
+	u64 search_hash;
+	u16 str_offset;
+	u32 range_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search || !string_blob);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, blob_len %zu\n",
+		  node->node_id, blob_len);
+
+	SSDFS_DBG("STRINGS BLOB DUMP\n");
+	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+			     string_blob, blob_len);
+	SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+	if (free_space > area_size) {
+		SSDFS_ERR("corrupted area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		return -ERANGE;
+	}
+
+	used_space = area_size - free_space;
+
+	if (blob_len > free_space) {
+		SSDFS_ERR("blob_len %zu > free_space %u\n",
+			  blob_len, free_space);
+		return -ENOSPC;
+	}
+
+	buf = &search->result.name_buf;
+	search_hash = search->request.start.hash;
+	left_name = &buf->place.name->left_name;
+	left_hash = le64_to_cpu(left_name->desc.hash);
+	right_name = &buf->place.name->right_name;
+	right_hash = le64_to_cpu(right_name->desc.hash);
+
+	if (search_hash >= U64_MAX ||
+	    left_hash >= U64_MAX || right_hash >= U64_MAX) {
+		SSDFS_ERR("invalid hash: "
+			  "search_hash %#llx, left_hash %#llx, "
+			  "right_hash %#llx\n",
+			  search_hash, left_hash, right_hash);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("search (start.hash %llx, hash %#llx), "
+		  "left_hash %#llx, right_hash %#llx, "
+		  "area_size %u, free_space %u\n",
+		  search->request.start.hash,
+		  search_hash, left_hash, right_hash,
+		  area_size, free_space);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search_hash < left_hash) {
+		str_offset = le16_to_cpu(left_name->desc.str_offset);
+
+		if (str_offset > used_space) {
+			SSDFS_ERR("invalid offset: "
+				  "str_offset %u, used_space %u\n",
+				  str_offset, used_space);
+			return -ERANGE;
+		} else
+			range_len = used_space - str_offset;
+
+		err = ssdfs_shift_memory_range_right(node,
+						     &node->items_area,
+						     str_offset,
+						     range_len,
+						     blob_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift the range: "
+				  "start %u, range %u, "
+				  "shift %zu, err %d\n",
+				  str_offset, range_len, blob_len, err);
+			return err;
+		}
+	} else if (search_hash <= right_hash) {
+		str_offset = le16_to_cpu(right_name->desc.str_offset);
+
+		if (str_offset > used_space) {
+			SSDFS_ERR("invalid offset: "
+				  "str_offset %u, used_space %u\n",
+				  str_offset, used_space);
+			return -ERANGE;
+		} else
+			range_len = used_space - str_offset;
+
+		err = ssdfs_shift_memory_range_right(node,
+						     &node->items_area,
+						     str_offset,
+						     range_len,
+						     blob_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift the range: "
+				  "start %u, range %u, "
+				  "shift %zu, err %d\n",
+				  str_offset, range_len, blob_len, err);
+			return err;
+		}
+	} else {
+		str_offset = le16_to_cpu(right_name->desc.str_offset);
+		str_offset += right_name->desc.str_len;
+
+		if (str_offset < used_space) {
+			range_len = used_space - str_offset;
+
+			err = ssdfs_shift_memory_range_right(node,
+							     &node->items_area,
+							     str_offset,
+							     range_len,
+							     blob_len);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to shift the range: "
+					  "start %u, range %u, "
+					  "shift %zu, err %d\n",
+					  str_offset, range_len,
+					  blob_len, err);
+				return err;
+			}
+		}
+	}
+
+	err = ssdfs_copy_string_from_buffer(node,
+					    (char *)string_blob, blob_len,
+					    str_offset);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy string: "
+			  "node_id %u, str_offset %u, "
+			  "blob_len %zu, err %d\n",
+			  node->node_id, str_offset,
+			  blob_len, err);
+		return err;
+	}
+
+	if (search->request.start.hash < node->items_area.start_hash)
+		node->items_area.start_hash = search->request.start.hash;
+
+	if (node->items_area.end_hash < search->request.start.hash)
+		node->items_area.end_hash = search->request.start.hash;
+
+	return 0;
+}
+
+static inline
+int __ssdfs_insert_full_string(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_search *search)
+{
+	const char *name;
+	size_t name_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!search->result.name_buf.place.name) {
+		SSDFS_ERR("empty buffer pointer\n");
+		return -ERANGE;
+	}
+
+	name = search->request.start.name;
+	if (!name) {
+		SSDFS_ERR("invalid name pointer\n");
+		return -ERANGE;
+	}
+
+	name_len = search->request.start.name_len;
+
+	err = __ssdfs_insert_strings_blob(node, name, name_len, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert strings blob: "
+			  "name %s, name_len %zu, err %d\n",
+			  name, name_len, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static
+int ssdfs_add_string_in_empty_node(struct ssdfs_btree_node *node,
+				   struct ssdfs_btree_search *search)
+{
+	const char *name;
+	u32 area_size;
+	u32 free_space;
+	u16 items_count;
+	u16 str_offset;
+	size_t name_len;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	items_count = node->items_area.items_count;
+
+	if (items_count != 0) {
+		SSDFS_ERR("node is not empty\n");
+		return -EINVAL;
+	}
+
+	if (free_space != area_size) {
+		SSDFS_ERR("corrupted area: "
+			  "free_space %u != area_size %u\n",
+			  free_space, area_size);
+		return -ERANGE;
+	}
+
+	name_len = search->request.start.name_len;
+
+	if (name_len > free_space) {
+		SSDFS_ERR("name_len %zu > free_space %u\n",
+			  name_len, free_space);
+		return -ENOSPC;
+	}
+
+	name = search->request.start.name;
+
+	if (!name) {
+		SSDFS_ERR("invalid name pointer\n");
+		return -ERANGE;
+	}
+
+	str_offset = 0;
+
+	err = ssdfs_copy_string_from_buffer(node,
+					    (char *)name, name_len,
+					    str_offset);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy string: "
+			  "node_id %u, str_offset %u, "
+			  "name_len %zu, err %d\n",
+			  node->node_id, str_offset,
+			  name_len, err);
+		return err;
+	}
+
+	node->items_area.start_hash = search->request.start.hash;
+	node->items_area.end_hash = search->request.start.hash;
+
+	return 0;
+}
+
+static
+int ssdfs_add_string_after_last_name(struct ssdfs_btree_node *node,
+				     struct ssdfs_btree_search *search)
+{
+	struct ssdfs_string_descriptor *left_name;
+	const char *name;
+	size_t name_len;
+	u32 free_space;
+	u64 hash1, hash2;
+	u16 str_offset;
+	u16 items_count;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!search->result.name_buf.place.name) {
+		SSDFS_ERR("empty buffer pointer\n");
+		return -ERANGE;
+	}
+
+	left_name = &search->result.name_buf.place.name->left_name;
+	hash1 = search->request.start.hash;
+	hash2 = le64_to_cpu(left_name->desc.hash);
+	items_count = node->items_area.items_count;
+	free_space = node->items_area.free_space;
+
+	if ((left_name->index + 1) != items_count) {
+		SSDFS_ERR("invalid request: index %u, items_count %u\n",
+			  left_name->index, items_count);
+		return -ERANGE;
+	}
+
+	if (hash1 <= hash2) {
+		SSDFS_ERR("invalid position: "
+			  "name->hash %#llx, "
+			  "desc.hash %#llx\n",
+			  hash1, hash2);
+		return -ERANGE;
+	}
+
+	name_len = search->request.start.name_len;
+
+	if (name_len > free_space) {
+		SSDFS_ERR("name_len %zu > free_space %u\n",
+			  name_len, free_space);
+		return -ENOSPC;
+	}
+
+	name = search->request.start.name;
+
+	if (!name) {
+		SSDFS_ERR("invalid name pointer\n");
+		return -ERANGE;
+	}
+
+	str_offset = le16_to_cpu(left_name->desc.str_offset);
+	str_offset += left_name->desc.str_len;
+
+	err = ssdfs_copy_string_from_buffer(node, (char *)name,
+					    name_len, str_offset);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy string: "
+			  "node_id %u, str_offset %u, "
+			  "name_len %zu, err %d\n",
+			  node->node_id, str_offset,
+			  name_len, err);
+		return err;
+	}
+
+	if (search->request.start.hash < node->items_area.start_hash)
+		node->items_area.start_hash = search->request.start.hash;
+
+	if (node->items_area.end_hash < search->request.start.hash)
+		node->items_area.end_hash = search->request.start.hash;
+
+	return 0;
+}
+
+static
+int ssdfs_add_string_before_first_name(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search)
+{
+	struct ssdfs_string_descriptor *left_name;
+	const char *name;
+	size_t name_len;
+	u32 area_size;
+	u32 free_space;
+	u64 hash1, hash2;
+	u16 str_offset;
+	u32 range_len;
+	u16 items_count;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!search->result.name_buf.place.name) {
+		SSDFS_ERR("empty buffer pointer\n");
+		return -ERANGE;
+	}
+
+	left_name = &search->result.name_buf.place.name->left_name;
+	hash1 = search->request.start.hash;
+	hash2 = le64_to_cpu(left_name->desc.hash);
+	area_size = node->items_area.area_size;
+	items_count = node->items_area.items_count;
+	free_space = node->items_area.free_space;
+
+	if (left_name->index != 0) {
+		SSDFS_ERR("invalid request: index %u\n",
+			  left_name->index);
+		return -ERANGE;
+	}
+
+	if (hash1 >= hash2) {
+		SSDFS_ERR("invalid position: "
+			  "name->hash %#llx, "
+			  "desc.hash %#llx\n",
+			  hash1,
+			  hash2);
+		return -ERANGE;
+	}
+
+	name_len = search->request.start.name_len;
+
+	if (name_len > free_space) {
+		SSDFS_ERR("name_len %zu > free_space %u\n",
+			  name_len, free_space);
+		return -ENOSPC;
+	}
+
+	name = search->request.start.name;
+
+	if (!name) {
+		SSDFS_ERR("invalid name pointer\n");
+		return -ERANGE;
+	}
+
+	str_offset = 0;
+	range_len = area_size - free_space;
+
+	err = ssdfs_shift_memory_range_right(node, &node->items_area,
+					     str_offset, range_len,
+					     name_len);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shift the range: "
+			  "start %u, range %u, "
+			  "shift %zu, err %d\n",
+			  str_offset, range_len,
+			  name_len, err);
+		return err;
+	}
+
+	err = ssdfs_copy_string_from_buffer(node, (char *)name,
+					    name_len, str_offset);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy string: "
+			  "node_id %u, str_offset %u, "
+			  "name_len %zu, err %d\n",
+			  node->node_id, str_offset,
+			  name_len, err);
+		return err;
+	}
+
+	if (search->request.start.hash < node->items_area.start_hash)
+		node->items_area.start_hash = search->request.start.hash;
+
+	if (node->items_area.end_hash < search->request.start.hash)
+		node->items_area.end_hash = search->request.start.hash;
+
+	return 0;
+}
+
+/*
+ * ssdfs_insert_full_string() - insert the full string into the node
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to insert the full name into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - not enough free space for the string.
+ */
+static
+int ssdfs_insert_full_string(struct ssdfs_btree_node *node,
+			     struct ssdfs_btree_search *search)
+{
+	struct ssdfs_string_descriptor *left_name;
+	u32 area_size;
+	u32 free_space;
+	u16 items_count;
+	u32 items_capacity;
+	size_t name_len;
+	u8 min_item_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	items_count = node->items_area.items_count;
+	min_item_size = node->items_area.min_item_size;
+
+	if (min_item_size != SSDFS_DENTRY_INLINE_NAME_MAX_LEN) {
+		SSDFS_ERR("invalid min_item_size %u\n",
+			  min_item_size);
+		return -ERANGE;
+	}
+
+	if (free_space > area_size) {
+		SSDFS_ERR("free_space %u > area_size %u\n",
+			  free_space, area_size);
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain the name\n");
+		return -ERANGE;
+	}
+
+	if (search->request.count != 1) {
+		SSDFS_ERR("invalid request: "
+			  "search->request.count %u\n",
+			  search->request.count);
+		return -ERANGE;
+	}
+
+	name_len = search->request.start.name_len;
+
+	if (name_len > free_space) {
+		SSDFS_ERR("name_len %zu > free_space %u\n",
+			  name_len, free_space);
+		return -ENOSPC;
+	}
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+		err = __ssdfs_insert_full_string(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert string: "
+				  "node_id %u, "
+				  "name_len %zu, err %d\n",
+				  node->node_id,
+				  name_len, err);
+			return err;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		if (items_count == 0) {
+			err = ssdfs_add_string_in_empty_node(node, search);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to add string: "
+					  "node_id %u, err %d\n",
+					  node->node_id, err);
+				return err;
+			}
+		} else {
+			struct ssdfs_btree_search_buffer *buf;
+
+			buf = &search->result.name_buf;
+			left_name = &buf->place.name->left_name;
+
+			if ((left_name->index + 1) == items_count) {
+				err = ssdfs_add_string_after_last_name(node,
+									search);
+				if (unlikely(err)) {
+					SSDFS_ERR("fail to add string: "
+						  "err %d\n", err);
+					return err;
+				}
+			} else if (left_name->index == 0) {
+				err = ssdfs_add_string_before_first_name(node,
+									search);
+				if (unlikely(err)) {
+					SSDFS_ERR("fail to add string: "
+						  "err %d\n", err);
+					return err;
+				}
+			} else {
+				SSDFS_ERR("invalid index: "
+					  "left_name->index %u\n",
+					  left_name->index);
+				return -ERANGE;
+			}
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected result state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	node->items_area.items_count += 1;
+	node->items_area.free_space -= name_len;
+
+	node->items_area.item_size = ssdfs_define_item_size(node);
+
+	items_capacity = ssdfs_define_items_capacity(node);
+	if (items_capacity >= U16_MAX) {
+		SSDFS_ERR("invalid items_capacity %u\n",
+			  items_capacity);
+		return -ERANGE;
+	}
+
+	node->items_area.items_capacity = (u16)items_capacity;
+
+	return 0;
+}
+
+static inline
+int ssdfs_correct_lookup2_table(struct ssdfs_btree_node *node,
+				u16 index, u32 range_len)
+{
+	u16 items_count;
+	u16 items_capacity;
+	u16 i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, index %u, range_len %u\n",
+		  node->node_id, index, range_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+
+	if ((items_count + range_len) > items_capacity) {
+		SSDFS_ERR("fail to add hash range: "
+			  "items_count %u, range_len %u, "
+			  "items_capacity %u\n",
+			  items_count, range_len,
+			  items_capacity);
+		return -ERANGE;
+	}
+
+	for (i = 0; i < items_count; i++) {
+		struct ssdfs_shdict_ltbl2_item cur_desc;
+		u16 cur_index;
+
+		err = ssdfs_get_lookup2_descriptor(node,
+						   &node->lookup_tbl_area,
+						   i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		cur_index = le16_to_cpu(cur_desc.hash_index);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u, cur_index %u\n",
+			  index, cur_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (cur_index >= index) {
+			le16_add_cpu(&cur_desc.hash_index, range_len);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("correct lookup2_table: "
+				  "lookup2_index %d, "
+				  "hash_index (old %u, new %u), "
+				  "hash %#llx\n",
+				  i, cur_index,
+				  le16_to_cpu(cur_desc.hash_index),
+				  le64_to_cpu(cur_desc.hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			err = ssdfs_set_lookup2_descriptor(node,
+						   &node->lookup_tbl_area,
+						   i, &cur_desc);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to set lookup2 descriptor: "
+					  "index %u, err %d\n",
+					  i, err);
+				return err;
+			}
+		}
+	}
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	return 0;
+}
+
+/*
+ * __ssdfs_hash_table_insert_descriptor() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @index: index of the item in the hash table
+ * @desc: pointer on the hash descriptor [in]
+ *
+ * This method tries to insert the hash descriptor into
+ * the hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - the hash table hasn't vacant items.
+ */
+static
+int __ssdfs_hash_table_insert_descriptor(struct ssdfs_btree_node *node,
+					 struct ssdfs_btree_search *search,
+					 u16 index,
+					 struct ssdfs_shdict_htbl_item *desc)
+{
+	struct ssdfs_shdict_htbl_item cur_desc;
+	u16 items_count;
+	u16 items_capacity;
+	u8 item_size;
+	u16 range_len;
+	u16 shift;
+	u32 desc_str_offset;
+	u8 str_len;
+	u32 str_offset;
+	u16 i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !desc || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, index %u\n",
+		  node->node_id, index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	err = ssdfs_correct_lookup2_table(node, index, 1);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to correct lookup2 table: "
+			  "index %u, range_len %u, err %d\n",
+			  index, range_len, err);
+		return err;
+	}
+
+	items_count = node->hash_tbl_area.index_count;
+	items_capacity = node->hash_tbl_area.index_capacity;
+	item_size = node->hash_tbl_area.index_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u, item_size %u\n",
+		  items_count, items_capacity, item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (item_size != sizeof(struct ssdfs_shdict_htbl_item)) {
+		SSDFS_ERR("corrupted area: "
+			  "item_size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	if (items_count > items_capacity) {
+		SSDFS_ERR("items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	} else if (items_count == items_capacity) {
+		SSDFS_ERR("items_count %u == items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ENOSPC;
+	}
+
+	if (index > items_count) {
+		SSDFS_ERR("index %u > items_count %u\n",
+			  index, items_count);
+		return -ERANGE;
+	}
+
+	if (index < items_count) {
+		range_len = items_count - index;
+		shift = 1;
+
+		err = ssdfs_shift_range_right2(node, &node->hash_tbl_area,
+						item_size,
+						index, range_len,
+						shift);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift the range: "
+				  "index %u, range_len %u, "
+				  "shift %u, err %d\n",
+				  index, range_len, shift, err);
+			return err;
+		}
+	}
+
+	err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+					index, desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set hash descriptor: "
+			  "index %u, err %d\n",
+			  index, err);
+		return err;
+	}
+
+	if (index == 0)
+		node->hash_tbl_area.start_hash = search->request.start.hash;
+
+	if (index == items_count)
+		node->hash_tbl_area.end_hash = search->request.start.hash;
+
+	node->hash_tbl_area.index_count++;
+	items_count = node->hash_tbl_area.index_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u, item_size %u\n",
+		  items_count, items_capacity, item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	desc_str_offset = le16_to_cpu(desc->str_offset);
+	str_len = desc->str_len;
+
+	i = index + 1;
+
+	if (i >= items_count)
+		goto mark_hash_table_dirty;
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					i, &cur_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  i, err);
+		return err;
+	}
+
+	str_offset = le16_to_cpu(cur_desc.str_offset);
+
+	if (str_offset == (desc_str_offset + str_len)) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("no necessity correct string offset: "
+			  "str_offset %u, desc_str_offset %u, "
+			  "str_len %u\n",
+			  str_offset, desc_str_offset, str_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto mark_hash_table_dirty;
+	}
+
+	for (; i < items_count; i++) {
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		str_offset = le16_to_cpu(cur_desc.str_offset);
+		str_offset += str_len;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u, old str_offset %u, "
+			  "new str_offset %u, str_len %u\n",
+			  i, le16_to_cpu(cur_desc.str_offset),
+			  str_offset, str_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (str_offset >= U16_MAX) {
+			SSDFS_ERR("invalid str_offset %u\n",
+				  str_offset);
+			return -ERANGE;
+		}
+
+		cur_desc.str_offset = cpu_to_le16((u16)str_offset);
+
+		err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+	}
+
+mark_hash_table_dirty:
+	ssdfs_mark_hash_table_dirty(node);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search->result.name_buf.place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	search->result.name_buf.place.name->placement.hash_index = index;
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_before_left_name() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor before left name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_before_left_name(struct ssdfs_btree_node *node,
+					     struct ssdfs_btree_search *search,
+					     u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *left_name;
+	struct ssdfs_shdict_htbl_item desc;
+	u32 str_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	left_name = &search->result.name_buf.place.name->left_name;
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	str_offset = le16_to_cpu(left_name->desc.str_offset);
+	if ((str_offset + str_len) > node->items_area.area_size) {
+		SSDFS_ERR("invalid offset: "
+			  "str_offset %u, "
+			  "area_size %u\n",
+			  str_offset,
+			  node->items_area.area_size);
+		return -ERANGE;
+	}
+
+	desc.str_offset = cpu_to_le16((u16)str_offset);
+
+	desc.str_len = str_len;
+	desc.type = str_type;
+
+	err = __ssdfs_hash_table_insert_descriptor(node, search,
+						   left_name->index,
+						   &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash: "
+			  "node_id %u, index %u, "
+			  "err %d\n",
+			  node->node_id, left_name->index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_before_right_name() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor before right name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_before_right_name(struct ssdfs_btree_node *node,
+					      struct ssdfs_btree_search *search,
+					      u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *left_name, *right_name;
+	struct ssdfs_shdict_htbl_item desc;
+	u32 str_offset;
+	u16 index;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	left_name = &search->result.name_buf.place.name->left_name;
+	right_name = &search->result.name_buf.place.name->right_name;
+
+	switch (left_name->desc.type) {
+	case SSDFS_NAME_PREFIX:
+		switch (right_name->desc.type) {
+		case SSDFS_NAME_PREFIX:
+		case SSDFS_NAME_SUFFIX:
+		case SSDFS_FULL_NAME:
+			if (str_type != SSDFS_NAME_SUFFIX) {
+				SSDFS_ERR("invalid type: str_type %#x\n",
+					  str_type);
+				return -ERANGE;
+			}
+			break;
+
+		default:
+			SSDFS_ERR("invalid type: right_name %#x\n",
+				  right_name->desc.type);
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_NAME_SUFFIX:
+		switch (right_name->desc.type) {
+		case SSDFS_NAME_PREFIX:
+		case SSDFS_NAME_SUFFIX:
+		case SSDFS_FULL_NAME:
+			/* any str_type is valid */
+			break;
+
+		default:
+			SSDFS_ERR("invalid type: right_name %#x\n",
+				  right_name->desc.type);
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_FULL_NAME:
+		switch (right_name->desc.type) {
+		case SSDFS_NAME_PREFIX:
+		case SSDFS_FULL_NAME:
+			if (str_type == SSDFS_NAME_SUFFIX) {
+				SSDFS_ERR("invalid type: str_type %#x\n",
+					  str_type);
+				return -ERANGE;
+			}
+			break;
+
+		default:
+			SSDFS_ERR("invalid type: right_name %#x\n",
+				  right_name->desc.type);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid type: left_name %#x\n",
+			  left_name->desc.type);
+		return -ERANGE;
+	}
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	str_offset = le16_to_cpu(right_name->desc.str_offset);
+	if ((str_offset + str_len) > node->items_area.area_size) {
+		SSDFS_ERR("invalid offset: str_offset %u, area_size %u\n",
+			  str_offset, node->items_area.area_size);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("right_name: (str_offset %u, str_len %u), "
+		  "str_offset %u\n",
+		  le16_to_cpu(right_name->desc.str_offset),
+		  right_name->desc.str_len,
+		  str_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	desc.str_offset = cpu_to_le16((u16)str_offset);
+
+	desc.str_len = str_len;
+	desc.type = str_type;
+
+	index = right_name->index;
+	err = __ssdfs_hash_table_insert_descriptor(node, search,
+						   right_name->index,
+						   &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash: "
+			  "node_id %u, index %u, err %d\n",
+			  node->node_id, index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_after_right_name() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor after right name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_after_right_name(struct ssdfs_btree_node *node,
+					     struct ssdfs_btree_search *search,
+					     u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *right_name;
+	struct ssdfs_shdict_htbl_item desc;
+	u32 str_offset;
+	u16 index;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	right_name = &search->result.name_buf.place.name->right_name;
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	str_offset = le16_to_cpu(right_name->desc.str_offset);
+	str_offset += right_name->desc.str_len;
+	if ((str_offset + str_len) > node->items_area.area_size) {
+		SSDFS_ERR("invalid offset: str_offset %u, area_size %u\n",
+			  str_offset, node->items_area.area_size);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(str_offset >= U16_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	desc.str_offset = cpu_to_le16((u16)str_offset);
+
+	desc.str_len = str_len;
+	desc.type = str_type;
+
+	index = right_name->index + 1;
+	err = __ssdfs_hash_table_insert_descriptor(node, search, index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash: "
+			  "node_id %u, index %u, "
+			  "err %d\n",
+			  node->node_id, index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_into_found_position() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor into found position.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ */
+static
+int ssdfs_hash_table_insert_into_found_position(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search,
+					    u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *left_name, *right_name;
+	u64 left_name_hash, right_name_hash, request_hash;
+	u16 index1, index2;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	left_name = &search->result.name_buf.place.name->left_name;
+	right_name = &search->result.name_buf.place.name->right_name;
+	request_hash = search->request.start.hash;
+	left_name_hash = le64_to_cpu(left_name->desc.hash);
+	right_name_hash = le64_to_cpu(right_name->desc.hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("request_hash %#llx, "
+		  "left_name_hash %#llx, right_name_hash %#llx, "
+		  "left_name->index %u, right_name->index %u\n",
+		  request_hash,
+		  left_name_hash,
+		  right_name_hash,
+		  left_name->index,
+		  right_name->index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (left_name_hash > right_name_hash) {
+		SSDFS_ERR("invalid hash: left_name %#llx, right_name %#llx\n",
+			  left_name_hash, right_name_hash);
+		return -ERANGE;
+	}
+
+	if (left_name_hash == right_name_hash) {
+		index1 = left_name->index;
+		index2 = right_name->index;
+	} else {
+		index1 = left_name->index + 1;
+		index2 = right_name->index;
+	}
+
+	if (index1 != index2) {
+		SSDFS_ERR("invalid index: index1 %u, index2 %u\n",
+			  index1, index2);
+		return -ERANGE;
+	}
+
+	if (left_name_hash == request_hash) {
+		err = ssdfs_hash_table_insert_before_right_name(node,
+					    search, str_len, str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+	} else if (request_hash < left_name_hash) {
+		err = ssdfs_hash_table_insert_before_left_name(node,
+					    search, str_len, str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+	} else if (left_name_hash < request_hash &&
+		   request_hash < right_name_hash) {
+		err = ssdfs_hash_table_insert_before_right_name(node,
+					    search, str_len, str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+	} else if (request_hash == right_name_hash) {
+		err = ssdfs_hash_table_insert_after_right_name(node,
+					    search, str_len, str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+	} else {
+		err = ssdfs_hash_table_insert_after_right_name(node,
+					    search, str_len, str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_into_empty_table() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor into empty table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_into_empty_table(struct ssdfs_btree_node *node,
+					     struct ssdfs_btree_search *search,
+					     u8 str_len, u8 str_type)
+{
+	struct ssdfs_shdict_htbl_item desc;
+	u16 items_count;
+	u16 index;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->hash_tbl_area.index_count;
+
+	if (items_count > 0) {
+		SSDFS_ERR("hash table is not empty\n");
+		return -ERANGE;
+	}
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+	desc.str_offset = cpu_to_le16(0);
+
+	if (str_len != search->request.start.name_len) {
+		SSDFS_ERR("invalid string length: "
+			  "str_len %u, name_len %zu\n",
+			  str_len, search->request.start.name_len);
+		return -ERANGE;
+	}
+
+	desc.str_len = str_len;
+
+	if (str_type != SSDFS_FULL_NAME) {
+		SSDFS_ERR("invalid str_type %#x\n",
+			  str_type);
+		return -ERANGE;
+	}
+
+	desc.type = str_type;
+
+	index = 0;
+	err = __ssdfs_hash_table_insert_descriptor(node, search, index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash descriptor: "
+			  "node_id %u, index %u, err %d\n",
+			  node->node_id, index, err);
+		return err;
+	}
+
+	node->hash_tbl_area.start_hash = search->request.start.hash;
+	node->hash_tbl_area.end_hash = search->request.start.hash;
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_before_prefix() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor before prefix.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_before_prefix(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search,
+					  u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name;
+	struct ssdfs_shdict_htbl_item desc;
+	u16 index, index1, index2;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	prefix = &search->result.name_buf.place.name->prefix;
+	left_name = &search->result.name_buf.place.name->left_name;
+
+	if (prefix->index != 0) {
+		SSDFS_ERR("invalid index: prefix->index %u\n",
+			  prefix->index);
+		return -ERANGE;
+	}
+
+	switch (prefix->desc.type) {
+	case SSDFS_NAME_PREFIX:
+		index1 = prefix->index + 1;
+		index2 = left_name->index;
+		if (index1 != index2) {
+			SSDFS_ERR("invalid index: "
+				  "type %#x, prefix %u, left_name %u\n",
+				  prefix->desc.type,
+				  prefix->index,
+				  left_name->index);
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_FULL_NAME:
+		index1 = prefix->index;
+		index2 = left_name->index;
+		if (index1 != index2) {
+			SSDFS_ERR("invalid index: "
+				  "type %#x, prefix %u, left_name %u\n",
+				  prefix->desc.type,
+				  prefix->index,
+				  left_name->index);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid prefix type %#x\n",
+			  prefix->desc.type);
+		return -ERANGE;
+	}
+
+	switch (str_type) {
+	case SSDFS_NAME_PREFIX:
+	case SSDFS_FULL_NAME:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type: str_type %#x\n",
+			  str_type);
+		return -ERANGE;
+	}
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+	desc.str_offset = cpu_to_le16(0);
+	desc.str_len = str_len;
+	desc.type = str_type;
+
+	index = prefix->index;
+	err = __ssdfs_hash_table_insert_descriptor(node, search, index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash: "
+			  "node_id %u, index %u, "
+			  "err %d\n",
+			  node->node_id, index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_after_prefix() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor after prefix.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_after_prefix(struct ssdfs_btree_node *node,
+					 struct ssdfs_btree_search *search,
+					 u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name;
+	struct ssdfs_shdict_htbl_item desc;
+	u16 index, index1, index2;
+	u32 str_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	prefix = &search->result.name_buf.place.name->prefix;
+	left_name = &search->result.name_buf.place.name->left_name;
+
+	if (prefix->index != 0) {
+		SSDFS_ERR("invalid index: "
+			  "prefix->index %u\n",
+			  prefix->index);
+		return -ERANGE;
+	}
+
+	switch (prefix->desc.type) {
+	case SSDFS_NAME_PREFIX:
+		index1 = prefix->index + 1;
+		index2 = left_name->index;
+		if (index1 != index2) {
+			SSDFS_ERR("invalid index: type %#x, "
+				  "prefix %u, left_name %u\n",
+				  prefix->desc.type,
+				  prefix->index,
+				  left_name->index);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid prefix type %#x\n",
+			  prefix->desc.type);
+		return -ERANGE;
+	}
+
+	switch (str_type) {
+	case SSDFS_NAME_SUFFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type: str_type %#x\n",
+			  str_type);
+		return -ERANGE;
+	}
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	str_offset = le16_to_cpu(prefix->desc.str_offset);
+	str_offset += prefix->desc.str_len;
+
+	if (str_offset >= node->items_area.area_size || str_offset >= U16_MAX) {
+		SSDFS_ERR("invalid offset: str_offset %u, area_size %u\n",
+			  str_offset, node->items_area.area_size);
+		return -ERANGE;
+	}
+
+	desc.str_offset = cpu_to_le16((u16)str_offset);
+
+	desc.str_len = str_len;
+	desc.type = str_type;
+
+	index = left_name->index;
+	err = __ssdfs_hash_table_insert_descriptor(node, search, index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash: "
+			  "node_id %u, index %u, "
+			  "err %d\n",
+			  node->node_id, index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_after_suffix() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor after suffix.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_insert_after_suffix(struct ssdfs_btree_node *node,
+					 struct ssdfs_btree_search *search,
+					 u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *left_name;
+	struct ssdfs_shdict_htbl_item desc;
+	u16 index;
+	u16 items_count;
+	u32 str_offset;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	left_name = &search->result.name_buf.place.name->left_name;
+	items_count = node->hash_tbl_area.index_count;
+
+	if ((left_name->index + 1) != items_count) {
+		SSDFS_ERR("invalid index: "
+			  "left_name->index %u, items_count %u\n",
+			  left_name->index,
+			  items_count);
+		return -ERANGE;
+	}
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	str_offset = le16_to_cpu(left_name->desc.str_offset);
+	str_offset += left_name->desc.str_len;
+
+	if (str_offset >= node->items_area.area_size || str_offset >= U16_MAX) {
+		SSDFS_ERR("invalid offset: "
+			  "str_offset %u, area_size %u\n",
+			  str_offset, node->items_area.area_size);
+		return -ERANGE;
+	}
+
+	desc.str_offset = cpu_to_le16((u16)str_offset);
+
+	if (str_len > search->request.start.name_len) {
+		SSDFS_ERR("invalid string length: "
+			  "str_len %u, name_len %zu\n",
+			str_len, search->request.start.name_len);
+		return -ERANGE;
+	}
+
+	desc.str_len = str_len;
+
+	switch (str_type) {
+	case SSDFS_NAME_PREFIX:
+	case SSDFS_NAME_SUFFIX:
+	case SSDFS_FULL_NAME:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid str_type %#x\n",
+			  str_type);
+		return -ERANGE;
+	}
+
+	desc.type = str_type;
+
+	index = left_name->index + 1;
+	err = __ssdfs_hash_table_insert_descriptor(node, search, index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert descriptor: "
+			  "node_id %u, index %u, err %d\n",
+			  node->node_id, index,
+			  err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_add_after_found_position() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor after found position.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static inline
+int ssdfs_hash_table_add_after_found_position(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search,
+					    u8 str_len, u8 str_type)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name;
+	u64 prefix_hash, left_name_hash, request_hash;
+	u16 items_count;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->hash_tbl_area.index_count;
+
+	if (items_count <= 1) {
+		err = ssdfs_hash_table_insert_into_empty_table(node, search,
+								str_len,
+								str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+	} else {
+		if (!search->result.name_buf.place.name) {
+			SSDFS_ERR("empty buffer pointer\n");
+			return -ERANGE;
+		}
+
+		prefix = &search->result.name_buf.place.name->prefix;
+		left_name = &search->result.name_buf.place.name->left_name;
+		request_hash = search->request.start.hash;
+		prefix_hash = le64_to_cpu(prefix->desc.hash);
+		left_name_hash = le64_to_cpu(left_name->desc.hash);
+
+		if (prefix_hash > left_name_hash) {
+			SSDFS_ERR("prefix %#llx > left_name %#llx\n",
+				  prefix_hash, left_name_hash);
+			return -ERANGE;
+		}
+
+		if (request_hash < prefix_hash) {
+			err = ssdfs_hash_table_insert_before_prefix(node,
+								    search,
+								    str_len,
+								    str_type);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to insert descriptor: "
+					  "err %d\n", err);
+				return err;
+			}
+		} else if (request_hash == prefix_hash) {
+			SSDFS_ERR("invalid hash: "
+				  "request %#llx == prefix %#llx\n",
+				  request_hash, prefix_hash);
+			return -EEXIST;
+		} else if (request_hash > prefix_hash &&
+			    request_hash < left_name_hash) {
+			err = ssdfs_hash_table_insert_after_prefix(node,
+								   search,
+								   str_len,
+								   str_type);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to insert descriptor: "
+					  "err %d\n", err);
+				return err;
+			}
+		} else if (request_hash > prefix_hash &&
+			   request_hash == left_name_hash) {
+			SSDFS_ERR("invalid hash: "
+				  "request %#llx == left_name %#llx\n",
+				  request_hash, left_name_hash);
+			return -EEXIST;
+		} else if (request_hash > left_name_hash) {
+			err = ssdfs_hash_table_insert_after_suffix(node,
+								   search,
+								   str_len,
+								   str_type);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to insert descriptor: "
+					  "err %d\n", err);
+				return err;
+			}
+		} else
+			BUG();
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_descriptor() - insert the hash descriptor
+ * @node: node object
+ * @search: search object
+ * @str_len: string length
+ * @str_type: string type
+ *
+ * This method tries to insert the hash descriptor for the string.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - hash table hasn't vacant items.
+ * %-EEXIST     - hash table contains the descriptor already.
+ */
+static
+int ssdfs_hash_table_insert_descriptor(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search,
+					u8 str_len, u8 str_type)
+{
+	u16 items_count;
+	u16 items_capacity;
+	u16 item_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_len %u, str_type %#x\n",
+		  node->node_id, str_len, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain the name\n");
+		return -ERANGE;
+	}
+
+	if (search->request.count != 1) {
+		SSDFS_ERR("invalid request: "
+			  "search->request.count %u\n",
+			  search->request.count);
+		return -ERANGE;
+	}
+
+	items_count = node->hash_tbl_area.index_count;
+	items_capacity = node->hash_tbl_area.index_capacity;
+	item_size = node->hash_tbl_area.index_size;
+
+	if (items_count == items_capacity) {
+		SSDFS_ERR("no vacant items: "
+			  "items_count %u, items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ENOSPC;
+	} else if (items_count > items_capacity) {
+		SSDFS_ERR("items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	}
+
+	if (item_size != sizeof(struct ssdfs_shdict_htbl_item)) {
+		SSDFS_ERR("invalid item size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	if (str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("str_len %u > max_name_len %u\n",
+			  str_len, SSDFS_MAX_NAME_LEN);
+		return -ERANGE;
+	}
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+		err = ssdfs_hash_table_insert_into_found_position(node, search,
+								  str_len,
+								  str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		err = ssdfs_hash_table_add_after_found_position(node, search,
+								str_len,
+								str_type);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected result state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup2_table_inc_str_count() - increment the strings count
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to increment the strings count for
+ * the existing descriptor in the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_lookup2_table_inc_str_count(struct ssdfs_btree_node *node,
+				      struct ssdfs_btree_search *search)
+{
+	struct ssdfs_shdict_ltbl2_item read_desc;
+	struct ssdfs_btree_search_buffer *buf;
+	u64 found_hash;
+	u64 req_hash;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("valid hash is absent in request\n");
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_debug_btree_search_result_name(search);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	req_hash = search->request.start.hash;
+	found_hash =
+		le64_to_cpu(search->name.string.strings_range.desc.hash);
+
+	if (found_hash < req_hash) {
+		SSDFS_ERR("invalid strings range: "
+			  "index %u, req_hash %#llx, found_hash %#llx\n",
+			  search->name.string.strings_range.index,
+			  req_hash, found_hash);
+		return -ERANGE;
+	}
+
+	err = ssdfs_get_lookup2_descriptor(node,
+					&node->lookup_tbl_area,
+					search->name.string.strings_range.index,
+					&read_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to extract lookup2 item: "
+			  "index %u, err %d\n",
+			  search->name.string.strings_range.index,
+			  err);
+		return err;
+	}
+
+	if (found_hash != le64_to_cpu(read_desc.hash)) {
+		SSDFS_ERR("found_hash %#llx != read_hash %#llx\n",
+			  found_hash,
+			  le64_to_cpu(read_desc.hash));
+		return -ERANGE;
+	}
+
+	if (read_desc.str_count >= U8_MAX) {
+		SSDFS_ERR("invalid str_count %u\n",
+			  read_desc.str_count);
+		return -ERANGE;
+	}
+
+	read_desc.str_count++;
+
+	err = ssdfs_set_lookup2_descriptor(node,
+				&node->lookup_tbl_area,
+				search->name.string.strings_range.index,
+				&read_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set lookup2 item: "
+			  "index %u, err %d\n",
+			  search->name.string.strings_range.index,
+			  err);
+		return err;
+	}
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	buf = &search->result.name_buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	buf->place.name->placement.lookup2_index =
+				search->name.string.strings_range.index;
+
+	return 0;
+}
+
+/*
+ * __ssdfs_lookup2_table_insert_descriptor() - insert a new lookup2 descriptor
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to insert a new descriptor in the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - lookup2 table hasn't vacant items.
+ */
+static
+int __ssdfs_lookup2_table_insert_descriptor(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	struct ssdfs_shdict_ltbl2_item desc;
+	struct ssdfs_btree_search_buffer *buf;
+	u16 items_count;
+	u16 items_capacity;
+	u16 item_size;
+	u16 hash_index;
+	u16 lookup2_index;
+	u16 range_len;
+	u16 shift;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+	item_size = node->lookup_tbl_area.index_size;
+
+	buf = &search->result.name_buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_index = buf->place.name->placement.hash_index;
+	lookup2_index = search->name.string.strings_range.index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u, "
+		  "index_size %u, hash_index %u, "
+		  "lookup2_index %u\n",
+		  items_count, items_capacity,
+		  item_size, hash_index,
+		  lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (items_count >= items_capacity) {
+		SSDFS_ERR("corrupted node: "
+			  "node_id %u, items_count %u, "
+			  "items_capacity %u\n",
+			  node->node_id, items_count,
+			  items_capacity);
+		return -ERANGE;
+	}
+
+	node->lookup_tbl_area.index_count++;
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	if (lookup2_index < items_count) {
+		range_len = items_count - lookup2_index;
+		shift = 1;
+
+		err = ssdfs_shift_range_right2(node,
+						&node->lookup_tbl_area,
+						item_size,
+						lookup2_index, range_len,
+						shift);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift the range: "
+				  "index %u, range_len %u, "
+				  "shift %u, err %d\n",
+				  lookup2_index, range_len, shift, err);
+			return err;
+		}
+	} else {
+		SSDFS_ERR("invalid index: "
+			  "index %u, items_count %u\n",
+			  lookup2_index, items_count);
+		return -ERANGE;
+	}
+
+	if (search->request.start.name_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid name len %zu\n",
+			  search->request.start.name_len);
+		return -ERANGE;
+	}
+
+	desc.prefix_len = (u8)search->request.start.name_len;
+	desc.hash_index = cpu_to_le16(hash_index);
+	desc.str_count = 1;
+
+	err = ssdfs_set_lookup2_descriptor(node, &node->lookup_tbl_area,
+					   lookup2_index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set lookup2 descriptor: "
+			  "index %u, err %d\n",
+			  lookup2_index, err);
+		return err;
+	}
+
+	items_count = node->lookup_tbl_area.index_count;
+
+	if (lookup2_index == 0)
+		node->lookup_tbl_area.start_hash = le64_to_cpu(desc.hash);
+
+	if ((lookup2_index + 1) == items_count)
+		node->lookup_tbl_area.end_hash = le64_to_cpu(desc.hash);
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	buf->place.name->placement.lookup2_index = lookup2_index;
+
+	return 0;
+}
+
+/*
+ * __ssdfs_lookup2_table_add_descriptor() - add a new lookup2 descriptor
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to add a new descriptor in the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - lookup2 table hasn't vacant items.
+ */
+static
+int __ssdfs_lookup2_table_add_descriptor(struct ssdfs_btree_node *node,
+					 struct ssdfs_btree_search *search)
+{
+	struct ssdfs_shdict_ltbl2_item desc;
+	struct ssdfs_btree_search_buffer *buf;
+	u16 items_count;
+	u16 items_capacity;
+	u16 item_size;
+	u16 hash_index;
+	u16 lookup2_index;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+	item_size = node->lookup_tbl_area.index_size;
+
+	buf = &search->result.name_buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!buf->place.name);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_index = buf->place.name->placement.hash_index;
+	lookup2_index = items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u, "
+		  "index_size %u, strings_range.index %u, "
+		  "hash_index %u, lookup2_index %u\n",
+		  items_count, items_capacity, item_size,
+		  search->name.string.strings_range.index,
+		  hash_index, lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (items_count >= items_capacity) {
+		SSDFS_ERR("invalid request: "
+			  "items_count %u >= items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	}
+
+	desc.hash = cpu_to_le64(search->request.start.hash);
+
+	if (search->request.start.name_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid name len %zu\n",
+			  search->request.start.name_len);
+		return -ERANGE;
+	}
+
+	desc.prefix_len = (u8)search->request.start.name_len;
+	desc.hash_index = cpu_to_le16(hash_index);
+	desc.str_count = 1;
+
+	err = ssdfs_set_lookup2_descriptor(node, &node->lookup_tbl_area,
+					   lookup2_index, &desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set lookup2 descriptor: "
+			  "index %u, err %d\n",
+			  lookup2_index, err);
+		return err;
+	}
+
+	if (node->lookup_tbl_area.index_count == 0)
+		node->lookup_tbl_area.start_hash = le64_to_cpu(desc.hash);
+
+	node->lookup_tbl_area.index_count++;
+	node->lookup_tbl_area.end_hash = le64_to_cpu(desc.hash);
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	buf->place.name->placement.lookup2_index = lookup2_index;
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup2_table_insert_new_descriptor() - add a new lookup2 descriptor
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to insert a new descriptor in the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - lookup2 table hasn't vacant items.
+ */
+static
+int ssdfs_lookup2_table_insert_new_descriptor(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	u64 req_hash;
+	u64 found_hash;
+	u16 items_count;
+	u16 items_capacity;
+	u16 item_size;
+	u16 index;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+	item_size = node->lookup_tbl_area.index_size;
+	index = search->name.string.strings_range.index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u, "
+		  "index_size %u, strings_range.index %u\n",
+		  items_count, items_capacity,
+		  item_size, index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (items_count == items_capacity) {
+		SSDFS_ERR("no vacant items: "
+			  "items_count %u, items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ENOSPC;
+	} else if (items_count > items_capacity) {
+		SSDFS_ERR("items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	}
+
+	if (item_size != sizeof(struct ssdfs_shdict_ltbl2_item)) {
+		SSDFS_ERR("invalid item size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	if (index > items_count) {
+		SSDFS_ERR("index %u > items_count %u\n",
+			  index, items_count);
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("valid hash is absent in request\n");
+		return -ERANGE;
+	}
+
+	req_hash = search->request.start.hash;
+	found_hash = le64_to_cpu(search->name.string.strings_range.desc.hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("req_hash %#llx, found_hash %#llx, "
+		  "search->result.state %#x\n",
+		  req_hash, found_hash,
+		  search->result.state);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+		if (req_hash == found_hash) {
+			err = __ssdfs_lookup2_table_insert_descriptor(node,
+								      search);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to insert descriptor: "
+					  "err %d\n", err);
+				return err;
+			}
+		} else if (req_hash < found_hash) {
+			err = __ssdfs_lookup2_table_insert_descriptor(node,
+								      search);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to insert descriptor: "
+					  "err %d\n", err);
+				return err;
+			}
+		} else {
+			search->name.string.strings_range.index++;
+			index = search->name.string.strings_range.index;
+
+			if (index < items_count) {
+				err =
+				   __ssdfs_lookup2_table_insert_descriptor(node,
+									search);
+				if (unlikely(err)) {
+					SSDFS_ERR("fail to insert descriptor: "
+						  "err %d\n", err);
+					return err;
+				}
+			} else {
+				err = __ssdfs_lookup2_table_add_descriptor(node,
+									search);
+				if (unlikely(err)) {
+					SSDFS_ERR("fail to add descriptor: "
+						  "err %d\n", err);
+					return err;
+				}
+			}
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		err = __ssdfs_lookup2_table_add_descriptor(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to add descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected result state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup2_table_insert_descriptor() - insert a lookup2 descriptor
+ * @node: node object
+ * @search: search object
+ * @str_type: type of the string
+ *
+ * This method tries to insert a new descriptor in the lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - lookup2 table hasn't vacant items.
+ */
+static
+int ssdfs_lookup2_table_insert_descriptor(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search,
+					  u8 str_type)
+{
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, str_type %#x\n",
+		  node->node_id, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	if (search->request.count != 1) {
+		SSDFS_ERR("invalid request: "
+			  "search->request.count %u\n",
+			  search->request.count);
+		return -ERANGE;
+	}
+
+	switch (str_type) {
+	case SSDFS_NAME_PREFIX:
+	case SSDFS_FULL_NAME:
+		err = ssdfs_lookup2_table_insert_new_descriptor(node,
+								search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert new descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	case SSDFS_NAME_SUFFIX:
+		err = ssdfs_lookup2_table_inc_str_count(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to increment strings count: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid str_type %#x\n",
+			  str_type);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup1_table_get_range_capacity() - get the capacity for an index
+ * @index: lookup1 table's index
+ */
+static inline
+u16 ssdfs_lookup1_table_get_range_capacity(u16 index)
+{
+	if (index >= SSDFS_SHDIC_LTBL1_SIZE)
+		return U16_MAX;
+
+	return lookup1_tbl_range_capacity[index];
+}
+
+/*
+ * ssdfs_convert_lookup2_to_lookup1_index() - convert lookup2 to lookup1 index
+ * @lookup2_index: lookup2 index
+ */
+static inline
+u16 ssdfs_convert_lookup2_to_lookup1_index(u16 lookup2_index)
+{
+	int cur_index;
+	u16 lower_bound, upper_bound;
+	u16 range_capacity;
+	u16 threshold;
+	u16 found_index = U16_MAX;
+
+	threshold = lookup1_tbl_threshold[0];
+	range_capacity = lookup1_tbl_range_capacity[0];
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("lookup2_index %u, threshold %u, "
+		  "range_capacity %u\n",
+		  lookup2_index, threshold, range_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (lookup2_index < threshold) {
+		/* first index */
+		return 0;
+	}
+
+	threshold = lookup1_tbl_threshold[SSDFS_SHDIC_LTBL1_SIZE - 1];
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("lookup2_index %u, threshold %u\n",
+		  lookup2_index, threshold);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (lookup2_index >= threshold) {
+		/* last index */
+		return SSDFS_SHDIC_LTBL1_SIZE - 1;
+	}
+
+	lower_bound = 1;
+	upper_bound = SSDFS_SHDIC_LTBL1_SIZE - 2;
+	cur_index = SSDFS_SHDIC_LTBL1_SIZE / 2;
+
+	do {
+		threshold = lookup1_tbl_threshold[cur_index];
+		range_capacity = lookup1_tbl_range_capacity[cur_index];
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("lower_bound %u, upper_bound %u, "
+			  "cur_index %u, threshold %u, "
+			  "range_capacity %u\n",
+			  lower_bound, upper_bound, cur_index,
+			  threshold, range_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (lookup2_index >= (threshold - range_capacity) &&
+		    lookup2_index < threshold) {
+			found_index = cur_index;
+			break;
+		} else if (lookup2_index < (threshold - range_capacity)) {
+			/* correct upper_bound */
+			upper_bound = cur_index;
+		} else {
+			/* correct lower_bound */
+			lower_bound = cur_index;
+		}
+
+		cur_index = lower_bound + ((upper_bound - lower_bound) / 2);
+	} while (lower_bound < upper_bound);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("found_index %u\n",
+		  found_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return found_index;
+}
+
+/*
+ * ssdfs_lookup1_table_modify_descriptor() - modify a lookup1 descriptor
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to modify an existing descriptor in the lookup1 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_lookup1_table_modify_descriptor(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_shdict_ltbl1_item *lookup1_tbl;
+	struct ssdfs_shdict_ltbl1_item *found_desc;
+	struct ssdfs_shdict_ltbl1_item read_desc;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t item_size = sizeof(struct ssdfs_shdict_ltbl1_item);
+	u16 items_count;
+	u16 items_capacity;
+	u16 lookup2_index;
+	u16 start_lookup2_index;
+	u16 found_index, calculated_index;
+	u16 range_len;
+	u16 range_capacity;
+	u64 hash64;
+	u16 i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	items_count = le16_to_cpu(node->raw.dict_header.lookup_table1_items);
+	items_capacity = SSDFS_SHDIC_LTBL1_SIZE;
+
+	if (items_count > SSDFS_SHDIC_LTBL1_SIZE) {
+		SSDFS_ERR("invalid lookup_table1_items %u\n",
+			  items_count);
+		return -ERANGE;
+	}
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	lookup2_index = buf->place.name->placement.lookup2_index;
+	calculated_index =
+		ssdfs_convert_lookup2_to_lookup1_index(lookup2_index);
+	if (calculated_index >= U16_MAX) {
+		SSDFS_ERR("invalid lookup1_index: "
+			  "lookup2_index %u\n",
+			  lookup2_index);
+		return -ERANGE;
+	}
+
+	lookup1_tbl = node->raw.dict_header.lookup_table1;
+	found_index = buf->place.name->lookup.index;
+	found_desc = &buf->place.name->lookup.desc;
+
+	start_lookup2_index = le16_to_cpu(found_desc->start_index);
+	if (start_lookup2_index >= U16_MAX) {
+		SSDFS_ERR("invalid lookup1 item: "
+			  "start_lookup2_index %u\n",
+			  start_lookup2_index);
+		return -ERANGE;
+	}
+
+	range_len = le16_to_cpu(found_desc->range_len);
+	if (range_len >= U16_MAX) {
+		SSDFS_ERR("invalid lookup1 item: "
+			  "range_len %u\n",
+			  range_len);
+		return -ERANGE;
+	}
+
+	range_capacity = lookup1_tbl_range_capacity[calculated_index];
+
+	if (lookup2_index < start_lookup2_index ||
+	    lookup2_index > (start_lookup2_index + range_len + 1)) {
+		SSDFS_ERR("invalid range: "
+			  "lookup2_index %u, start_lookup2_index %u, "
+			  "range_len %u\n",
+			  lookup2_index,
+			  start_lookup2_index,
+			  range_len);
+		return -ERANGE;
+	}
+
+	ssdfs_memcpy(&read_desc, 0, item_size,
+		     &lookup1_tbl[calculated_index], 0, item_size,
+		     item_size);
+
+	if (calculated_index == found_index) {
+		if (memcmp(found_desc, &read_desc, item_size) != 0) {
+			SSDFS_ERR("invalid lookup1 descriptors\n");
+			return -ERANGE;
+		}
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("lookup2_index %u, calculated_index %u, "
+		  "requested_hash %#x, "
+		  "found_hash %#x\n",
+		  lookup2_index, calculated_index,
+		  SSDFS_HASH32_LO(search->request.start.hash),
+		  le32_to_cpu(read_desc.hash_lo));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash64 = search->request.start.hash;
+
+	if (SSDFS_HASH32_LO(hash64) < le32_to_cpu(read_desc.hash_lo))
+		read_desc.hash_lo = cpu_to_le32(SSDFS_HASH32_LO(hash64));
+
+	ssdfs_memcpy(&lookup1_tbl[calculated_index], 0, item_size,
+		     &read_desc, 0, item_size,
+		     item_size);
+
+	start_lookup2_index = lookup1_tbl_threshold[calculated_index];
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("calculated_index %u, items_count %u, "
+		  "start_lookup2_index %u\n",
+		  calculated_index, items_count,
+		  start_lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	for (i = calculated_index + 1; i < items_capacity; i++) {
+		struct ssdfs_shdict_ltbl2_item lookup2_item;
+		u16 start_index;
+		u16 index_count;
+
+		index_count = node->lookup_tbl_area.index_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("lookup2_index_count %u\n",
+			  index_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		if (index_count <= start_lookup2_index) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("lookup2_index_count %u, "
+				  "threshold %u\n",
+				  index_count,
+				  start_lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+			goto set_node_header_dirty;
+		}
+
+		if (i < items_count) {
+			ssdfs_memcpy(&read_desc, 0, item_size,
+				     &lookup1_tbl[i], 0, item_size,
+				     item_size);
+
+			start_index = le16_to_cpu(read_desc.start_index);
+			if (start_index >= U16_MAX) {
+				SSDFS_ERR("invalid lookup1 item: "
+					  "start_index %#x\n",
+					  start_index);
+				return -ERANGE;
+			}
+
+			range_len = le16_to_cpu(read_desc.range_len);
+			if (range_len >= U16_MAX) {
+				SSDFS_ERR("invalid lookup1 item: "
+					  "range_len %#x\n",
+					  range_len);
+				return -ERANGE;
+			}
+
+			if ((start_index + range_len) > index_count) {
+				SSDFS_ERR("invalid lookup1 item: "
+					  "start_index %u, "
+					  "range_len %u, "
+					  "index_count %u\n",
+					  start_index,
+					  range_len,
+					  index_count);
+				return -ERANGE;
+			}
+
+			if (start_index != start_lookup2_index) {
+				SSDFS_ERR("invalid lookup1 item: "
+					  "start_index %u, "
+					  "start_lookup2_index %u\n",
+					  start_index,
+					  start_lookup2_index);
+				return -ERANGE;
+			}
+
+			err = ssdfs_get_lookup2_descriptor(node,
+						&node->lookup_tbl_area,
+						start_lookup2_index,
+						&lookup2_item);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to extract: "
+					  "index %u, err %d\n",
+					  start_lookup2_index,
+					  err);
+				return err;
+			}
+
+			hash64 = le64_to_cpu(lookup2_item.hash);
+			read_desc.hash_lo =
+					cpu_to_le32(SSDFS_HASH32_LO(hash64));
+			read_desc.start_index =
+					cpu_to_le16(start_lookup2_index);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("lookup1_index %u, lookup2_index %u, "
+				  "hash_lo %#x, range_len %u\n",
+				  i, start_lookup2_index,
+				  le32_to_cpu(read_desc.hash_lo),
+				  range_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			ssdfs_memcpy(&lookup1_tbl[i], 0, item_size,
+				     &read_desc, 0, item_size,
+				     item_size);
+		} else {
+			err = ssdfs_get_lookup2_descriptor(node,
+						&node->lookup_tbl_area,
+						start_lookup2_index,
+						&lookup2_item);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to extract: "
+					  "index %u, err %d\n",
+					  start_lookup2_index,
+					  err);
+				return err;
+			}
+
+			hash64 = le64_to_cpu(lookup2_item.hash);
+			read_desc.hash_lo =
+					cpu_to_le32(SSDFS_HASH32_LO(hash64));
+			read_desc.start_index =
+					cpu_to_le16(start_lookup2_index);
+			read_desc.range_len = cpu_to_le16(0);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("lookup1_index %u, lookup2_index %u, "
+				  "hash_lo %#x, range_len %u\n",
+				  i, start_lookup2_index,
+				  le32_to_cpu(read_desc.hash_lo),
+				  le16_to_cpu(read_desc.range_len));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			ssdfs_memcpy(&lookup1_tbl[i], 0, item_size,
+				     &read_desc, 0, item_size,
+				     item_size);
+
+			le16_add_cpu(&node->raw.dict_header.lookup_table1_items,
+				     1);
+		}
+
+		start_lookup2_index = lookup1_tbl_threshold[i];
+	}
+
+set_node_header_dirty:
+	items_count = le16_to_cpu(node->raw.dict_header.lookup_table1_items);
+
+	ssdfs_memcpy(&read_desc, 0, item_size,
+		     &lookup1_tbl[items_count - 1], 0, item_size,
+		     item_size);
+
+	le16_add_cpu(&read_desc.range_len, 1);
+
+	ssdfs_memcpy(&lookup1_tbl[items_count - 1], 0, item_size,
+		     &read_desc, 0, item_size,
+		     item_size);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, range_len %u\n",
+		  items_count,
+		  le16_to_cpu(read_desc.range_len));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_set_node_header_dirty(node,
+					  node->items_area.items_capacity);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set header dirty: err %d\n",
+			  err);
+		return err;
+	}
+
+	buf->place.name->placement.lookup1_index = calculated_index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("LOOKUP1 TABLE DUMP\n");
+	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+			     lookup1_tbl,
+			     sizeof(struct ssdfs_shdict_ltbl1_item) *
+				SSDFS_SHDIC_LTBL1_SIZE);
+	SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup1_table_add_descriptor() - add a lookup1 descriptor in the table
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to add a new descriptor in the lookup1 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_lookup1_table_add_descriptor(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search)
+{
+	struct ssdfs_shdict_ltbl1_item *lookup1_tbl;
+	struct ssdfs_shdict_ltbl1_item read_desc;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t item_size = sizeof(struct ssdfs_shdict_ltbl1_item);
+	u16 items_count;
+	u16 lookup2_index = 0;
+	u16 calculated_index = 0;
+	u16 start_index;
+	u16 range_len;
+	u16 range_capacity = 0;
+	u64 hash64;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	items_count = le16_to_cpu(node->raw.dict_header.lookup_table1_items);
+
+	if (items_count > SSDFS_SHDIC_LTBL1_SIZE) {
+		SSDFS_ERR("invalid lookup_table1_items %u\n",
+			  items_count);
+		return -ERANGE;
+	}
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	lookup1_tbl = node->raw.dict_header.lookup_table1;
+
+	if (items_count == 0) {
+		calculated_index = 0;
+	} else {
+		lookup2_index = buf->place.name->placement.lookup2_index;
+		calculated_index =
+			ssdfs_convert_lookup2_to_lookup1_index(lookup2_index);
+		if (calculated_index >= U16_MAX) {
+			SSDFS_ERR("invalid lookup1_index: "
+				  "lookup2_index %u\n",
+				  lookup2_index);
+			return -ERANGE;
+		}
+
+		range_capacity = lookup1_tbl_range_capacity[calculated_index];
+	}
+
+	if (calculated_index == items_count) {
+		hash64 = search->request.start.hash;
+		read_desc.hash_lo = cpu_to_le32(SSDFS_HASH32_LO(hash64));
+		read_desc.start_index = cpu_to_le16(lookup2_index);
+		read_desc.range_len = cpu_to_le16(1);
+
+		ssdfs_memcpy(&lookup1_tbl[calculated_index], 0, item_size,
+			     &read_desc, 0, item_size,
+			     item_size);
+
+		le16_add_cpu(&node->raw.dict_header.lookup_table1_items, 1);
+	} else {
+		ssdfs_memcpy(&read_desc, 0, item_size,
+			     &lookup1_tbl[calculated_index], 0, item_size,
+			     item_size);
+
+		start_index = le16_to_cpu(read_desc.start_index);
+		if (start_index >= U16_MAX) {
+			SSDFS_ERR("invalid lookup1 item: "
+				  "start_index %#x\n",
+				  start_index);
+			return -ERANGE;
+		}
+
+		range_len = le16_to_cpu(read_desc.range_len);
+		if (range_len >= U16_MAX) {
+			SSDFS_ERR("invalid lookup1 item: "
+				  "range_len %#x\n",
+				  range_len);
+			return -ERANGE;
+		}
+
+		if (lookup2_index < start_index ||
+		    lookup2_index > (start_index + range_len + 1)) {
+			SSDFS_ERR("invalid range: "
+				  "lookup2_index %u, start_index %u, "
+				  "range_len %u, calculated_index %u\n",
+				  lookup2_index,
+				  start_index,
+				  range_len,
+				  calculated_index);
+
+			if (calculated_index > 0) {
+				ssdfs_memcpy(&read_desc, 0, item_size,
+					     &lookup1_tbl[calculated_index - 1],
+					     0, item_size,
+					     item_size);
+				start_index = le16_to_cpu(read_desc.start_index);
+				range_len = le16_to_cpu(read_desc.range_len);
+
+				SSDFS_ERR("invalid range: "
+					  "lookup2_index %u, start_index %u, "
+					  "range_len %u, calculated_index %u\n",
+					  lookup2_index,
+					  start_index,
+					  range_len,
+					  calculated_index - 1);
+			}
+
+			return -ERANGE;
+		}
+
+		if (range_len == range_capacity) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("unable to add into lookup1 table: "
+				  "range_len %u, range_capacity %u\n",
+				  range_len, range_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return -ENOSPC;
+		}
+
+		if (range_len > range_capacity) {
+			SSDFS_ERR("corrupted lookup1 table: "
+				  "range_len %u, range_capacity %u\n",
+				  range_len, range_capacity);
+			return -ERANGE;
+		}
+
+		if (start_index == lookup2_index) {
+			hash64 = search->request.start.hash;
+			read_desc.hash_lo =
+				cpu_to_le32(SSDFS_HASH32_LO(hash64));
+		}
+
+		le16_add_cpu(&read_desc.range_len, 1);
+
+		ssdfs_memcpy(&lookup1_tbl[calculated_index], 0, item_size,
+			     &read_desc, 0, item_size,
+			     item_size);
+	}
+
+	err = ssdfs_set_node_header_dirty(node,
+					  node->items_area.items_capacity);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set header dirty: err %d\n",
+			  err);
+		return err;
+	}
+
+	buf->place.name->placement.lookup1_index = calculated_index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("LOOKUP1 TABLE DUMP\n");
+	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+			     lookup1_tbl,
+			     sizeof(struct ssdfs_shdict_ltbl1_item) *
+				SSDFS_SHDIC_LTBL1_SIZE);
+	SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup1_table_insert_descriptor() - insert a lookup1 descriptor
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to insert a new descriptor in the lookup1 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_lookup1_table_insert_descriptor(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search,
+					  u8 str_type)
+{
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+	BUG_ON(!search->result.name_buf.place.name);
+
+	SSDFS_DBG("node_id %u, str_type %#x\n",
+		  node->node_id, str_type);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (str_type) {
+	case SSDFS_NAME_PREFIX:
+	case SSDFS_FULL_NAME:
+		if (!search->result.name_buf.place.name) {
+			SSDFS_ERR("invalid name buffer\n");
+			return -ERANGE;
+		}
+
+		err = ssdfs_lookup1_table_add_descriptor(node, search);
+		if (err == -ENOSPC) {
+			err = ssdfs_lookup1_table_modify_descriptor(node,
+								    search);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to modify the lookup1 table: "
+					  "err %d\n", err);
+				return err;
+			}
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to add lookup1 descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	case SSDFS_NAME_SUFFIX:
+		/*
+		 * No record was added into lookup2 table for the suffix.
+		 * Do nothing.
+		 */
+		break;
+
+	default:
+		SSDFS_ERR("invalid str_type %#x\n",
+			  str_type);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_check_node_consistency() - check a node's consistency
+ * @node: node object
+ *
+ * This method tries to check a node's consistency.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_check_node_consistency(struct ssdfs_btree_node *node)
+{
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	u16 index_area_size;
+	u16 str_area_offset;
+	u16 str_area_bytes;
+	u16 hash_tbl_offset;
+	u16 hash_tbl_size;
+	u16 lookup_tbl2_offset;
+	u16 lookup_tbl2_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_check_items_area(node, &node->items_area);
+	if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't free space\n",
+			  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+		err = 0;
+		/* continue logic */
+	} else if (unlikely(err)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("items area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	err = ssdfs_check_lookup2_table_area(node, &node->lookup_tbl_area);
+	if (unlikely(err)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("lookup2 table area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	err = ssdfs_check_hash_table_area(node, &node->hash_tbl_area);
+	if (unlikely(err)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("hash table area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	index_area_size = node->index_area.area_size;
+	str_area_offset = node->items_area.offset;
+	str_area_bytes = node->items_area.area_size;
+	hash_tbl_offset = node->hash_tbl_area.offset;
+	hash_tbl_size = node->hash_tbl_area.area_size;
+	lookup_tbl2_offset = node->lookup_tbl_area.offset;
+	lookup_tbl2_size = node->lookup_tbl_area.area_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("index_area_size %u, str_area_offset %u, "
+		  "str_area_bytes %u, hash_tbl_offset %u, "
+		  "hash_tbl_size %u, lookup_tbl2_offset %u, "
+		  "lookup_tbl2_size %u\n",
+		  index_area_size, str_area_offset,
+		  str_area_bytes, hash_tbl_offset,
+		  hash_tbl_size, lookup_tbl2_offset,
+		  lookup_tbl2_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (str_area_offset != (hdr_size + index_area_size)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted strings area: "
+			  "str_area_offset %u, hdr_size %zu, "
+			  "index_area_size %u\n",
+			  str_area_offset,
+			  hdr_size,
+			  index_area_size);
+		return -ERANGE;
+	}
+
+	if (hash_tbl_offset != (str_area_offset + str_area_bytes)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted hash table: "
+			  "hash_tbl_offset %u, str_area_offset %u, "
+			  "str_area_bytes %u\n",
+			  hash_tbl_offset,
+			  str_area_offset,
+			  str_area_bytes);
+		return -ERANGE;
+	}
+
+	if (lookup_tbl2_offset != (hash_tbl_offset + hash_tbl_size)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted lookup table: "
+			  "lookup_tbl2_offset %u, hash_tbl_offset %u, "
+			  "hash_tbl_size %u\n",
+			  lookup_tbl2_offset,
+			  hash_tbl_offset,
+			  hash_tbl_size);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_add_full_name() - add a full name into the node
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to insert a full name into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_add_full_name(struct ssdfs_btree_node *node,
+			struct ssdfs_btree_search *search)
+{
+	size_t hdesc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	size_t l2desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t str_len;
+	size_t requested_size;
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 threshold;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain valid name\n");
+		return -ERANGE;
+	}
+
+	if (!search->request.start.name) {
+		SSDFS_ERR("empty name pointer\n");
+		return -ERANGE;
+	}
+
+	str_len = search->request.start.name_len;
+
+	if (str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid str_len %zu\n", str_len);
+		return -ERANGE;
+	}
+
+	requested_size = str_len + l2desc_size + hdesc_size;
+
+	down_write(&node->header_lock);
+
+	if (!is_free_space_enough(node, requested_size)) {
+		err = -ENOSPC;
+		node->items_area.items_capacity = node->items_area.items_count;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't enough free space: "
+			  "requested_size %zu\n",
+			  node->node_id, requested_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_add_full_name;
+	}
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+	if (free_space < requested_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: free_space %u\n",
+			  free_space);
+		goto finish_add_full_name;
+	}
+
+	if (area_size < free_space) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		goto finish_add_full_name;
+	}
+
+	area_size -= l2desc_size + hdesc_size;
+
+	err = ssdfs_resize_string_area(node, area_offset, area_size);
+	if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_add_full_name;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if (area_offset <= (l2desc_size + hdesc_size)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		goto finish_add_full_name;
+	}
+
+	if (threshold != (area_offset - (l2desc_size + hdesc_size))) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		goto finish_add_full_name;
+	}
+
+	area_offset -= l2desc_size + hdesc_size;
+	area_size += hdesc_size;
+
+	err = ssdfs_resize_hash_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize hash table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->lookup_tbl_area.offset;
+	area_size = node->lookup_tbl_area.area_size;
+
+	if (area_offset <= l2desc_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		goto finish_add_full_name;
+	}
+
+	if (threshold != (area_offset - l2desc_size)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		goto finish_add_full_name;
+	}
+
+	area_offset -= l2desc_size;
+	area_size += l2desc_size;
+
+	err = ssdfs_resize_lookup2_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize lookup2 table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		goto finish_add_full_name;
+	}
+
+	err = ssdfs_insert_full_string(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert the full string: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_hash_table_insert_descriptor(node, search,
+						 (u8)str_len,
+						 SSDFS_FULL_NAME);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash descriptor: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_lookup2_table_insert_descriptor(node, search,
+						    SSDFS_FULL_NAME);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert lookup2 descriptor: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_lookup1_table_insert_descriptor(node, search,
+						    SSDFS_FULL_NAME);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert lookup1 descriptor: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+check_node_consistency:
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_add_full_name;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+finish_add_full_name:
+	up_write(&node->header_lock);
+
+	return err;
+}
+
+#define SSDFS_LOWER_PREFIX_THRESHOLD	(SSDFS_DENTRY_INLINE_NAME_MAX_LEN / 2)
+#define SSDFS_DEFAULT_PREFIX_LEN	(SSDFS_DENTRY_INLINE_NAME_MAX_LEN)
+
+/*
+ * ssdfs_create_prefix_for_left_name() - create the prefix for left name
+ * @node: node object
+ * @search: search object
+ * @prefix_len: length of the prefix
+ *
+ * This method tries to create the prefix for left name in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EOPNOTSUPP - unable to create the prefix.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+static
+int ssdfs_create_prefix_for_left_name(struct ssdfs_btree_node *node,
+				      struct ssdfs_btree_search *search,
+				      u16 prefix_len)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name, *right_name;
+	struct ssdfs_strings_range_descriptor *strings_range;
+	struct ssdfs_shdict_htbl_item read_hdesc;
+	struct ssdfs_shdict_ltbl2_item read_ldesc;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t hdesc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	size_t l2desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t str_len;
+	size_t requested_size;
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 threshold;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u, prefix_len %u\n",
+		  node->node_id, prefix_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	prefix = &buf->place.name->prefix;
+	left_name = &buf->place.name->left_name;
+	right_name = &buf->place.name->right_name;
+	strings_range = &buf->place.name->strings_range;
+
+	switch (prefix->desc.type) {
+	case SSDFS_FULL_NAME:
+		/* expected type */
+		break;
+
+	case SSDFS_NAME_PREFIX:
+		SSDFS_ERR("unsupported type %#x\n",
+			  prefix->desc.type);
+		return -EOPNOTSUPP;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  prefix->desc.type);
+		return -ERANGE;
+	}
+
+	switch (left_name->desc.type) {
+	case SSDFS_FULL_NAME:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  left_name->desc.type);
+		return -ERANGE;
+	}
+
+	if (prefix->index != left_name->index) {
+		SSDFS_ERR("prefix->index %u != left_name->index %u\n",
+			  prefix->index,
+			  left_name->index);
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain valid name\n");
+		return -ERANGE;
+	}
+
+	if (!search->request.start.name) {
+		SSDFS_ERR("empty name pointer\n");
+		return -ERANGE;
+	}
+
+	str_len = search->request.start.name_len;
+
+	if (str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid str_len %zu\n", str_len);
+		return -ERANGE;
+	}
+
+	if (prefix_len > str_len) {
+		SSDFS_ERR("prefix_len %u > str_len %zu\n",
+			  prefix_len, str_len);
+		return -ERANGE;
+	}
+
+	requested_size = hdesc_size;
+
+	down_write(&node->header_lock);
+
+	if (!is_free_space_enough(node, requested_size)) {
+		err = -ENOSPC;
+		node->items_area.items_capacity = node->items_area.items_count;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't enough free space: "
+			  "requested_size %zu\n",
+			  node->node_id, requested_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_create_left_prefix;
+	}
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+	if (free_space < requested_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: free_space %u\n",
+			  free_space);
+		goto finish_create_left_prefix;
+	}
+
+	if (area_size < free_space) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		goto finish_create_left_prefix;
+	}
+
+	area_size -= hdesc_size;
+
+	err = ssdfs_resize_string_area(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if (area_offset < requested_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		goto finish_create_left_prefix;
+	}
+
+	if (threshold != (area_offset - requested_size)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		goto finish_create_left_prefix;
+	}
+
+	area_offset -= hdesc_size;
+	area_size += hdesc_size;
+
+	err = ssdfs_resize_hash_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize hash table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	threshold = area_offset + area_size;
+	area_offset = node->lookup_tbl_area.offset;
+
+	if (threshold != area_offset) {
+		err = -ERANGE;
+		SSDFS_ERR("threshold %u != area_offset %u\n",
+			  threshold, area_offset);
+		goto check_node_consistency;
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					prefix->index, &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  prefix->index, err);
+		goto check_node_consistency;
+	}
+
+	if (memcmp(&read_hdesc, &prefix->desc, hdesc_size) != 0) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted node: "
+			  "different hash descriptors: "
+			  "index %u\n", prefix->index);
+		goto check_node_consistency;
+	}
+
+	str_len = read_hdesc.str_len;
+	read_hdesc.str_len = (u8)prefix_len;
+	read_hdesc.type = SSDFS_NAME_PREFIX;
+
+	err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+					prefix->index, &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set hash descriptor: "
+			  "index %u, err %d\n",
+			  prefix->index, err);
+		goto check_node_consistency;
+	}
+
+	ssdfs_mark_hash_table_dirty(node);
+
+	ssdfs_memcpy(&prefix->desc, 0, hdesc_size,
+		     &read_hdesc, 0, hdesc_size,
+		     hdesc_size);
+
+	le16_add_cpu(&read_hdesc.str_offset, prefix_len);
+	read_hdesc.str_len = (u8)(str_len - prefix_len);
+	read_hdesc.type = SSDFS_NAME_SUFFIX;
+
+	if (left_name->index == right_name->index) {
+		left_name->index = prefix->index + 1;
+		right_name->index = left_name->index;
+	} else {
+		left_name->index = prefix->index + 1;
+		right_name->index = left_name->index + 1;
+	}
+
+	err = __ssdfs_hash_table_insert_descriptor(node, search,
+						   left_name->index,
+						   &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash descriptor: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					left_name->index, &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  left_name->index, err);
+		goto check_node_consistency;
+	}
+
+	ssdfs_memcpy(&left_name->desc, 0, hdesc_size,
+		     &read_hdesc, 0, hdesc_size,
+		     hdesc_size);
+
+	if (left_name->index == right_name->index) {
+		ssdfs_memcpy(&right_name->desc, 0, hdesc_size,
+			     &read_hdesc, 0, hdesc_size,
+			     hdesc_size);
+	}
+
+	err = ssdfs_get_lookup2_descriptor(node,
+					   &node->lookup_tbl_area,
+					   strings_range->index,
+					   &read_ldesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to extract lookup2 item: "
+			  "index %u, err %d\n",
+			  search->name.string.strings_range.index,
+			  err);
+		goto check_node_consistency;
+	}
+
+	if (memcmp(&read_ldesc, &strings_range->desc, l2desc_size) != 0) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted node: "
+			  "different lookup2 descriptors: "
+			  "index %u\n",
+			  strings_range->index);
+		goto check_node_consistency;
+	}
+
+	read_ldesc.prefix_len = (u8)prefix_len;
+
+	if (read_ldesc.str_count != 1) {
+		err = -ERANGE;
+		SSDFS_ERR("invalid str_count %u\n",
+			  read_ldesc.str_count);
+		goto check_node_consistency;
+	}
+
+	/* Prefix needs to be accounted as string too */
+	read_ldesc.str_count++;
+
+	err = ssdfs_set_lookup2_descriptor(node,
+					   &node->lookup_tbl_area,
+					   strings_range->index,
+					   &read_ldesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set lookup2 item: "
+			  "index %u, err %d\n",
+			  strings_range->index, err);
+		goto check_node_consistency;
+	}
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	ssdfs_memcpy(&strings_range->desc, 0, l2desc_size,
+		     &read_ldesc, 0, l2desc_size,
+		     l2desc_size);
+
+check_node_consistency:
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_create_left_prefix;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+finish_create_left_prefix:
+	up_write(&node->header_lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+
+/*
+ * ssdfs_create_prefix_for_right_name() - create the prefix for right name
+ * @node: node object
+ * @search: search object
+ * @prefix_len: length of the prefix
+ *
+ * This method tries to create the prefix for left name in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EOPNOTSUPP - unable to create the prefix.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+static
+int ssdfs_create_prefix_for_right_name(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search,
+					u16 prefix_len)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name, *right_name;
+	struct ssdfs_strings_range_descriptor *strings_range;
+	struct ssdfs_shdict_htbl_item read_hdesc;
+	struct ssdfs_shdict_ltbl2_item read_ldesc;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t hdesc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	size_t l2desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t str_len;
+	u64 hash;
+	u16 str_offset;
+	size_t requested_size;
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 threshold;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u, prefix_len %u\n",
+		  node->node_id, prefix_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	prefix = &buf->place.name->prefix;
+	left_name = &buf->place.name->left_name;
+	right_name = &buf->place.name->right_name;
+	strings_range = &buf->place.name->strings_range;
+
+	switch (right_name->desc.type) {
+	case SSDFS_FULL_NAME:
+		/* expected type */
+		break;
+
+	case SSDFS_NAME_PREFIX:
+		SSDFS_ERR("unsupported type %#x\n",
+			  right_name->desc.type);
+		return -EOPNOTSUPP;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  right_name->desc.type);
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain valid name\n");
+		return -ERANGE;
+	}
+
+	if (!search->request.start.name) {
+		SSDFS_ERR("empty name pointer\n");
+		return -ERANGE;
+	}
+
+	str_len = search->request.start.name_len;
+
+	if (str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid str_len %zu\n", str_len);
+		return -ERANGE;
+	}
+
+	if (prefix_len > str_len) {
+		SSDFS_ERR("prefix_len %u > str_len %zu\n",
+			  prefix_len, str_len);
+		return -ERANGE;
+	}
+
+	requested_size = hdesc_size;
+
+	down_write(&node->header_lock);
+
+	if (!is_free_space_enough(node, requested_size)) {
+		err = -ENOSPC;
+		node->items_area.items_capacity = node->items_area.items_count;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't enough free space: "
+			  "requested_size %zu\n",
+			  node->node_id, requested_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_create_right_prefix;
+	}
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+	if (free_space < requested_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: free_space %u\n",
+			  free_space);
+		goto finish_create_right_prefix;
+	}
+
+	if (area_size < free_space) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		goto finish_create_right_prefix;
+	}
+
+	area_size -= hdesc_size;
+
+	err = ssdfs_resize_string_area(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if (area_offset < requested_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		goto finish_create_right_prefix;
+	}
+
+	if (threshold != (area_offset - requested_size)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		goto finish_create_right_prefix;
+	}
+
+	area_offset -= hdesc_size;
+	area_size += hdesc_size;
+
+	err = ssdfs_resize_hash_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize hash table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		goto check_node_consistency;
+	}
+
+	threshold = area_offset + area_size;
+	area_offset = node->lookup_tbl_area.offset;
+
+	if (threshold != area_offset) {
+		err = -ERANGE;
+		SSDFS_ERR("threshold %u != area_offset %u\n",
+			  threshold, area_offset);
+		goto check_node_consistency;
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					right_name->index, &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  right_name->index, err);
+		goto check_node_consistency;
+	}
+
+	if (memcmp(&read_hdesc, &right_name->desc, hdesc_size) != 0) {
+		err = -ERANGE;
+		SSDFS_ERR("corrupted node: "
+			  "different hash descriptors: "
+			  "index %u\n",
+			  right_name->index);
+		goto check_node_consistency;
+	}
+
+	str_len = read_hdesc.str_len;
+	hash = le64_to_cpu(read_hdesc.hash);
+	str_offset = le16_to_cpu(read_hdesc.str_offset);
+	read_hdesc.str_len = (u8)prefix_len;
+	read_hdesc.type = SSDFS_NAME_PREFIX;
+
+	err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+					right_name->index, &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set hash descriptor: "
+			  "index %u, err %d\n",
+			  right_name->index, err);
+		goto check_node_consistency;
+	}
+
+	ssdfs_mark_hash_table_dirty(node);
+
+	ssdfs_memcpy(&prefix->desc, 0, hdesc_size,
+		     &read_hdesc, 0, hdesc_size,
+		     hdesc_size);
+	prefix->index = right_name->index;
+	ssdfs_memcpy(&left_name->desc, 0, hdesc_size,
+		     &read_hdesc, 0, hdesc_size,
+		     hdesc_size);
+	left_name->index = right_name->index;
+
+	read_hdesc.hash = cpu_to_le64(hash);
+	read_hdesc.str_offset = cpu_to_le16(str_offset + prefix_len);
+	read_hdesc.str_len = (u8)(str_len - prefix_len);
+	read_hdesc.type = SSDFS_NAME_SUFFIX;
+
+	err = __ssdfs_hash_table_insert_descriptor(node, search,
+						   right_name->index + 1,
+						   &read_hdesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash descriptor: "
+			  "index %u, err %d\n",
+			  right_name->index + 1, err);
+		goto check_node_consistency;
+	}
+
+	ssdfs_memcpy(&right_name->desc, 0, hdesc_size,
+		     &read_hdesc, 0, hdesc_size,
+		     hdesc_size);
+	right_name->index++;
+
+	err = ssdfs_get_lookup2_descriptor(node,
+					   &node->lookup_tbl_area,
+					   strings_range->index + 1,
+					   &read_ldesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to extract lookup2 item: "
+			  "index %u, err %d\n",
+			  strings_range->index + 1,
+			  err);
+		goto check_node_consistency;
+	}
+
+	if (le16_to_cpu(read_ldesc.hash_index) != prefix->index) {
+		err = -ERANGE;
+		SSDFS_ERR("hash_index %u != prefix->index %u\n",
+			  le16_to_cpu(read_ldesc.hash_index),
+			  prefix->index);
+		goto check_node_consistency;
+	}
+
+	if (read_ldesc.str_count != 1) {
+		err = -ERANGE;
+		SSDFS_ERR("invalid str_count %u\n",
+			  read_ldesc.str_count);
+		goto check_node_consistency;
+	}
+
+	read_ldesc.prefix_len = (u8)prefix_len;
+
+	/* Prefix needs to be accounted as string too */
+	read_ldesc.str_count++;
+
+	err = ssdfs_set_lookup2_descriptor(node,
+					   &node->lookup_tbl_area,
+					   strings_range->index + 1,
+					   &read_ldesc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set lookup2 item: "
+			  "index %u, err %d\n",
+			  strings_range->index + 1, err);
+		goto check_node_consistency;
+	}
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	ssdfs_memcpy(&strings_range->desc, 0, l2desc_size,
+		     &read_ldesc, 0, l2desc_size,
+		     l2desc_size);
+	strings_range->index++;
+
+check_node_consistency:
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_create_right_prefix;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+finish_create_right_prefix:
+	up_write(&node->header_lock);
+
+	return err;
+}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+
+/*
+ * __ssdfs_insert_suffix() - insert a name's suffix in the node
+ * @node: node object
+ * @search: search object
+ * @prefix_len: length of the prefix
+ *
+ * This method tries to insert a name's suffix in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+static
+int __ssdfs_insert_suffix(struct ssdfs_btree_node *node,
+			  struct ssdfs_btree_search *search,
+			  u16 prefix_len)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name, *right_name;
+	const char *name;
+	struct ssdfs_shdict_htbl_item read_hdesc;
+	struct ssdfs_btree_search_buffer *buf;
+	u32 area_size;
+	u32 free_space;
+	u16 items_count;
+	u32 items_capacity;
+	size_t name_len, suffix_len;
+	u16 str_offset;
+	u64 insert_hash;
+	u64 prefix_hash;
+	u64 lname_hash;
+	u64 rname_hash;
+	u32 range_len;
+	u8 min_item_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	items_count = node->items_area.items_count;
+	min_item_size = node->items_area.min_item_size;
+
+	if (min_item_size != SSDFS_DENTRY_INLINE_NAME_MAX_LEN) {
+		SSDFS_ERR("invalid min_item_size %u\n",
+			  min_item_size);
+		return -ERANGE;
+	}
+
+	if (free_space > area_size) {
+		SSDFS_ERR("free_space %u > area_size %u\n",
+			  free_space, area_size);
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain the name\n");
+		return -ERANGE;
+	}
+
+	if (search->request.count != 1) {
+		SSDFS_ERR("invalid request: "
+			  "search->request.count %u\n",
+			  search->request.count);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("empty name descriptor\n");
+		return -ERANGE;
+	}
+
+	prefix = &buf->place.name->prefix;
+	left_name = &buf->place.name->left_name;
+	right_name = &buf->place.name->right_name;
+
+	if (prefix->desc.str_len != prefix_len) {
+		SSDFS_ERR("desc.str_len %u != prefix_len %u\n",
+			  prefix->desc.str_len,
+			  prefix_len);
+		return -ERANGE;
+	}
+
+	name_len = search->request.start.name_len;
+
+	if (prefix_len >= name_len) {
+		SSDFS_ERR("prefix_len %u >= name_len %zu\n",
+			  prefix_len, name_len);
+		return -ERANGE;
+	}
+
+	suffix_len = name_len - prefix_len;
+
+	if (suffix_len > free_space) {
+		SSDFS_ERR("suffix_len %zu > free_space %u\n",
+			  suffix_len, free_space);
+		return -ENOSPC;
+	}
+
+	name = search->request.start.name;
+
+	if (!name) {
+		SSDFS_ERR("invalid name pointer\n");
+		return -ERANGE;
+	}
+
+	switch (prefix->desc.type) {
+	case SSDFS_NAME_PREFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("unexpected left_name type %#x\n",
+			  left_name->desc.type);
+		return -ERANGE;
+	}
+
+	insert_hash = search->request.start.hash;
+	rname_hash = le64_to_cpu(right_name->desc.hash);
+	lname_hash = le64_to_cpu(left_name->desc.hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("insert_hash %#llx, lname_hash %#llx, "
+		  "rname_hash %#llx\n",
+		  insert_hash, lname_hash,
+		  rname_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (right_name->desc.type) {
+	case SSDFS_FULL_NAME:
+	case SSDFS_NAME_PREFIX:
+		if (insert_hash >= rname_hash) {
+			SSDFS_ERR("invalid position: "
+				  "name->hash %#llx, "
+				  "desc.hash %#llx\n",
+				  insert_hash,
+				  rname_hash);
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_NAME_SUFFIX:
+		if (left_name->index <= right_name->index) {
+			if (insert_hash == rname_hash) {
+				SSDFS_ERR("invalid position: "
+					  "name->hash %#llx, "
+					  "desc.hash %#llx\n",
+					  insert_hash,
+					  rname_hash);
+				return -ERANGE;
+			}
+		} else {
+			SSDFS_ERR("corrupted node: "
+				  "left_name->index %u, "
+				  "right_name->index %u\n",
+				  left_name->index,
+				  right_name->index);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected right_name type %#x\n",
+			  right_name->desc.type);
+		return -ERANGE;
+	}
+
+	switch (left_name->desc.type) {
+	case SSDFS_NAME_PREFIX:
+	case SSDFS_NAME_SUFFIX:
+		if (insert_hash == lname_hash) {
+			SSDFS_ERR("invalid position: "
+				  "name->hash %#llx, "
+				  "desc.hash %#llx\n",
+				  insert_hash,
+				  lname_hash);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected left_name type %#x\n",
+			  left_name->desc.type);
+		return -ERANGE;
+	}
+
+	if (insert_hash > rname_hash) {
+		/* insert after right suffix */
+		str_offset = le16_to_cpu(right_name->desc.str_offset);
+		str_offset += right_name->desc.str_len;
+	} else if (insert_hash > lname_hash) {
+		/* insert after left suffix */
+		str_offset = le16_to_cpu(left_name->desc.str_offset);
+		str_offset += left_name->desc.str_len;
+	} else if (insert_hash < lname_hash) {
+		/* insert before left suffix */
+		str_offset = le16_to_cpu(left_name->desc.str_offset);
+	} else
+		BUG();
+
+	range_len = area_size - free_space - str_offset;
+
+	if (range_len > 0) {
+		err = ssdfs_shift_memory_range_right(node, &node->items_area,
+						     str_offset, range_len,
+						     suffix_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift the range: "
+				  "start %u, range %u, "
+				  "shift %zu, err %d\n",
+				  str_offset, range_len, suffix_len, err);
+			return err;
+		}
+	}
+
+	err = ssdfs_copy_string_from_buffer(node,
+					    name + prefix_len,
+					    suffix_len,
+					    str_offset);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to copy string: "
+			  "node_id %u, str_offset %u, "
+			  "suffix_len %zu, err %d\n",
+			  node->node_id, str_offset,
+			  suffix_len, err);
+		return err;
+	}
+
+	prefix_hash = le64_to_cpu(prefix->desc.hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("prefix_hash %#llx, insert_hash %#llx\n",
+		  prefix_hash, insert_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (insert_hash < prefix_hash) {
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						prefix->index, &read_hdesc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  prefix->index, err);
+			return err;
+		}
+
+		read_hdesc.hash = cpu_to_le64(insert_hash);
+
+		err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+						prefix->index, &read_hdesc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set hash descriptor: "
+				  "index %u, err %d\n",
+				  prefix->index, err);
+			return err;
+		}
+
+		ssdfs_mark_hash_table_dirty(node);
+	}
+
+	node->items_area.items_count += 1;
+	node->items_area.free_space -= suffix_len;
+
+	node->items_area.item_size = ssdfs_define_item_size(node);
+
+	items_capacity = ssdfs_define_items_capacity(node);
+	if (items_capacity >= U16_MAX) {
+		SSDFS_ERR("invalid items_capacity %u\n",
+			  items_capacity);
+		return -ERANGE;
+	}
+
+	node->items_area.items_capacity = (u16)items_capacity;
+
+	if (search->request.start.hash < node->items_area.start_hash)
+		node->items_area.start_hash = search->request.start.hash;
+
+	if (node->items_area.end_hash < search->request.start.hash)
+		node->items_area.end_hash = search->request.start.hash;
+
+	return 0;
+}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+
+/*
+ * ssdfs_insert_suffix() - insert a name's suffix in the node
+ * @node: node object
+ * @search: search object
+ * @prefix_len: length of the prefix
+ *
+ * This method tries to insert a name's suffix in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+static
+int ssdfs_insert_suffix(struct ssdfs_btree_node *node,
+			struct ssdfs_btree_search *search,
+			u16 prefix_len)
+{
+	size_t hdesc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	size_t str_len;
+	size_t requested_size;
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 threshold;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	str_len = search->request.start.name_len;
+	requested_size = (str_len - prefix_len) + hdesc_size;
+
+	if (!is_free_space_enough(node, requested_size)) {
+		node->items_area.items_capacity = node->items_area.items_count;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't enough free space: "
+			  "requested_size %zu\n",
+			  node->node_id, requested_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENOSPC;
+	}
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+	if (free_space < requested_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: free_space %u\n",
+			  free_space);
+		return -ERANGE;
+	}
+
+	if (area_size < free_space) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		return -ERANGE;
+	}
+
+	area_size -= hdesc_size;
+
+	err = ssdfs_resize_string_area(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		return err;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if (area_offset <= hdesc_size) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		return -ERANGE;
+	}
+
+	if (threshold != (area_offset - hdesc_size)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		return -ERANGE;
+	}
+
+	area_offset -= hdesc_size;
+	area_size += hdesc_size;
+
+	err = ssdfs_resize_hash_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize hash table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		return err;
+	}
+
+	threshold = area_offset + area_size;
+	area_offset = node->lookup_tbl_area.offset;
+
+	if (threshold != area_offset) {
+		SSDFS_ERR("threshold %u != area_offset %u\n",
+			  threshold, area_offset);
+		return -ERANGE;
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		return err;
+	}
+
+	err = __ssdfs_insert_suffix(node, search, prefix_len);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert suffix: err %d\n",
+			  err);
+		return err;
+	}
+
+	err = ssdfs_hash_table_insert_descriptor(node, search,
+						 (u8)(str_len - prefix_len),
+						 SSDFS_NAME_SUFFIX);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert hash descriptor: err %d\n", err);
+		return err;
+	}
+
+	err = ssdfs_lookup2_table_inc_str_count(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to increase str_count: err %d\n",
+			  err);
+		return err;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+
+/*
+ * ssdfs_insert_suffix_into_left_range() - insert a name's suffix in left range
+ * @node: node object
+ * @search: search object
+ * @prefix_len: length of the prefix
+ *
+ * This method tries to insert a name's suffix in the left range.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EOPNOTSUPP - unable to insert the name's suffix.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+static
+int ssdfs_insert_suffix_into_left_range(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search,
+					u16 prefix_len)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name;
+	struct ssdfs_strings_range_descriptor *strings_range;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t str_len;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain valid name\n");
+		return -ERANGE;
+	}
+
+	if (!search->request.start.name) {
+		SSDFS_ERR("empty name pointer\n");
+		return -ERANGE;
+	}
+
+	str_len = search->request.start.name_len;
+
+	if (str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid str_len %zu\n", str_len);
+		return -ERANGE;
+	}
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	strings_range = &buf->place.name->strings_range;
+	ltbl2_item = &strings_range->desc;
+
+	prefix = &buf->place.name->prefix;
+	left_name = &buf->place.name->left_name;
+
+	switch (prefix->desc.type) {
+	case SSDFS_NAME_PREFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  prefix->desc.type);
+		return -ERANGE;
+	}
+
+	switch (left_name->desc.type) {
+	case SSDFS_NAME_SUFFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  left_name->desc.type);
+		return -ERANGE;
+	}
+
+	if (le16_to_cpu(ltbl2_item->hash_index) != prefix->index) {
+		SSDFS_ERR("corrupted search result: "
+			  "ltbl2_item->hash_index %u, "
+			  "prefix->index %u\n",
+			  le16_to_cpu(ltbl2_item->hash_index),
+			  prefix->index);
+		return -ERANGE;
+	}
+
+	if (prefix->index > left_name->index) {
+		SSDFS_ERR("corrupted search result: "
+			  "prefix->index %u, "
+			  "left_name->index %u\n",
+			  prefix->index, left_name->index);
+		return -ERANGE;
+	}
+
+	if (left_name->index >= (prefix->index + ltbl2_item->str_count)) {
+		SSDFS_ERR("corrupted search result: "
+			  "left_name->index %u, "
+			  "prefix->index %u, "
+			  "ltbl2_item->str_count %u\n",
+			  left_name->index, prefix->index,
+			  ltbl2_item->str_count);
+		return -ERANGE;
+	}
+
+	if (prefix_len > str_len) {
+		SSDFS_ERR("prefix_len %u > str_len %zu\n",
+			  prefix_len, str_len);
+		return -ERANGE;
+	}
+
+	if (prefix_len != prefix->desc.str_len) {
+		SSDFS_ERR("prefix_len %u != prefix->desc.str_len %u\n",
+			  prefix_len,
+			  prefix->desc.str_len);
+		return -ERANGE;
+	}
+
+	down_write(&node->header_lock);
+
+	err = ssdfs_insert_suffix(node, search, prefix_len);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert name's suffix: err %d\n",
+			  err);
+		if (atomic_read(&node->state) == SSDFS_BTREE_NODE_CORRUPTED)
+			goto finish_insert_left_suffix;
+		else
+			goto check_node_consistency;
+	}
+
+check_node_consistency:
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_insert_left_suffix;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+finish_insert_left_suffix:
+	up_write(&node->header_lock);
+
+	return err;
+}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+
+/*
+ * ssdfs_insert_suffix_into_right_range() - insert a suffix into right range
+ * @node: node object
+ * @search: search object
+ * @prefix_len: length of the prefix
+ *
+ * This method tries to insert a name's suffix into the right range.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EOPNOTSUPP - unable to insert the name's suffix.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+static
+int ssdfs_insert_suffix_into_right_range(struct ssdfs_btree_node *node,
+					 struct ssdfs_btree_search *search,
+					 u16 prefix_len)
+{
+	struct ssdfs_string_descriptor *prefix, *left_name, *right_name;
+	struct ssdfs_strings_range_descriptor *strings_range;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t str_len;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (!(search->request.flags & SSDFS_BTREE_SEARCH_HAS_VALID_NAME)) {
+		SSDFS_ERR("request doesn't contain valid name\n");
+		return -ERANGE;
+	}
+
+	if (!search->request.start.name) {
+		SSDFS_ERR("empty name pointer\n");
+		return -ERANGE;
+	}
+
+	str_len = search->request.start.name_len;
+
+	if (str_len > SSDFS_MAX_NAME_LEN) {
+		SSDFS_ERR("invalid str_len %zu\n", str_len);
+		return -ERANGE;
+	}
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected states */
+		break;
+
+	default:
+		SSDFS_ERR("invalid name state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid name buffer\n");
+		return -ERANGE;
+	}
+
+	strings_range = &buf->place.name->strings_range;
+	ltbl2_item = &strings_range->desc;
+
+	prefix = &buf->place.name->prefix;
+	left_name = &buf->place.name->left_name;
+	right_name = &buf->place.name->right_name;
+
+	switch (prefix->desc.type) {
+	case SSDFS_NAME_PREFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  prefix->desc.type);
+		return -ERANGE;
+	}
+
+	switch (left_name->desc.type) {
+	case SSDFS_NAME_SUFFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  left_name->desc.type);
+		return -ERANGE;
+	}
+
+	switch (right_name->desc.type) {
+	case SSDFS_NAME_SUFFIX:
+		/* expected type */
+		break;
+
+	default:
+		SSDFS_ERR("invalid type %#x\n",
+			  right_name->desc.type);
+		return -ERANGE;
+	}
+
+	if (le16_to_cpu(ltbl2_item->hash_index) != prefix->index) {
+		SSDFS_ERR("corrupted search result: "
+			  "ltbl2_item->hash_index %u, "
+			  "prefix->index %u\n",
+			  le16_to_cpu(ltbl2_item->hash_index),
+			  prefix->index);
+		return -ERANGE;
+	}
+
+	if (prefix->index > left_name->index) {
+		SSDFS_ERR("corrupted search result: "
+			  "prefix->index %u, "
+			  "left_name->index %u\n",
+			  prefix->index, left_name->index);
+		return -ERANGE;
+	}
+
+	if (left_name->index > right_name->index) {
+		SSDFS_ERR("corrupted search result: "
+			  "left_name->index %u, "
+			  "right_name->index %u\n",
+			  left_name->index, right_name->index);
+		return -ERANGE;
+	}
+
+	if (left_name->index >= (prefix->index + ltbl2_item->str_count)) {
+		SSDFS_ERR("corrupted search result: "
+			  "left_name->index %u, "
+			  "prefix->index %u, "
+			  "ltbl2_item->str_count %u\n",
+			  left_name->index, prefix->index,
+			  ltbl2_item->str_count);
+		return -ERANGE;
+	}
+
+	if (right_name->index >= (prefix->index + ltbl2_item->str_count)) {
+		SSDFS_ERR("corrupted search result: "
+			  "right_name->index %u, "
+			  "prefix->index %u, "
+			  "ltbl2_item->str_count %u\n",
+			  right_name->index, prefix->index,
+			  ltbl2_item->str_count);
+		return -ERANGE;
+	}
+
+	if (prefix_len > str_len) {
+		SSDFS_ERR("prefix_len %u > str_len %zu\n",
+			  prefix_len, str_len);
+		return -ERANGE;
+	}
+
+	if (prefix_len != prefix->desc.str_len) {
+		SSDFS_ERR("prefix_len %u != prefix->desc.str_len %u\n",
+			  prefix_len,
+			  prefix->desc.str_len);
+		return -ERANGE;
+	}
+
+	down_write(&node->header_lock);
+
+	err = ssdfs_insert_suffix(node, search, prefix_len);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert name's suffix: err %d\n",
+			  err);
+		if (atomic_read(&node->state) == SSDFS_BTREE_NODE_CORRUPTED)
+			goto finish_insert_right_suffix;
+		else
+			goto check_node_consistency;
+	}
+
+check_node_consistency:
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_insert_right_suffix;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+finish_insert_right_suffix:
+	up_write(&node->header_lock);
+
+	return err;
+}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+
+/*
+ * ssdfs_correct_search_result_for_full_name() - correct search result
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to correct a search result for the case
+ * of full name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_correct_search_result_for_full_name(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	struct ssdfs_string_descriptor *left_name, *right_name;
+	struct ssdfs_strings_range_descriptor *strings_range;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	union ssdfs_shdict_search_key key = {0};
+	struct ssdfs_btree_search_buffer *buf;
+	u32 index;
+	u64 hash;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	buf = &search->result.name_buf;
+	left_name = &buf->place.name->left_name;
+	right_name = &buf->place.name->right_name;
+	strings_range = &buf->place.name->strings_range;
+	ltbl2_item = &strings_range->desc;
+
+	switch (left_name->desc.type) {
+	case SSDFS_NAME_SUFFIX:
+		/* continue logic */
+		break;
+
+	default:
+		/* nothing should be done */
+		return 0;
+	}
+
+	index = le16_to_cpu(ltbl2_item->hash_index);
+	index += ltbl2_item->str_count - 1;
+
+	err = ssdfs_get_hash_table_search_key(node, index, &key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash item: "
+			  "node_id %u, index %u, err %d\n",
+			  node->node_id, index, err);
+		return err;
+	}
+
+	/* simulate presence of name with lesser hash */
+	hash = search->request.start.hash - 1;
+
+	left_name->index = index;
+	ssdfs_memcpy(&left_name->desc,
+		     0, sizeof(struct ssdfs_shdict_htbl_item),
+		     &key,
+		     0, sizeof(union ssdfs_shdict_search_key),
+		     sizeof(struct ssdfs_shdict_htbl_item));
+	left_name->desc.hash = cpu_to_le64(hash);
+
+	right_name->index = index;
+	ssdfs_memcpy(&right_name->desc,
+		     0, sizeof(struct ssdfs_shdict_htbl_item),
+		     &key,
+		     0, sizeof(union ssdfs_shdict_search_key),
+		     sizeof(struct ssdfs_shdict_htbl_item));
+	right_name->desc.hash = cpu_to_le64(hash);
+
+	return 0;
+}
+
+/*
+ * __ssdfs_shared_dict_btree_node_insert_item() - insert an item into the node
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to insert an item into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EOPNOTSUPP - unable to insert the name's suffix.
+ * %-ENOSPC     - node hasn't enough free space.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int __ssdfs_shared_dict_btree_node_insert_item(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area items_area;
+	struct ssdfs_btree_node_index_area lookup_tbl_area;
+	struct ssdfs_btree_node_index_area hash_tbl_area;
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	u16 index_area_size;
+	u16 str_area_offset;
+	u16 str_area_bytes;
+	u16 hash_tbl_offset;
+	u16 hash_tbl_size;
+	u16 lookup_tbl2_offset;
+	u16 lookup_tbl2_size;
+	u16 left_len, right_len;
+	u64 start_hash = U64_MAX;
+	u64 old_hash;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	down_write(&node->full_lock);
+
+	down_read(&node->header_lock);
+	ssdfs_memcpy(&items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     &node->items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     sizeof(struct ssdfs_btree_node_items_area));
+	ssdfs_memcpy(&lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	ssdfs_memcpy(&hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	index_area_size = node->index_area.area_size;
+	old_hash = node->items_area.start_hash;
+	up_read(&node->header_lock);
+
+	err = ssdfs_check_items_area(node, &items_area);
+	if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't free space\n",
+			  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_insert_item;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("items area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG();
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_insert_item;
+	}
+
+	err = ssdfs_check_lookup2_table_area(node, &lookup_tbl_area);
+	if (unlikely(err)) {
+		SSDFS_ERR("lookup2 table area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG();
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_insert_item;
+	}
+
+	down_read(&node->header_lock);
+	err = ssdfs_check_hash_table_area(node, &hash_tbl_area);
+	up_read(&node->header_lock);
+
+	if (unlikely(err)) {
+		SSDFS_ERR("hash table area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG();
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_insert_item;
+	}
+
+	str_area_offset = items_area.offset;
+	str_area_bytes = items_area.area_size;
+	hash_tbl_offset = hash_tbl_area.offset;
+	hash_tbl_size = hash_tbl_area.area_size;
+	lookup_tbl2_offset = lookup_tbl_area.offset;
+	lookup_tbl2_size = lookup_tbl_area.area_size;
+
+	if (str_area_offset != (hdr_size + index_area_size)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted strings area: "
+			  "str_area_offset %u, hdr_size %zu, "
+			  "index_area_size %u\n",
+			  str_area_offset,
+			  hdr_size,
+			  index_area_size);
+		goto finish_insert_item;
+	}
+
+	if (hash_tbl_offset != (str_area_offset + str_area_bytes)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted hash table: "
+			  "hash_tbl_offset %u, str_area_offset %u, "
+			  "str_area_bytes %u\n",
+			  hash_tbl_offset,
+			  str_area_offset,
+			  str_area_bytes);
+		goto finish_insert_item;
+	}
+
+	if (lookup_tbl2_offset != (hash_tbl_offset + hash_tbl_size)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted lookup table: "
+			  "lookup_tbl2_offset %u, hash_tbl_offset %u, "
+			  "hash_tbl_size %u\n",
+			  lookup_tbl2_offset,
+			  hash_tbl_offset,
+			  hash_tbl_size);
+		goto finish_insert_item;
+	}
+
+	if (items_area.items_count == 0) {
+		err = ssdfs_add_full_name(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to add the full name: "
+				  "node_id %u, err %d\n",
+				  node->node_id, err);
+			goto finish_insert_item;
+		}
+	} else {
+		err = ssdfs_extract_intersection_with_left_name(node,
+								search,
+								&left_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: "
+				  "err %d\n", err);
+			goto finish_insert_item;
+		}
+
+		err = ssdfs_extract_intersection_with_right_name(node,
+								search,
+								&right_len);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to extract intersection: "
+				  "err %d\n", err);
+			goto finish_insert_item;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("left_len %u, right_len %u\n",
+			  left_len, right_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+#ifdef CONFIG_SSDFS_LONG_NAME_DEDUPLICATION
+		if (left_len < SSDFS_LOWER_PREFIX_THRESHOLD &&
+		    right_len < SSDFS_LOWER_PREFIX_THRESHOLD) {
+			err = ssdfs_correct_search_result_for_full_name(node,
+									search);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to correct search result: "
+					  "err %d\n", err);
+				goto finish_insert_item;
+			}
+
+			err = ssdfs_add_full_name(node, search);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to add the full name: "
+					  "node_id %u, err %d\n",
+					  node->node_id, err);
+				goto finish_insert_item;
+			}
+		} else if (left_len >= right_len) {
+			if (left_len > SSDFS_DEFAULT_PREFIX_LEN)
+				left_len = SSDFS_DEFAULT_PREFIX_LEN;
+
+			if (is_ssdfs_left_full_name(search)) {
+				err = ssdfs_create_prefix_for_left_name(node,
+								    search,
+								    left_len);
+				if (err == -EOPNOTSUPP) {
+					err = ssdfs_add_full_name(node, search);
+					if (unlikely(err)) {
+						SSDFS_ERR("fail to add name: "
+							  "node_id %u, "
+							  "err %d\n",
+							  node->node_id,
+							  err);
+					}
+
+					goto finish_insert_item;
+				} else if (unlikely(err)) {
+					SSDFS_ERR("fail to create prefix: "
+						  "len %u, err %d\n",
+						  left_len, err);
+					goto finish_insert_item;
+				}
+			}
+
+			err = ssdfs_insert_suffix_into_left_range(node,
+								  search,
+								  left_len);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to add suffix into range: "
+					  "err %d\n", err);
+				goto finish_insert_item;
+			}
+		} else {
+			if (right_len > SSDFS_DEFAULT_PREFIX_LEN)
+				right_len = SSDFS_DEFAULT_PREFIX_LEN;
+
+			if (is_ssdfs_right_full_name(search)) {
+				err = ssdfs_create_prefix_for_right_name(node,
+								    search,
+								    right_len);
+				if (err == -EOPNOTSUPP) {
+					err = ssdfs_add_full_name(node, search);
+					if (unlikely(err)) {
+						SSDFS_ERR("fail to add name: "
+							  "node_id %u, "
+							  "err %d\n",
+							  node->node_id,
+							  err);
+					}
+
+					goto finish_insert_item;
+				} else if (unlikely(err)) {
+					SSDFS_ERR("fail to create prefix: "
+						  "len %u, err %d\n",
+						  right_len, err);
+					goto finish_insert_item;
+				}
+			}
+
+			err = ssdfs_insert_suffix_into_right_range(node,
+								   search,
+								   right_len);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to add suffix into range: "
+					  "err %d\n", err);
+				goto finish_insert_item;
+			}
+		}
+#else
+		err = ssdfs_correct_search_result_for_full_name(node,
+								search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to correct search result: "
+				  "err %d\n", err);
+			goto finish_insert_item;
+		}
+
+		err = ssdfs_add_full_name(node, search);
+		if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("unable to add the full name: "
+				  "node_id %u, err %d\n",
+				  node->node_id, err);
+#endif /* CONFIG_SSDFS_DEBUG */
+			goto finish_insert_item;
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to add the full name: "
+				  "node_id %u, err %d\n",
+				  node->node_id, err);
+			goto finish_insert_item;
+		}
+#endif /* CONFIG_SSDFS_LONG_NAME_DEDUPLICATION */
+	}
+
+	down_read(&node->header_lock);
+	start_hash = node->items_area.start_hash;
+	up_read(&node->header_lock);
+
+finish_insert_item:
+	up_write(&node->full_lock);
+
+	if (unlikely(err))
+		return err;
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_HYBRID_NODE:
+		if (items_area.items_count == 0) {
+			struct ssdfs_btree_index_key key;
+
+			spin_lock(&node->descriptor_lock);
+			ssdfs_memcpy(&key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			spin_unlock(&node->descriptor_lock);
+
+			key.index.hash = cpu_to_le64(start_hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("node_id %u, node_type %#x, "
+				  "node_height %u, hash %llx\n",
+				  le32_to_cpu(key.node_id),
+				  key.node_type,
+				  key.height,
+				  le64_to_cpu(key.index.hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			err = ssdfs_btree_node_add_index(node, &key);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to add index: err %d\n", err);
+				return err;
+			}
+		} else if (old_hash != start_hash) {
+			struct ssdfs_btree_index_key old_key, new_key;
+
+			spin_lock(&node->descriptor_lock);
+			ssdfs_memcpy(&old_key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			ssdfs_memcpy(&new_key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			spin_unlock(&node->descriptor_lock);
+
+			old_key.index.hash = cpu_to_le64(old_hash);
+			new_key.index.hash = cpu_to_le64(start_hash);
+
+			err = ssdfs_btree_node_change_index(node,
+							&old_key, &new_key);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to change index: err %d\n",
+					  err);
+				return err;
+			}
+		}
+		break;
+
+	default:
+		/* do nothing */
+		break;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_check_shdict_btree_node_consistency(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_insert_item() - insert item in the node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert an item in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't free space.
+ * %-ENOMEM     - fail to allocate memory.
+ */
+static
+int ssdfs_shared_dict_btree_node_insert_item(struct ssdfs_btree_node *node,
+					     struct ssdfs_btree_search *search)
+{
+	int state;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid result's state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	if (search->result.err == -ENODATA) {
+		search->result.err = 0;
+		/*
+		 * Node doesn't contain an item.
+		 */
+	} else if (search->result.err) {
+		SSDFS_WARN("invalid search result: err %d\n",
+			   search->result.err);
+		return search->result.err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(search->result.count != 1);
+	BUG_ON(!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE));
+	BUG_ON(!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_NAME));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	state = atomic_read(&node->items_area.state);
+	if (state != SSDFS_BTREE_NODE_ITEMS_AREA_EXIST) {
+		SSDFS_ERR("invalid area state %#x\n",
+			  state);
+		return -ERANGE;
+	}
+
+	err = __ssdfs_shared_dict_btree_node_insert_item(node, search);
+	if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to insert item: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return err;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to insert item: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_check_shdict_btree_node_consistency(node);
+	ssdfs_debug_btree_node_object(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * __ssdfs_shared_dict_btree_node_insert_range() - insert a range into the node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert a range of items into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't free space.
+ * %-ENOMEM     - fail to allocate memory.
+ */
+static
+int __ssdfs_shared_dict_btree_node_insert_range(struct ssdfs_btree_node *node,
+						struct ssdfs_btree_search *search)
+{
+	struct ssdfs_name_string *cur_name;
+	struct ssdfs_name_string_range *name_range = NULL;
+	struct ssdfs_btree_search_buffer *buf;
+	u32 request_flags;
+	int state;
+	u32 index;
+	u16 items_count;
+	u64 start_hash;
+	u64 end_hash;
+	int i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search->result.state != SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND) {
+		SSDFS_ERR("invalid result's state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	if (search->result.err == -ENODATA) {
+		search->result.err = 0;
+		/*
+		 * Node doesn't contain an item.
+		 */
+	} else if (search->result.err) {
+		SSDFS_WARN("invalid search result: err %d\n",
+			   search->result.err);
+		return search->result.err;
+	}
+
+	state = atomic_read(&node->items_area.state);
+	if (state != SSDFS_BTREE_NODE_ITEMS_AREA_EXIST) {
+		SSDFS_ERR("invalid area state %#x\n",
+			  state);
+		return -ERANGE;
+	}
+
+	switch (search->result.name_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		if (search->result.name_buf.items_count != 1) {
+			SSDFS_ERR("inconsistent search result: "
+				  "names_in_buffer %u\n",
+				  search->result.name_buf.items_count);
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		if (search->result.name_buf.items_count < 1) {
+			SSDFS_ERR("inconsistent search result: "
+				  "names_in_buffer %u\n",
+				  search->result.name_buf.items_count);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid search result state %#x\n",
+			  search->result.name_buf.state);
+		return -ERANGE;
+	}
+
+
+	name_range = search->result.range_buf.place.name_range;
+	buf = &name_range->hash_table.buf;
+
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	start_hash = le64_to_cpu(buf->place.htbl_items[0].hash);
+	end_hash = le64_to_cpu(buf->place.htbl_items[items_count - 1].hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_hash %#llx, end_hash %#llx, items_count %u\n",
+		  start_hash, end_hash, items_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	buf = &search->result.name_buf;
+
+	if (!buf->place.name) {
+		SSDFS_ERR("invalid buffer pointer\n");
+		return -ERANGE;
+	}
+
+	request_flags = search->request.flags;
+
+	if (search->request.count != buf->items_count) {
+		if (request_flags & SSDFS_BTREE_SEARCH_HAS_VALID_COUNT) {
+			SSDFS_ERR("count %u != names_in_buffer %u\n",
+				  search->request.count,
+				  buf->items_count);
+			return -ERANGE;
+		} else {
+			search->request.count = buf->items_count;
+			search->request.flags |=
+				SSDFS_BTREE_SEARCH_HAS_VALID_COUNT;
+		}
+	}
+
+	index = buf->items_count - 1;
+	cur_name = &buf->place.name[index];
+	search->request.end.name = cur_name->str;
+	search->request.end.name_len = cur_name->len;
+	search->request.end.hash = cur_name->hash;
+
+	for (i = 0; i < buf->items_count; i++) {
+		cur_name = &buf->place.name[i];
+
+		search->request.start.name = cur_name->str;
+		search->request.start.name_len = cur_name->len;
+		search->request.start.hash = cur_name->hash;
+
+		search->request.flags |=
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE;
+		search->request.flags |=
+			SSDFS_BTREE_SEARCH_HAS_VALID_NAME;
+		search->request.flags |=
+			SSDFS_BTREE_SEARCH_HAS_VALID_COUNT;
+
+		err = __ssdfs_shared_dict_btree_node_insert_item(node, search);
+		if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("unable to insert item: "
+				  "node_id %u, err %d\n",
+				  node->node_id, err);
+#endif /* CONFIG_SSDFS_DEBUG */
+			return err;
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to insert item: "
+				  "node_id %u, index %d, err %d\n",
+				  node->node_id, i, err);
+			return err;
+		}
+
+		search->request.count--;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_check_shdict_btree_node_consistency(node);
+	ssdfs_debug_btree_node_object(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_check_node_areas() - check node's areas
+ * @node: pointer on node object
+ *
+ * This method tries to check that node's areas are not corrupted.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static inline
+int ssdfs_shared_dict_check_node_areas(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree_node_items_area items_area;
+	struct ssdfs_btree_node_index_area lookup_tbl_area;
+	struct ssdfs_btree_node_index_area hash_tbl_area;
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	u16 index_area_size;
+	u16 str_area_offset;
+	u16 str_area_bytes;
+	u16 hash_tbl_offset;
+	u16 hash_tbl_size;
+	u16 lookup_tbl2_offset;
+	u16 lookup_tbl2_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_read(&node->header_lock);
+	index_area_size = node->index_area.area_size;
+	ssdfs_memcpy(&items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     &node->items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     sizeof(struct ssdfs_btree_node_items_area));
+	ssdfs_memcpy(&lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	ssdfs_memcpy(&hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	up_read(&node->header_lock);
+
+	err = ssdfs_check_items_area(node, &items_area);
+	if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't free space\n",
+			  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+		err = 0;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("items area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	err = ssdfs_check_lookup2_table_area(node, &lookup_tbl_area);
+	if (unlikely(err)) {
+		SSDFS_ERR("lookup2 table area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	down_read(&node->header_lock);
+	err = ssdfs_check_hash_table_area(node, &hash_tbl_area);
+	up_read(&node->header_lock);
+
+	if (unlikely(err)) {
+		SSDFS_ERR("hash table area is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		return err;
+	}
+
+	str_area_offset = items_area.offset;
+	str_area_bytes = items_area.area_size;
+	hash_tbl_offset = hash_tbl_area.offset;
+	hash_tbl_size = hash_tbl_area.area_size;
+	lookup_tbl2_offset = lookup_tbl_area.offset;
+	lookup_tbl2_size = lookup_tbl_area.area_size;
+
+	if (str_area_offset != (hdr_size + index_area_size)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted strings area: "
+			  "str_area_offset %u, hdr_size %zu, "
+			  "index_area_size %u\n",
+			  str_area_offset,
+			  hdr_size,
+			  index_area_size);
+		return err;
+	}
+
+	if (hash_tbl_offset != (str_area_offset + str_area_bytes)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted hash table: "
+			  "hash_tbl_offset %u, str_area_offset %u, "
+			  "str_area_bytes %u\n",
+			  hash_tbl_offset,
+			  str_area_offset,
+			  str_area_bytes);
+		return err;
+	}
+
+	if (lookup_tbl2_offset != (hash_tbl_offset + hash_tbl_size)) {
+		err = -EIO;
+		SSDFS_ERR("corrupted lookup table: "
+			  "lookup_tbl2_offset %u, hash_tbl_offset %u, "
+			  "hash_tbl_size %u\n",
+			  lookup_tbl2_offset,
+			  hash_tbl_offset,
+			  hash_tbl_size);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_resize_node_areas() - resize node's areas
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to resize the node's areas with the goal of
+ * preparing the insert of items range.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static inline
+int ssdfs_shared_dict_resize_node_areas(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_search_buffer *buf;
+	struct ssdfs_name_string_range *name_range = NULL;
+	u16 str_area_bytes;
+	u16 hash_tbl_size;
+	u16 lookup_tbl2_size;
+	u64 requested_size;
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 threshold;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	buf = &search->result.range_buf;
+	name_range = buf->place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!name_range);
+	BUG_ON(name_range->strings.buf.state !=
+			SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	BUG_ON(name_range->strings.buf.size == 0);
+	BUG_ON(name_range->hash_table.buf.state !=
+			SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	BUG_ON(name_range->hash_table.buf.size == 0);
+	BUG_ON(name_range->lookup2_table.buf.state !=
+			SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	BUG_ON(name_range->lookup2_table.buf.size == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	str_area_bytes = name_range->strings.buf.size;
+	hash_tbl_size = name_range->hash_table.buf.size;
+	lookup_tbl2_size = name_range->lookup2_table.buf.size;
+
+	requested_size = str_area_bytes + hash_tbl_size + lookup_tbl2_size;
+
+	if (!is_free_space_enough(node, requested_size)) {
+		err = -ENOSPC;
+		node->items_area.items_capacity = node->items_area.items_count;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node %u hasn't enough free space: "
+			  "requested_size %llu\n",
+			  node->node_id, requested_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return err;
+	}
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+	if (free_space < requested_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: free_space %u\n",
+			  free_space);
+		return err;
+	}
+
+	if (area_size < free_space) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted items area: "
+			  "area_size %u, free_space %u\n",
+			  area_size, free_space);
+		return err;
+	}
+
+	area_size -= lookup_tbl2_size + hash_tbl_size;
+
+	err = ssdfs_resize_string_area(node, area_offset, area_size);
+	if (err == -ENOSPC) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return err;
+	} else if (unlikely(err)) {
+		SSDFS_ERR("fail to shrink the string area: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		return err;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->hash_tbl_area.offset;
+	area_size = node->hash_tbl_area.area_size;
+
+	if (area_offset <= (lookup_tbl2_size + hash_tbl_size)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		return err;
+	}
+
+	if (threshold != (area_offset - (lookup_tbl2_size + hash_tbl_size))) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		return err;
+	}
+
+	area_offset -= lookup_tbl2_size + hash_tbl_size;
+	area_size += hash_tbl_size;
+
+	err = ssdfs_resize_hash_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize hash table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		return err;
+	}
+
+	threshold = area_offset + area_size;
+
+	area_offset = node->lookup_tbl_area.offset;
+	area_size = node->lookup_tbl_area.area_size;
+
+	if (area_offset <= lookup_tbl2_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "area_offset %u\n",
+			  area_offset);
+		return err;
+	}
+
+	if (threshold != (area_offset - lookup_tbl2_size)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("corrupted area: "
+			  "threshold %u, area_offset %u\n",
+			  threshold, area_offset);
+		return err;
+	}
+
+	area_offset -= lookup_tbl2_size;
+	area_size += lookup_tbl2_size;
+
+	err = ssdfs_resize_lookup2_table(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize lookup2 table: "
+			  "area_offset %u, area_size %u, err %d\n",
+			  area_offset, area_size, err);
+		return err;
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_insert_strings_blob() - insert strings blob
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert the strings blob into
+ * the strings area of node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_insert_strings_blob(struct ssdfs_btree_node *node,
+			      struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_search_buffer *buf;
+	struct ssdfs_name_string_range *name_range;
+	u32 area_size;
+	u32 free_space;
+	u32 items_count;
+	u32 items_capacity;
+	u8 min_item_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+	items_count = node->items_area.items_count;
+	min_item_size = node->items_area.min_item_size;
+
+	if (min_item_size != SSDFS_DENTRY_INLINE_NAME_MAX_LEN) {
+		SSDFS_ERR("invalid min_item_size %u\n",
+			  min_item_size);
+		return -ERANGE;
+	}
+
+	if (free_space > area_size) {
+		SSDFS_ERR("free_space %u > area_size %u\n",
+			  free_space, area_size);
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash range\n");
+		return -ERANGE;
+	}
+
+	switch (search->result.range_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid range state %#x\n",
+			  search->result.range_buf.state);
+		return -ERANGE;
+	}
+
+	buf = &search->result.range_buf;
+	name_range = buf->place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (name_range->strings.buf.state) {
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected state */
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range->strings.buf.place.ptr);
+		BUG_ON(name_range->strings.buf.size == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+		break;
+
+	default:
+		SSDFS_ERR("invalid buffer state %#x\n",
+			  name_range->strings.buf.state);
+		return -ERANGE;
+	}
+
+	if (name_range->strings.buf.size > free_space) {
+		SSDFS_ERR("buf_size %zu > free_space %u\n",
+			  name_range->strings.buf.size,
+			  free_space);
+		return -ENOSPC;
+	}
+
+	switch (name_range->hash_table.buf.state) {
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected state */
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range->hash_table.buf.place.htbl_items);
+		BUG_ON(name_range->hash_table.buf.size == 0);
+		BUG_ON(name_range->hash_table.buf.items_count == 0);
+		BUG_ON(name_range->hash_table.buf.items_count >= U32_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+		break;
+
+	default:
+		SSDFS_ERR("invalid buffer state %#x\n",
+			  name_range->hash_table.buf.state);
+		return -ERANGE;
+	}
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		err = __ssdfs_insert_strings_blob(node,
+					name_range->strings.buf.place.ptr,
+					name_range->strings.buf.size,
+					search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert strings blob: "
+				  "buf_size %zu, err %d\n",
+				  name_range->strings.buf.size, err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected result state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	node->items_area.items_count += name_range->hash_table.buf.items_count;
+	node->items_area.free_space -= name_range->strings.buf.size;
+
+	node->items_area.item_size = ssdfs_define_item_size(node);
+
+	items_capacity = ssdfs_define_items_capacity(node);
+	if (items_capacity >= U16_MAX) {
+		SSDFS_ERR("invalid items_capacity %u\n",
+			  items_capacity);
+		return -ERANGE;
+	}
+
+	node->items_area.items_capacity = (u16)items_capacity;
+
+	buf = &name_range->hash_table.buf;
+
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * __ssdfs_hash_table_insert_range() - insert hash items range
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ * @index: index for inserting
+ * @name_range: pointer on name range [in]
+ *
+ * This method tries to insert the range of items
+ * into hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int __ssdfs_hash_table_insert_range(struct ssdfs_btree_node *node,
+				    struct ssdfs_btree_search *search,
+				    u16 index,
+				    struct ssdfs_name_string_range *name_range)
+{
+	struct ssdfs_shdict_htbl_item cur_desc;
+	struct ssdfs_shdict_htbl_item *range_desc;
+	struct ssdfs_btree_search_buffer *buf;
+	u32 items_count;
+	u16 items_capacity;
+	u8 item_size;
+	u32 range_len;
+	u16 shift;
+	u32 str_offset;
+	u64 start_hash, end_hash;
+	u16 i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !name_range || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+	BUG_ON(!name_range->hash_table.buf.place.htbl_items);
+	BUG_ON(name_range->hash_table.buf.size == 0);
+	BUG_ON(name_range->hash_table.buf.items_count == 0);
+	BUG_ON(name_range->hash_table.buf.items_count >= U32_MAX);
+
+	SSDFS_DBG("node_id %u, index %u\n",
+		  node->node_id, index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	range_len = name_range->hash_table.buf.items_count;
+	err = ssdfs_correct_lookup2_table(node, index, range_len);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to correct lookup2 table: "
+			  "index %u, range_len %u, err %d\n",
+			  index, range_len, err);
+		return err;
+	}
+
+	items_count = node->hash_tbl_area.index_count;
+	items_capacity = node->hash_tbl_area.index_capacity;
+	item_size = node->hash_tbl_area.index_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("HASH_TBL: items_count %u, items_capacity %u, item_size %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  items_count, items_capacity, item_size,
+		  node->hash_tbl_area.start_hash,
+		  node->hash_tbl_area.end_hash);
+	buf = &name_range->hash_table.buf;
+	SSDFS_DBG("NAME_RANGE: items_count %u, start_hash %#llx, "
+		  "end_hash %#llx\n",
+		  buf->items_count,
+		  le64_to_cpu(buf->place.htbl_items[0].hash),
+		  le64_to_cpu(buf->place.htbl_items[buf->items_count - 1].hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (item_size != sizeof(struct ssdfs_shdict_htbl_item)) {
+		SSDFS_ERR("corrupted area: "
+			  "item_size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	if (items_count > items_capacity) {
+		SSDFS_ERR("items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	} else if ((items_count + range_len) > items_capacity) {
+		SSDFS_ERR("NO SPACE: items_count %u, "
+			  "range_len %u, items_capacity %u\n",
+			  items_count, range_len, items_capacity);
+		return -ENOSPC;
+	}
+
+	if (index > items_count) {
+		SSDFS_ERR("index %u > items_count %u\n",
+			  index, items_count);
+		return -ERANGE;
+	}
+
+	if (index < items_count) {
+		u16 selected_items = items_count - index;
+		shift = name_range->hash_table.buf.items_count;
+
+		err = ssdfs_shift_range_right2(node, &node->hash_tbl_area,
+						item_size,
+						index, selected_items,
+						shift);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift the range: "
+				  "index %u, selected_items %u, "
+				  "shift %u, err %d\n",
+				  index, selected_items, shift, err);
+			return err;
+		}
+	}
+
+	if (index > 0) {
+		i = index - 1;
+
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		str_offset = le16_to_cpu(cur_desc.str_offset);
+		str_offset += cur_desc.str_len;
+	} else
+		str_offset = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("node_id %u, index %u, str_offset %u\n",
+		  node->node_id, index, str_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	range_len = name_range->hash_table.buf.items_count;
+	for (i = 0; i < range_len; i++) {
+		u16 cur_index = index + i;
+
+		range_desc = &name_range->hash_table.buf.place.htbl_items[i];
+		range_desc->str_offset = cpu_to_le16(str_offset);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node_id %u, cur_index %u, str_offset %u\n",
+			  node->node_id, cur_index, str_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+						cur_index, range_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set hash descriptor: "
+				  "index %u, err %d\n",
+				  cur_index, err);
+			return err;
+		}
+
+		if (node->hash_tbl_area.index_count == 0) {
+			buf = &name_range->hash_table.buf;
+			start_hash = le64_to_cpu(buf->place.htbl_items[0].hash);
+			node->hash_tbl_area.start_hash = start_hash;
+			node->hash_tbl_area.end_hash = start_hash;
+		}
+
+		str_offset += range_desc->str_len;
+		node->hash_tbl_area.index_count++;
+	}
+
+	range_len = name_range->hash_table.buf.items_count;
+	items_count = node->hash_tbl_area.index_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, items_capacity %u, item_size %u\n",
+		  items_count, items_capacity, item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	i = index + range_len;
+
+	if (i >= items_count)
+		goto mark_hash_table_dirty;
+
+	for (; i < items_count; i++) {
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("index %u, old str_offset %u, "
+			  "new str_offset %u\n",
+			  i, le16_to_cpu(cur_desc.str_offset),
+			  str_offset);
+
+		if (str_offset >= U16_MAX) {
+			SSDFS_ERR("invalid str_offset %u\n",
+				  str_offset);
+			return -ERANGE;
+		}
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		cur_desc.str_offset = cpu_to_le16((u16)str_offset);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node_id %u, cur_index %u, str_offset %u\n",
+			  node->node_id, i, str_offset);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_set_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		str_offset += cur_desc.str_len;
+	}
+
+mark_hash_table_dirty:
+	buf = &name_range->hash_table.buf;
+
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	start_hash = le64_to_cpu(buf->place.htbl_items[0].hash);
+	end_hash = le64_to_cpu(buf->place.htbl_items[items_count - 1].hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_hash %#llx, end_hash %#llx, items_count %u, "
+		  "HASH TBL: start_hash %#llx, end_hash %#llx\n",
+		  start_hash, end_hash, items_count,
+		  node->hash_tbl_area.start_hash,
+		  node->hash_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (node->hash_tbl_area.start_hash > start_hash)
+		node->hash_tbl_area.start_hash = start_hash;
+
+	if (node->hash_tbl_area.end_hash < end_hash)
+		node->hash_tbl_area.end_hash = end_hash;
+
+	ssdfs_mark_hash_table_dirty(node);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search->result.range_buf.place.name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	search->result.range_buf.place.name_range->placement.hash_index = index;
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_table_insert_range() - insert hash items range
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert the range of items
+ * into hash table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_hash_table_insert_range(struct ssdfs_btree_node *node,
+				  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_name_string_range *name_range;
+	u16 items_count;
+	u32 new_items_count;
+	u16 items_capacity;
+	u16 item_size;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n",
+		  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	switch (search->result.range_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid range state %#x\n",
+			  search->result.range_buf.state);
+		return -ERANGE;
+	}
+
+	name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (name_range->hash_table.buf.state) {
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected state */
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range->hash_table.buf.place.htbl_items);
+		BUG_ON(name_range->hash_table.buf.size == 0);
+		BUG_ON(name_range->hash_table.buf.items_count == 0);
+		BUG_ON(name_range->hash_table.buf.items_count >= U32_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+		break;
+
+	default:
+		SSDFS_ERR("invalid buffer state %#x\n",
+			  name_range->hash_table.buf.state);
+		return -ERANGE;
+	}
+
+	items_count = node->hash_tbl_area.index_count;
+	new_items_count = items_count + name_range->hash_table.buf.items_count;
+	items_capacity = node->hash_tbl_area.index_capacity;
+	item_size = node->hash_tbl_area.index_size;
+
+	if (items_count == items_capacity) {
+		SSDFS_ERR("no vacant items: "
+			  "items_count %u, items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ENOSPC;
+	} else if (items_count > items_capacity) {
+		SSDFS_ERR("items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	} else if (new_items_count > items_capacity) {
+		SSDFS_ERR("new_items_count %u > items_capacity %u\n",
+			  new_items_count, items_capacity);
+		return -ENOSPC;
+	}
+
+	if (item_size != sizeof(struct ssdfs_shdict_htbl_item)) {
+		SSDFS_ERR("invalid item size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		err = __ssdfs_hash_table_insert_range(node, search,
+						search->result.start_index,
+						name_range);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert descriptor: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("unexpected result state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_resolve_l2tbl_hash_collision() - resolve hash collision in lookup2 table
+ * @node: pointer on node object
+ * @desc: lookup2 descriptor for search
+ * @lookup2_index: pointer on index in lookup2 table [out]
+ *
+ * This method tries to correct the position in the case of
+ * hash collision in lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static inline
+int ssdfs_resolve_l2tbl_hash_collision(struct ssdfs_btree_node *node,
+					struct ssdfs_shdict_ltbl2_item *desc,
+					u16 *lookup2_index)
+{
+	union ssdfs_shdict_search_key *key;
+	union ssdfs_shdict_search_key cur_key;
+	u16 table_size;
+	int i;
+	int res;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !desc || !lookup2_index);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, hash_lo %#llx, lookup2_index %u\n",
+		  node->node_id, le64_to_cpu(desc->hash), *lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	key = SSDFS_SEARCH_KEY(desc);
+	table_size = node->lookup_tbl_area.index_count;
+
+	for (i = *lookup2_index; i < table_size; i++) {
+		err = ssdfs_get_lookup2_descriptor(node,
+						   &node->lookup_tbl_area,
+						   i,
+						   SSDFS_LTBL2_DESC(&cur_key));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get key: index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!is_ssdfs_hash64_valid(&cur_key));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		res = ssdfs_hash64_compare(key, &cur_key);
+		if (res > 0) {
+			SSDFS_ERR("corrupted lookup2 table: "
+				  "index %d\n", i);
+			return -ERANGE;
+		} else if (res < 0) {
+			*lookup2_index = i;
+			return 0;
+		}
+	}
+
+	*lookup2_index = i;
+	return 0;
+}
+
+/*
+ * ssdfs_find_lookup2_table_position() - find position in lookup2 table
+ * @node: pointer on node object
+ * @desc: lookup2 descriptor for search
+ * @lookup2_index: pointer on index in lookup2 table [out]
+ *
+ * This method tries to find a position in lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_find_lookup2_table_position(struct ssdfs_btree_node *node,
+				      struct ssdfs_shdict_ltbl2_item *desc,
+				      u16 *lookup2_index)
+{
+	union ssdfs_shdict_search_key *key;
+	union ssdfs_shdict_search_key lower_bound, upper_bound;
+	int index, lower_index, upper_index;
+	u16 table_size;
+	int res;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !desc || !lookup2_index);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, hash %#llx\n",
+		  node->node_id,
+		  le64_to_cpu(desc->hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	*lookup2_index = U16_MAX;
+	key = SSDFS_SEARCH_KEY(desc);
+	table_size = node->lookup_tbl_area.index_count;
+
+	if (table_size == 0) {
+		*lookup2_index = lower_index;
+		return 0;
+	}
+
+	lower_index = 0;
+	err = ssdfs_get_lookup2_descriptor(node,
+					   &node->lookup_tbl_area,
+					   lower_index,
+					   SSDFS_LTBL2_DESC(&lower_bound));
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get key: index %u, err %d\n",
+			  lower_index, err);
+		return err;
+	}
+
+	if (!is_ssdfs_hash64_valid(&lower_bound)) {
+		*lookup2_index = lower_index;
+		return 0;
+	}
+
+	res = ssdfs_hash64_compare(key, &lower_bound);
+	if (res < 0) {
+		*lookup2_index = lower_index;
+		return 0;
+	} else if (res == 0) {
+		*lookup2_index = lower_index;
+		goto resolve_hash_collision;
+	} else if (table_size == 1) {
+		*lookup2_index = table_size;
+		return 0;
+	}
+
+	lower_index++;
+
+	upper_index = table_size - 1;
+	err = ssdfs_get_lookup2_descriptor(node,
+					   &node->lookup_tbl_area,
+					   upper_index,
+					   SSDFS_LTBL2_DESC(&upper_bound));
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get key: index %u, err %d\n",
+			  upper_index, err);
+		return err;
+	}
+
+	if (!is_ssdfs_hash64_valid(&upper_bound)) {
+		/*
+		 * continue to search
+		 */
+	} else {
+		res = ssdfs_hash64_compare(&upper_bound, key);
+		if (res < 0) {
+			*lookup2_index = table_size;
+			return 0;
+		} else if (res == 0) {
+			*lookup2_index = upper_index;
+			goto resolve_hash_collision;
+		} else if (table_size == 2) {
+			*lookup2_index = upper_index;
+			return 0;
+		}
+	}
+
+	do {
+		int diff = upper_index - lower_index;
+
+		index = lower_index + (diff / 2);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("lower_index %d, upper_index %d, "
+			  "diff %d, index %d\n",
+			  lower_index, upper_index,
+			  diff, index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_get_lookup2_descriptor(node,
+						&node->lookup_tbl_area,
+						index,
+						SSDFS_LTBL2_DESC(&lower_bound));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get key: index %u, err %d\n",
+				  index, err);
+			return err;
+		}
+
+		err = ssdfs_get_lookup2_descriptor(node,
+						&node->lookup_tbl_area,
+						index + 1,
+						SSDFS_LTBL2_DESC(&upper_bound));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get key: index %u, err %d\n",
+				  index + 1, err);
+			return err;
+		}
+
+		if (!is_ssdfs_hash64_valid(&lower_bound)) {
+			upper_index = index;
+		} else {
+			res = ssdfs_hash64_compare(key, &lower_bound);
+			if (res < 0) {
+				upper_index = index;
+			} else if (res == 0) {
+				*lookup2_index = index;
+				goto resolve_hash_collision;
+			} else {
+				if (!is_ssdfs_hash64_valid(&upper_bound)) {
+					lower_index = index + 1;
+					upper_index = lower_index;
+				} else {
+					res = ssdfs_hash64_compare(key,
+								&upper_bound);
+					if (res < 0) {
+						lower_index = index + 1;
+						upper_index = lower_index;
+					} else if (res == 0) {
+						*lookup2_index = index + 1;
+						goto resolve_hash_collision;
+					} else {
+						lower_index = index + 1;
+					}
+				}
+			}
+		}
+	} while (lower_index < upper_index);
+
+	if (lower_index != upper_index) {
+		SSDFS_ERR("lower_index %d != upper_index %d\n",
+			  lower_index, upper_index);
+		return -ERANGE;
+	}
+
+	*lookup2_index = lower_index;
+	return 0;
+
+resolve_hash_collision:
+	return ssdfs_resolve_l2tbl_hash_collision(node, desc, lookup2_index);
+}
+
+/*
+ * __ssdfs_lookup2_table_insert_range() - insert lookup2 items range
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ * @name_range: pointer on name range [in]
+ *
+ * This method tries to insert the range of items
+ * into lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int __ssdfs_lookup2_table_insert_range(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_search *search,
+				struct ssdfs_name_string_range *name_range)
+{
+	struct ssdfs_shdict_ltbl2_item *desc;
+	u16 items_count;
+	u16 items_capacity;
+	u16 item_size;
+	u16 hash_index;
+	u16 min_hash_index;
+	u16 range_len;
+	u16 shift;
+	int i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !name_range || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+	BUG_ON(!name_range->lookup2_table.buf.place.ltbl2_items);
+	BUG_ON(name_range->lookup2_table.buf.size == 0);
+	BUG_ON(name_range->lookup2_table.buf.items_count == 0);
+	BUG_ON(name_range->lookup2_table.buf.items_count >= U32_MAX);
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	if (!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE)) {
+		SSDFS_ERR("request doesn't contain the hash\n");
+		return -ERANGE;
+	}
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+	item_size = node->lookup_tbl_area.index_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!search->result.range_buf.place.name_range);
+
+	SSDFS_DBG("items_count %u, items_capacity %u, "
+		  "index_size %u\n",
+		  items_count, items_capacity,
+		  item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	range_len = name_range->lookup2_table.buf.items_count;
+
+	if (items_count >= items_capacity) {
+		SSDFS_ERR("corrupted node: "
+			  "node_id %u, items_count %u, "
+			  "items_capacity %u\n",
+			  node->node_id, items_count,
+			  items_capacity);
+		return -ERANGE;
+	} else if ((items_count + range_len) > items_capacity) {
+		SSDFS_ERR("NO SPACE: node_id %u, items_count %u, "
+			  "range_len %u, items_capacity %u\n",
+			  node->node_id, items_count,
+			  range_len, items_capacity);
+		return -ENOSPC;
+	}
+
+	desc = &name_range->lookup2_table.buf.place.ltbl2_items[0];
+	min_hash_index = le16_to_cpu(desc->hash_index);
+
+	for (i = 1; i < range_len; i++) {
+		desc = &name_range->lookup2_table.buf.place.ltbl2_items[i];
+
+		hash_index = le16_to_cpu(desc->hash_index);
+
+		if (hash_index < min_hash_index)
+			min_hash_index = hash_index;
+	}
+
+	for (i = 0; i < range_len; i++) {
+		u16 lookup2_index;
+
+		desc = &name_range->lookup2_table.buf.place.ltbl2_items[i];
+
+		err = ssdfs_find_lookup2_table_position(node,
+							desc,
+							&lookup2_index);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to find lookup2 table position: "
+				  "err %d\n", err);
+			return err;
+		}
+
+		if (lookup2_index < items_count) {
+			u16 selected_items = items_count - lookup2_index;
+			shift = 1;
+
+			err = ssdfs_shift_range_right2(node,
+						&node->lookup_tbl_area,
+						item_size,
+						lookup2_index, selected_items,
+						shift);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to shift the range: "
+					  "index %u, selected_items %u, "
+					  "shift %u, err %d\n",
+					  lookup2_index, selected_items,
+					  shift, err);
+				return err;
+			}
+		}
+
+		hash_index = le16_to_cpu(desc->hash_index);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(hash_index < min_hash_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		hash_index -= min_hash_index;
+		hash_index += search->result.start_index;
+
+		desc->hash_index = cpu_to_le16(hash_index);
+
+		err = ssdfs_set_lookup2_descriptor(node, &node->lookup_tbl_area,
+						   lookup2_index, desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  lookup2_index, err);
+			return err;
+		}
+
+		node->lookup_tbl_area.index_count++;
+		items_count = node->lookup_tbl_area.index_count;
+
+		if (lookup2_index == 0) {
+			node->lookup_tbl_area.start_hash =
+						le64_to_cpu(desc->hash);
+		}
+
+		if ((lookup2_index + 1) == items_count) {
+			node->lookup_tbl_area.end_hash =
+						le64_to_cpu(desc->hash);
+		}
+
+		ssdfs_mark_lookup2_table_dirty(node);
+
+		name_range->placement.lookup2_index = lookup2_index;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_lookup2_table_insert_range() - insert lookup2 items range
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert the range of items
+ * into lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_lookup2_table_insert_range(struct ssdfs_btree_node *node,
+				     struct ssdfs_btree_search *search)
+{
+	struct ssdfs_name_string_range *name_range;
+	u16 items_count;
+	u32 new_items_count;
+	u16 items_capacity;
+	u16 item_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	switch (search->result.range_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid range state %#x\n",
+			  search->result.range_buf.state);
+		return -ERANGE;
+	}
+
+	name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (name_range->lookup2_table.buf.state) {
+	case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+		/* expected state */
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range->lookup2_table.buf.place.ltbl2_items);
+		BUG_ON(name_range->lookup2_table.buf.size == 0);
+		BUG_ON(name_range->lookup2_table.buf.items_count == 0);
+		BUG_ON(name_range->lookup2_table.buf.items_count >= U32_MAX);
+#endif /* CONFIG_SSDFS_DEBUG */
+		break;
+
+	default:
+		SSDFS_ERR("invalid buffer state %#x\n",
+			  name_range->lookup2_table.buf.state);
+		return -ERANGE;
+	}
+
+	items_count = node->lookup_tbl_area.index_count;
+	new_items_count = items_count +
+				name_range->lookup2_table.buf.items_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+	item_size = node->lookup_tbl_area.index_size;
+
+	if (items_count == items_capacity) {
+		SSDFS_ERR("no vacant items: "
+			  "items_count %u, items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ENOSPC;
+	} else if (items_count > items_capacity) {
+		SSDFS_ERR("items_count %u > items_capacity %u\n",
+			  items_count, items_capacity);
+		return -ERANGE;
+	} else if (new_items_count > items_capacity) {
+		SSDFS_ERR("new_items_count %u > items_capacity %u\n",
+			  new_items_count, items_capacity);
+		return -ENOSPC;
+	}
+
+	if (item_size != sizeof(struct ssdfs_shdict_ltbl2_item)) {
+		SSDFS_ERR("invalid item size %u\n",
+			  item_size);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, buf.items_count %u, new_items_count %u, "
+		  "items_capacity %u, item_size %u\n",
+		  items_count,
+		  name_range->lookup2_table.buf.items_count,
+		  new_items_count,
+		  items_capacity,
+		  item_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return __ssdfs_lookup2_table_insert_range(node, search, name_range);
+}
+
+/*
+ * ssdfs_rebuild_lookup1_table() - rebuild lookup1 table
+ * @node: pointer on node object
+ *
+ * This method tries to rebuild the lookup1 table
+ * on the basis of current state of lookup2 table.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_rebuild_lookup1_table(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_shdict_ltbl1_item *lookup1_tbl;
+	struct ssdfs_shdict_ltbl1_item ltbl1_desc;
+	union ssdfs_shdict_search_key ltbl2_desc;
+	size_t item_size = sizeof(struct ssdfs_shdict_ltbl1_item);
+	u16 ltbl1_items_count;
+	u16 ltbl2_items_count;
+	u16 ltbl2_items_capacity;
+	int ltbl1_index;
+	int ltbl2_index;
+	u16 range_len;
+#ifdef CONFIG_SSDFS_DEBUG
+	size_t ltbl1_bytes_count = item_size * SSDFS_SHDIC_LTBL1_SIZE;
+#endif /* CONFIG_SSDFS_DEBUG */
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n",
+		  node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	lookup1_tbl = node->raw.dict_header.lookup_table1;
+
+	ltbl1_items_count =
+		le16_to_cpu(node->raw.dict_header.lookup_table1_items);
+	if (ltbl1_items_count > SSDFS_SHDIC_LTBL1_SIZE) {
+		SSDFS_ERR("invalid lookup_table1_items %u\n",
+			  ltbl1_items_count);
+		return -ERANGE;
+	}
+
+	memset(lookup1_tbl, 0xFF,
+		sizeof(struct ssdfs_shdict_ltbl1_item) * SSDFS_SHDIC_LTBL1_SIZE);
+	node->raw.dict_header.lookup_table1_items = cpu_to_le16(0);
+
+	ltbl2_items_count = node->lookup_tbl_area.index_count;
+	ltbl2_items_capacity = node->lookup_tbl_area.index_capacity;
+
+	if (ltbl2_items_count == 0) {
+		SSDFS_ERR("empty lookup2 table\n");
+		return -ERANGE;
+	} else if (ltbl2_items_count > ltbl2_items_capacity) {
+		SSDFS_ERR("corrupted lookup2 table: "
+			  "items_count %u, items_capacity %u\n",
+			  ltbl2_items_count, ltbl2_items_capacity);
+		return -ERANGE;
+	}
+
+	ltbl1_items_count = 0;
+	ltbl1_index = 0;
+	ltbl2_index = 0;
+
+	while (ltbl2_index < ltbl2_items_count) {
+		u64 hash;
+
+		err = ssdfs_get_lookup2_descriptor(node,
+						&node->lookup_tbl_area,
+						ltbl2_index,
+						SSDFS_LTBL2_DESC(&ltbl2_desc));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get key: index %u, err %d\n",
+				  ltbl2_index, err);
+			return err;
+		}
+
+		if (!is_ssdfs_hash64_valid(&ltbl2_desc)) {
+			SSDFS_ERR("key is invalid: index %u\n",
+				  ltbl2_index);
+			return -ERANGE;
+		}
+
+		hash = le64_to_cpu(ltbl2_desc.hash);
+		ltbl1_desc.hash_lo = cpu_to_le32(SSDFS_HASH32_LO(hash));
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(ltbl2_index >= U16_MAX);
+		BUG_ON(ltbl2_index >= ltbl2_items_capacity);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ltbl1_desc.start_index = cpu_to_le16((u16)ltbl2_index);
+
+		range_len = ssdfs_lookup1_table_get_range_capacity(ltbl1_index);
+
+		if (range_len >= U16_MAX) {
+			SSDFS_ERR("invalid range len: ltbl1_index %d\n",
+				  ltbl1_index);
+			return -ERANGE;
+		}
+
+		range_len = min_t(u16, ltbl2_items_count - ltbl2_index,
+					range_len);
+
+		ltbl1_desc.range_len = cpu_to_le16(range_len);
+
+		ltbl1_items_count++;
+
+		if (ltbl1_items_count > SSDFS_SHDIC_LTBL1_SIZE) {
+			SSDFS_ERR("corrupted lookup1 table: "
+				  "items_count %u, items_capacity %u\n",
+				  ltbl1_items_count,
+				  SSDFS_SHDIC_LTBL1_SIZE);
+			return -ERANGE;
+		}
+
+		node->raw.dict_header.lookup_table1_items =
+					cpu_to_le16(ltbl1_items_count);
+
+		ssdfs_memcpy(&lookup1_tbl[ltbl1_index], 0, item_size,
+			     &ltbl1_desc, 0, item_size,
+			     item_size);
+
+		ltbl2_index = lookup1_tbl_threshold[ltbl1_index];
+		ltbl1_index++;
+	}
+
+	err = ssdfs_set_node_header_dirty(node,
+					  node->items_area.items_capacity);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to set header dirty: err %d\n",
+			  err);
+		return err;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("LOOKUP1 TABLE DUMP\n");
+	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+			     lookup1_tbl, ltbl1_bytes_count);
+	SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_name_range_insert() - insert a name range
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert a name range into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't free space.
+ * %-ENOMEM     - fail to allocate memory.
+ */
+static int
+ssdfs_shared_dict_btree_node_name_range_insert(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area items_area;
+	struct ssdfs_name_string_range *name_range = NULL;
+	struct ssdfs_btree_search_buffer *buf;
+	u64 start_hash = U64_MAX;
+	u64 end_hash;
+	u64 old_hash;
+	u16 items_count;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p, "
+		  "request.count %u, result.count %u\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child, search->request.count,
+		  search->result.count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+	case SSDFS_BTREE_SEARCH_OUT_OF_RANGE:
+		/* continue logic */
+		break;
+
+	default:
+		SSDFS_ERR("invalid result's state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	if (search->result.err == -ENODATA) {
+		search->result.err = 0;
+		/*
+		 * Node doesn't contain an item.
+		 */
+	} else if (search->result.err) {
+		SSDFS_WARN("invalid search result: err %d\n",
+			   search->result.err);
+		return search->result.err;
+	}
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	switch (search->result.range_buf.state) {
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid search result state %#x\n",
+			  search->result.range_buf.state);
+		return -ERANGE;
+	}
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		/*
+		 * Find could change the search->result.count.
+		 */
+		search->result.count = search->request.count;
+	} else {
+		SSDFS_ERR("invalid flags set: search->result.flags %#x\n",
+			  search->result.flags);
+		return -ERANGE;
+	}
+
+	name_range = search->result.range_buf.place.name_range;
+
+	if (!name_range) {
+		SSDFS_ERR("invalid buffer pointer\n");
+		return -ERANGE;
+	}
+
+	buf = &name_range->hash_table.buf;
+
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	start_hash = le64_to_cpu(buf->place.htbl_items[0].hash);
+	end_hash = le64_to_cpu(buf->place.htbl_items[items_count - 1].hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_hash %#llx, end_hash %#llx, items_count %u\n",
+		  start_hash, end_hash, items_count);
+
+	if (search->result.count != name_range->hash_table.buf.items_count) {
+		SSDFS_ERR("result.count %d != buf.items_count %u\n",
+			  search->result.count,
+			  name_range->hash_table.buf.items_count);
+		BUG();
+	}
+	BUG_ON(!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE));
+	BUG_ON(!(search->request.flags &
+			SSDFS_BTREE_SEARCH_HAS_VALID_COUNT));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_write(&node->full_lock);
+
+	err = ssdfs_shared_dict_check_node_areas(node);
+	if (unlikely(err)) {
+		SSDFS_ERR("node is corrupted: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		goto finish_insert_name_range;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(name_range->strings.buf.state !=
+			SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	BUG_ON(name_range->strings.buf.size == 0);
+	BUG_ON(name_range->hash_table.buf.state !=
+			SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	BUG_ON(name_range->hash_table.buf.size == 0);
+	BUG_ON(name_range->lookup2_table.buf.state !=
+			SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	BUG_ON(name_range->lookup2_table.buf.size == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	down_write(&node->header_lock);
+
+	ssdfs_memcpy(&items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     &node->items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     sizeof(struct ssdfs_btree_node_items_area));
+	old_hash = node->items_area.start_hash;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("BEFORE: items_count %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  node->items_area.items_count,
+		  node->items_area.start_hash,
+		  node->items_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_shared_dict_resize_node_areas(node, search);
+	if (err) {
+		switch (atomic_read(&node->state)) {
+		case SSDFS_BTREE_NODE_CORRUPTED:
+			goto finish_modify_node;
+
+		default:
+			goto check_node_consistency;
+		}
+	}
+
+	err = ssdfs_insert_strings_blob(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert the strings blob: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_hash_table_insert_range(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert range of hashes: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_lookup2_table_insert_range(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to insert lookup2 range: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	err = ssdfs_rebuild_lookup1_table(node);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to rebuild lookup1 table: err %d\n", err);
+		goto check_node_consistency;
+	}
+
+	node->items_area.start_hash = node->hash_tbl_area.start_hash;
+	node->items_area.end_hash = node->hash_tbl_area.end_hash;
+	start_hash = node->items_area.start_hash;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("AFTER: items_count %u, "
+	          "start_hash %#llx, end_hash %#llx\n",
+	          node->items_area.items_count,
+	          node->items_area.start_hash,
+	          node->items_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+check_node_consistency:
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_modify_node;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+finish_modify_node:
+	up_write(&node->header_lock);
+
+finish_insert_name_range:
+	up_write(&node->full_lock);
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_HYBRID_NODE:
+		if (items_area.items_count == 0) {
+			struct ssdfs_btree_index_key key;
+
+			spin_lock(&node->descriptor_lock);
+			ssdfs_memcpy(&key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			spin_unlock(&node->descriptor_lock);
+
+			key.index.hash = cpu_to_le64(start_hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("node_id %u, node_type %#x, "
+				  "node_height %u, hash %llx\n",
+				  le32_to_cpu(key.node_id),
+				  key.node_type,
+				  key.height,
+				  le64_to_cpu(key.index.hash));
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			err = ssdfs_btree_node_add_index(node, &key);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to add index: err %d\n", err);
+				return err;
+			}
+		} else if (old_hash != start_hash) {
+			struct ssdfs_btree_index_key old_key, new_key;
+
+			spin_lock(&node->descriptor_lock);
+			ssdfs_memcpy(&old_key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			ssdfs_memcpy(&new_key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			spin_unlock(&node->descriptor_lock);
+
+			old_key.index.hash = cpu_to_le64(old_hash);
+			new_key.index.hash = cpu_to_le64(start_hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("old_hash %llx, start_hash %llx\n",
+				  old_hash, start_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			err = ssdfs_btree_node_change_index(node,
+							&old_key, &new_key);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to change index: err %d\n",
+					  err);
+				return err;
+			}
+		}
+		break;
+
+	default:
+		/* do nothing */
+		break;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_check_shdict_btree_node_consistency(node);
+	ssdfs_debug_btree_node_object(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_insert_range() - insert a range into the node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to insert a range of items into the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENOSPC     - node hasn't free space.
+ * %-ENOMEM     - fail to allocate memory.
+ */
+static
+int ssdfs_shared_dict_btree_node_insert_range(struct ssdfs_btree_node *node,
+					      struct ssdfs_btree_search *search)
+{
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(search->result.name_buf.state ==
+				SSDFS_BTREE_SEARCH_UNKNOWN_BUFFER_STATE);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = ssdfs_shared_dict_btree_node_name_range_insert(node,
+								     search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert name range: err %d\n",
+				  err);
+		}
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(search->result.range_buf.state ==
+				SSDFS_BTREE_SEARCH_UNKNOWN_BUFFER_STATE);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		err = __ssdfs_shared_dict_btree_node_insert_range(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to insert name range: err %d\n",
+				  err);
+		}
+	} else {
+		err = -ERANGE;
+		SSDFS_ERR("invalid search result state: "
+			  "flags %#x\n",
+			  search->result.flags);
+	}
+
+	return err;
+}
+
+static
+int ssdfs_shared_dict_btree_node_change_item(struct ssdfs_btree_node *node,
+					     struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("operation is unavailable\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+	return -EOPNOTSUPP;
+}
+
+/*
+ * is_lookup1_position_correct() - check that lookup1 position is correct
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to check that requested position
+ * into the node is correct.
+ *
+ * RETURN:
+ * [success]
+ *
+ * %SSDFS_CORRECT_POSITION        - requested position is correct.
+ * %SSDFS_SEARCH_LEFT_DIRECTION   - correct position from the left.
+ * %SSDFS_SEARCH_RIGHT_DIRECTION  - correct position from the right.
+ *
+ * [failure] - error code:
+ *
+ * %SSDFS_CHECK_POSITION_FAILURE  - internal error.
+ */
+static inline
+int is_lookup1_position_correct(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_search *search)
+{
+	struct ssdfs_lookup_descriptor *lookup = NULL;
+	union ssdfs_shdict_search_key req_key, found_key;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	int err, res;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		lookup = &search->result.name_buf.place.name->lookup;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		lookup = &search->result.range_buf.place.name_range->lookup1;
+	} else
+		BUG();
+
+	ssdfs_memcpy(&req_key, 0, key_size,
+		     &lookup->desc, 0, key_size,
+		     key_size);
+
+	err = ssdfs_get_lookup1_table_search_key(node, lookup->index,
+						 &found_key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get lookup1 key: "
+			  "index %u, err %d\n",
+			  lookup->index, err);
+		return SSDFS_CHECK_POSITION_FAILURE;
+	}
+
+	res = ssdfs_hash32_lo_compare(&req_key, &found_key);
+	if (res == 0)
+		return SSDFS_CORRECT_POSITION;
+	else if (res < 0)
+		return SSDFS_SEARCH_LEFT_DIRECTION;
+	else
+		return SSDFS_SEARCH_RIGHT_DIRECTION;
+}
+
+/*
+ * is_lookup2_position_correct() - check that lookup2 position is correct
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to check that requested position
+ * into the node is correct.
+ *
+ * RETURN:
+ * [success]
+ *
+ * %SSDFS_CORRECT_POSITION        - requested position is correct.
+ * %SSDFS_SEARCH_LEFT_DIRECTION   - correct position from the left.
+ * %SSDFS_SEARCH_RIGHT_DIRECTION  - correct position from the right.
+ *
+ * [failure] - error code:
+ *
+ * %SSDFS_CHECK_POSITION_FAILURE  - internal error.
+ */
+static inline
+int is_lookup2_position_correct(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_index_area *lookup_tbl_area;
+	union ssdfs_shdict_search_key req_key, found_key;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	u16 index = U16_MAX;
+	int err, res;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	lookup_tbl_area = &node->lookup_tbl_area;
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		struct ssdfs_strings_range_descriptor *strings_range;
+
+		strings_range =
+			&search->result.name_buf.place.name->strings_range;
+		ssdfs_memcpy(&req_key, 0, key_size,
+			     &strings_range->desc, 0, key_size,
+			     key_size);
+		index = strings_range->index;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		struct ssdfs_name_string_range *name_range;
+		struct ssdfs_btree_search_buffer *buf;
+
+		name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		buf = &name_range->lookup2_table.buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ssdfs_memcpy(&req_key, 0, key_size,
+			     buf->place.ltbl2_items, 0, key_size,
+			     key_size);
+		index = name_range->lookup2_table.index;
+	} else
+		BUG();
+
+	err = ssdfs_get_lookup2_descriptor(node, lookup_tbl_area, index,
+					   SSDFS_LTBL2_DESC(&found_key));
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get lookup2 key: "
+			  "index %u, err %d\n",
+			  index, err);
+		return SSDFS_CHECK_POSITION_FAILURE;
+	}
+
+	res = ssdfs_hash64_compare(&req_key, &found_key);
+	if (res == 0)
+		return SSDFS_CORRECT_POSITION;
+	else if (res < 0)
+		return SSDFS_SEARCH_LEFT_DIRECTION;
+	else
+		return SSDFS_SEARCH_RIGHT_DIRECTION;
+}
+
+/*
+ * is_hash_position_correct() - check that hash position is correct
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to check that requested position
+ * into the node is correct.
+ *
+ * RETURN:
+ * [success]
+ *
+ * %SSDFS_CORRECT_POSITION        - requested position is correct.
+ * %SSDFS_SEARCH_LEFT_DIRECTION   - correct position from the left.
+ * %SSDFS_SEARCH_RIGHT_DIRECTION  - correct position from the right.
+ *
+ * [failure] - error code:
+ *
+ * %SSDFS_CHECK_POSITION_FAILURE  - internal error.
+ */
+static inline
+int is_hash_position_correct(struct ssdfs_btree_node *node,
+			     struct ssdfs_btree_search *search,
+			     u16 item_index)
+{
+	struct ssdfs_btree_node_index_area *hash_tbl_area;
+	union ssdfs_shdict_search_key req_key = {0};
+	union ssdfs_shdict_search_key found_key = {0};
+	int err, res;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, item_index %u\n",
+		node->node_id, item_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_tbl_area = &node->hash_tbl_area;
+
+	err = ssdfs_convert_hash64_to_hash64_key(search, &req_key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert hash64: err %d\n",
+			  err);
+		return SSDFS_CHECK_POSITION_FAILURE;
+	}
+
+	err = ssdfs_get_hash_descriptor(node, hash_tbl_area,
+					item_index,
+					SSDFS_HTBL_DESC(&found_key));
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  item_index, err);
+		return SSDFS_CHECK_POSITION_FAILURE;
+	}
+
+	res = ssdfs_hash64_compare(&req_key, &found_key);
+	if (res == 0)
+		return SSDFS_CORRECT_POSITION;
+	else if (res < 0)
+		return SSDFS_SEARCH_LEFT_DIRECTION;
+	else
+		return SSDFS_SEARCH_RIGHT_DIRECTION;
+}
+
+/*
+ * is_requested_position_correct() - check that requested position is correct
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to check that requested position
+ * into the node is correct.
+ *
+ * RETURN:
+ * [success]
+ *
+ * %SSDFS_CORRECT_POSITION        - requested position is correct.
+ * %SSDFS_SEARCH_LEFT_DIRECTION   - correct position from the left.
+ * %SSDFS_SEARCH_RIGHT_DIRECTION  - correct position from the right.
+ *
+ * [failure] - error code:
+ *
+ * %SSDFS_CHECK_POSITION_FAILURE  - internal error.
+ */
+static
+int is_requested_position_correct(struct ssdfs_btree_node *node,
+				  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area *items_area;
+	struct ssdfs_btree_node_index_area *hash_tbl_area;
+	struct ssdfs_btree_node_index_area *lookup_tbl_area;
+	u16 item_index;
+	u16 items_count, items_capacity;
+	int direction = SSDFS_CHECK_POSITION_FAILURE;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, item_index %u\n",
+		  node->node_id, search->result.start_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_area = &node->items_area;
+	hash_tbl_area = &node->hash_tbl_area;
+	lookup_tbl_area = &node->lookup_tbl_area;
+
+	items_count = items_area->items_count;
+	items_capacity = items_area->items_capacity;
+
+	item_index = search->result.start_index;
+	if ((item_index + search->request.count) > items_capacity) {
+		SSDFS_ERR("invalid request: "
+			  "request (item_index %u, count %u), "
+			  "items_capacity %u\n",
+			  item_index, search->request.count,
+			  items_capacity);
+		return SSDFS_CHECK_POSITION_FAILURE;
+	}
+
+	if (item_index >= items_count) {
+		if (items_count == 0)
+			item_index = items_count;
+		else
+			item_index = items_count - 1;
+
+		search->result.start_index = item_index;
+	}
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+			/* expected states */
+			break;
+
+		default:
+			SSDFS_ERR("invalid name state %#x\n",
+				  search->result.name_buf.state);
+			return SSDFS_CHECK_POSITION_FAILURE;
+		}
+
+		if (!search->result.name_buf.place.name) {
+			SSDFS_ERR("invalid name buffer\n");
+			return SSDFS_CHECK_POSITION_FAILURE;
+		}
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		switch (search->result.range_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+			/* expected states */
+			break;
+
+		default:
+			SSDFS_ERR("invalid range state %#x\n",
+				  search->result.range_buf.state);
+			return SSDFS_CHECK_POSITION_FAILURE;
+		}
+
+		if (!search->result.range_buf.place.name_range) {
+			SSDFS_ERR("invalid range buffer\n");
+			return SSDFS_CHECK_POSITION_FAILURE;
+		}
+	} else
+		BUG();
+
+	direction = is_lookup1_position_correct(node, search);
+
+	switch (direction) {
+	case SSDFS_CHECK_POSITION_FAILURE:
+	case SSDFS_SEARCH_LEFT_DIRECTION:
+	case SSDFS_SEARCH_RIGHT_DIRECTION:
+		return direction;
+
+	default:
+		/* continue the check */
+		break;
+	}
+
+	direction = is_lookup2_position_correct(node, search);
+
+	switch (direction) {
+	case SSDFS_CHECK_POSITION_FAILURE:
+	case SSDFS_SEARCH_LEFT_DIRECTION:
+	case SSDFS_SEARCH_RIGHT_DIRECTION:
+		return direction;
+
+	default:
+		/* continue the check */
+		break;
+	}
+
+	return is_hash_position_correct(node, search, item_index);
+}
+
+/*
+ * ssdfs_find_lookup1_position_from_left() - find a correct position from left
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to find the correct position from the left
+ * for a lookup1 index.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - the requested position is out of the node.
+ * %-ENOENT     - possible place is found.
+ */
+static
+int ssdfs_find_lookup1_position_from_left(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_lookup_descriptor *lookup;
+	union ssdfs_shdict_search_key req_key, found_key;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	int i;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		lookup = &search->result.name_buf.place.name->lookup;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		lookup = &search->result.range_buf.place.name_range->lookup1;
+	} else
+		BUG();
+
+	ssdfs_memcpy(&req_key, 0, key_size,
+		     &lookup->desc, 0, key_size,
+		     key_size);
+	memset(&found_key, 0xFF, key_size);
+
+	if (lookup->index == 0) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find a new index: "
+			  "lookup->index %u\n",
+			  lookup->index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	for (i = lookup->index - 1; i >= 0; i--) {
+		err = ssdfs_get_lookup1_table_search_key(node, i, &found_key);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup1 key: "
+				  "index %d, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		res = ssdfs_hash32_lo_compare(&req_key, &found_key);
+		if (res == 0) {
+			lookup->index = i;
+			return 0;
+		} else if (res > 0) {
+			lookup->index = i;
+			return -ENOENT;
+		}
+	}
+
+	lookup->index = 0;
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_find_lookup2_position_from_left() - find a correct position from left
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to find the correct position from the left
+ * for a lookup2 index.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - the requested position is out of the node.
+ * %-ENOENT     - possible place is found.
+ */
+static
+int ssdfs_find_lookup2_position_from_left(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_index_area *lookup_tbl_area;
+	union ssdfs_shdict_search_key req_key = {0};
+	union ssdfs_shdict_search_key found_key = {0};
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	u16 *index = NULL;
+	int i;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	lookup_tbl_area = &node->lookup_tbl_area;
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		struct ssdfs_strings_range_descriptor *strings_range;
+
+		strings_range =
+			&search->result.name_buf.place.name->strings_range;
+		ssdfs_memcpy(&req_key, 0, key_size,
+			     &strings_range->desc, 0, key_size,
+			     key_size);
+		index = &strings_range->index;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		struct ssdfs_name_string_range *name_range;
+		struct ssdfs_btree_search_buffer *buf;
+
+		name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		buf = &name_range->lookup2_table.buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ssdfs_memcpy(&req_key, 0, key_size,
+			     buf->place.ltbl2_items, 0, key_size,
+			     key_size);
+		index = &name_range->lookup2_table.index;
+	} else
+		BUG();
+
+	if (*index == 0) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find a new index: "
+			  "index %u\n",
+			  *index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	for (i = *index - 1; i >= 0; i--) {
+		err = ssdfs_get_lookup2_descriptor(node, lookup_tbl_area, i,
+						SSDFS_LTBL2_DESC(&found_key));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 key: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		res = ssdfs_hash64_compare(&req_key, &found_key);
+		if (res == 0) {
+			*index = i;
+			return 0;
+		} else if (res > 0) {
+			*index = i;
+			return -ENOENT;
+		}
+	}
+
+	*index = 0;
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_find_hash_position_from_left() - find a correct position from left
+ * @node: node object
+ * @item_index: starting item index
+ * @search: search object
+ *
+ * This method tries to find the correct position from the left
+ * for a hash index.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - the requested position is out of the node.
+ * %-ENOENT     - possible place is found.
+ */
+static
+int ssdfs_find_hash_position_from_left(struct ssdfs_btree_node *node,
+					int item_index,
+					struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_index_area *hash_tbl_area;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	union ssdfs_shdict_search_key req_key = {0};
+	union ssdfs_shdict_search_key found_key = {0};
+	u16 lower_bound;
+	u16 *index = NULL;
+	int i;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_tbl_area = &node->hash_tbl_area;
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		struct ssdfs_strings_range_descriptor *strings_range;
+
+		strings_range =
+			&search->result.name_buf.place.name->strings_range;
+		ltbl2_item = &strings_range->desc;
+
+		index = &search->result.name_buf.place.name->right_name.index;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		struct ssdfs_name_string_range *name_range;
+		struct ssdfs_btree_search_buffer *buf;
+
+		name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		buf = &name_range->lookup2_table.buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ltbl2_item = buf->place.ltbl2_items;
+		index = &name_range->hash_table.index;
+	} else
+		BUG();
+
+	lower_bound = le16_to_cpu(ltbl2_item->hash_index);
+
+	if (item_index <= 0) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find a new index: "
+			  "item_index %d\n",
+			  item_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	if (item_index <= lower_bound) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("item_index %d <= lower_bound %u\n",
+			  item_index, lower_bound);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	err = ssdfs_convert_hash64_to_hash64_key(search, &req_key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert hash64: err %d\n",
+			  err);
+		return err;
+	}
+
+	for (i = item_index - 1; i >= lower_bound; i--) {
+		err = ssdfs_get_hash_descriptor(node, hash_tbl_area, i,
+						SSDFS_HTBL_DESC(&found_key));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		res = ssdfs_hash64_compare(&req_key, &found_key);
+		if (res == 0) {
+			*index = i;
+			return 0;
+		} else if (res > 0) {
+			*index = i;
+			return -ENOENT;
+		}
+	}
+
+	*index = lower_bound;
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_find_correct_position_from_left() - find position from the left
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to find a correct position of the name
+ * from the left side of names' sequence in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_find_correct_position_from_left(struct ssdfs_btree_node *node,
+					  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area *items_area;
+	int item_index;
+	u16 items_count, items_capacity;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, item_index %u\n",
+		  node->node_id, search->result.start_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_area = &node->items_area;
+	items_count = items_area->items_count;
+	items_capacity = items_area->items_capacity;
+
+	item_index = search->result.start_index;
+	if ((item_index + search->request.count) >= items_capacity) {
+		SSDFS_ERR("invalid request: "
+			  "item_index %d, count %u\n",
+			  item_index, search->request.count);
+		return -ERANGE;
+	}
+
+	if (item_index >= items_count) {
+		if (items_count == 0)
+			item_index = items_count;
+		else
+			item_index = items_count - 1;
+
+		search->result.start_index = (u16)item_index;
+	}
+
+	if (item_index == 0)
+		return 0;
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+			/* expected states */
+			break;
+
+		default:
+			SSDFS_ERR("invalid name state %#x\n",
+				  search->result.name_buf.state);
+			return -ERANGE;
+		}
+
+		if (!search->result.name_buf.place.name) {
+			SSDFS_ERR("invalid name buffer\n");
+			return -ERANGE;
+		}
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		switch (search->result.range_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+			/* expected states */
+			break;
+
+		default:
+			SSDFS_ERR("invalid range state %#x\n",
+				  search->result.range_buf.state);
+			return -ERANGE;
+		}
+
+		if (!search->result.range_buf.place.name_range) {
+			SSDFS_ERR("invalid range buffer\n");
+			return -ERANGE;
+		}
+	} else
+		BUG();
+
+	switch (is_lookup1_position_correct(node, search)) {
+	case SSDFS_CORRECT_POSITION:
+		/* check the lookup2 table */
+		break;
+
+	case SSDFS_SEARCH_LEFT_DIRECTION:
+		err = ssdfs_find_lookup1_position_from_left(node, search);
+		if (err == -ENODATA || err == -ENOENT) {
+			err = 0;
+			/* continue logic */
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to find a position in lookup1 table: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid direction\n");
+		return -ERANGE;
+	}
+
+	switch (is_lookup2_position_correct(node, search)) {
+	case SSDFS_CORRECT_POSITION:
+		/* do nothing */
+		break;
+
+	case SSDFS_SEARCH_LEFT_DIRECTION:
+		err = ssdfs_find_lookup2_position_from_left(node, search);
+		if (err == -ENODATA || err == -ENOENT) {
+			err = 0;
+			/* continue logic */
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to find a position in lookup2 table: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid direction\n");
+		return -ERANGE;
+	}
+
+	switch (is_hash_position_correct(node, search, item_index)) {
+	case SSDFS_CORRECT_POSITION:
+		break;
+
+	case SSDFS_SEARCH_LEFT_DIRECTION:
+		err = ssdfs_find_hash_position_from_left(node, item_index, search);
+		if (err == -ENODATA || err == -ENOENT) {
+			err = 0;
+			/* continue logic */
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to find a position in hash table: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid direction\n");
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_find_lookup1_position_from_right() - find a correct position from right
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to find the correct position from the right
+ * for a lookup1 index.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - the requested position is out of the node.
+ * %-ENOENT     - possible place is found.
+ */
+static
+int ssdfs_find_lookup1_position_from_right(struct ssdfs_btree_node *node,
+					   struct ssdfs_btree_search *search)
+{
+	struct ssdfs_lookup_descriptor *lookup;
+	union ssdfs_shdict_search_key req_key = {0};
+	union ssdfs_shdict_search_key found_key = {0};
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	u16 table_size;
+	int i;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		lookup = &search->result.name_buf.place.name->lookup;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		lookup = &search->result.range_buf.place.name_range->lookup1;
+	} else
+		BUG();
+
+	table_size = le16_to_cpu(node->raw.dict_header.lookup_table1_items);
+
+	ssdfs_memcpy(&req_key, 0, key_size,
+		     &lookup->desc, 0, key_size,
+		     key_size);
+
+	if (lookup->index >= table_size) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find a new index: "
+			  "lookup->index %u, table_size %u\n",
+			  lookup->index, table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	for (i = lookup->index; i < table_size; i++) {
+		err = ssdfs_get_lookup1_table_search_key(node, i, &found_key);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup1 key: "
+				  "index %d, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		res = ssdfs_hash32_lo_compare(&req_key, &found_key);
+		if (res == 0) {
+			lookup->index = i;
+			return 0;
+		} else if (res < 0) {
+			lookup->index = i - 1;
+			return -ENOENT;
+		}
+	}
+
+	lookup->index = table_size - 1;
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_find_lookup2_position_from_right() - find a correct position from right
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to find the correct position from the right
+ * for a lookup2 index.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - the requested position is out of the node.
+ * %-ENOENT     - possible place is found.
+ */
+static
+int ssdfs_find_lookup2_position_from_right(struct ssdfs_btree_node *node,
+					   struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_index_area *lookup_tbl_area;
+	union ssdfs_shdict_search_key req_key, found_key;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	u16 table_size;
+	u16 *index = NULL;
+	int i;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	lookup_tbl_area = &node->lookup_tbl_area;
+	table_size = lookup_tbl_area->index_count;
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		struct ssdfs_strings_range_descriptor *strings_range;
+
+		strings_range =
+			&search->result.name_buf.place.name->strings_range;
+		ssdfs_memcpy(&req_key, 0, key_size,
+			     &strings_range->desc, 0, key_size,
+			     key_size);
+		index = &strings_range->index;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		struct ssdfs_name_string_range *name_range;
+		struct ssdfs_btree_search_buffer *buf;
+
+		name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		buf = &name_range->lookup2_table.buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ssdfs_memcpy(&req_key, 0, key_size,
+			     buf->place.ltbl2_items, 0, key_size,
+			     key_size);
+		index = &name_range->lookup2_table.index;
+	} else
+		BUG();
+
+	if (*index >= table_size) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find a new index: "
+			  "index %u, table_size %u\n",
+			  *index, table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	for (i = *index; i < table_size; i++) {
+		err = ssdfs_get_lookup2_descriptor(node, lookup_tbl_area, i,
+						SSDFS_LTBL2_DESC(&found_key));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 key: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		res = ssdfs_hash64_compare(&req_key, &found_key);
+		if (res == 0) {
+			*index = i;
+			return 0;
+		} else if (res < 0) {
+			*index = i - 1;
+			return -ENOENT;
+		}
+	}
+
+	*index = table_size - 1;
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_find_hash_position_from_right() - find a correct position from right
+ * @node: node object
+ * @search: search object
+ *
+ * This method tries to find the correct position from the right
+ * for a hash index.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-ENODATA    - the requested position is out of the node.
+ * %-ENOENT     - possible place is found.
+ */
+static
+int ssdfs_find_hash_position_from_right(struct ssdfs_btree_node *node,
+					int item_index,
+					struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_index_area *hash_tbl_area;
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	union ssdfs_shdict_search_key req_key = {0};
+	union ssdfs_shdict_search_key found_key = {0};
+	u16 table_size;
+	u16 upper_bound;
+	u16 *index = NULL;
+	int i;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_tbl_area = &node->hash_tbl_area;
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		struct ssdfs_strings_range_descriptor *strings_range;
+
+		strings_range =
+			&search->result.name_buf.place.name->strings_range;
+		ltbl2_item = &strings_range->desc;
+
+		index = &search->result.name_buf.place.name->right_name.index;
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		struct ssdfs_name_string_range *name_range;
+		struct ssdfs_btree_search_buffer *buf;
+
+		name_range = search->result.range_buf.place.name_range;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(!name_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		buf = &name_range->lookup2_table.buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+		ltbl2_item = buf->place.ltbl2_items;
+		index = &name_range->hash_table.index;
+	} else
+		BUG();
+
+	table_size = hash_tbl_area->index_count;
+
+	upper_bound = le16_to_cpu(ltbl2_item->hash_index);
+	upper_bound += ltbl2_item->str_count;
+
+	if (item_index >= table_size) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("unable to find a new index: "
+			  "item_index %u, table_size %u\n",
+			  item_index, table_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	if (upper_bound > table_size) {
+		SSDFS_ERR("upper_bound %u > table_size %u\n",
+			  upper_bound, table_size);
+		return -ERANGE;
+	}
+
+	if (item_index >= upper_bound) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("item_index %d >= upper_bound %u\n",
+			  item_index, upper_bound);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	err = ssdfs_convert_hash64_to_hash64_key(search, &req_key);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to convert hash64: err %d\n",
+			  err);
+		return err;
+	}
+
+	for (i = item_index; i < upper_bound; i++) {
+		err = ssdfs_get_hash_descriptor(node, hash_tbl_area, i,
+						SSDFS_HTBL_DESC(&found_key));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		res = ssdfs_hash64_compare(&req_key, &found_key);
+		if (res == 0) {
+			*index = i;
+			return 0;
+		} else if (res < 0) {
+			*index = i - 1;
+			return -ENOENT;
+		}
+	}
+
+	*index = upper_bound - 1;
+	return -ENODATA;
+}
+
+/*
+ * ssdfs_find_correct_position_from_right() - find position from the right
+ * @node: pointer on node object
+ * @search: search object
+ *
+ * This method tries to find a correct position of the name
+ * from the right side of names' sequence in the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_find_correct_position_from_right(struct ssdfs_btree_node *node,
+					   struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area *items_area;
+	int item_index;
+	u16 items_count, items_capacity;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, item_index %u\n",
+		  node->node_id, search->result.start_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_area = &node->items_area;
+	items_count = items_area->items_count;
+	items_capacity = items_area->items_capacity;
+
+	item_index = search->result.start_index;
+	if ((item_index + search->request.count) >= items_capacity) {
+		SSDFS_ERR("invalid request: "
+			  "item_index %d, count %u\n",
+			  item_index, search->request.count);
+		return -ERANGE;
+	}
+
+	if (item_index >= items_count) {
+		if (items_count == 0)
+			item_index = items_count;
+		else
+			item_index = items_count - 1;
+
+		search->result.start_index = (u16)item_index;
+	}
+
+	if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_NAME) {
+		switch (search->result.name_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		case SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER:
+			/* expected states */
+			break;
+
+		default:
+			SSDFS_ERR("invalid name state %#x\n",
+				  search->result.name_buf.state);
+			return -ERANGE;
+		}
+
+		if (!search->result.name_buf.place.name) {
+			SSDFS_ERR("invalid name buffer\n");
+			return -ERANGE;
+		}
+	} else if (search->result.flags & SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE) {
+		switch (search->result.range_buf.state) {
+		case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+			/* expected states */
+			break;
+
+		default:
+			SSDFS_ERR("invalid range state %#x\n",
+				  search->result.range_buf.state);
+			return -ERANGE;
+		}
+
+		if (!search->result.range_buf.place.name_range) {
+			SSDFS_ERR("invalid range buffer\n");
+			return -ERANGE;
+		}
+	} else
+		BUG();
+
+	switch (is_lookup1_position_correct(node, search)) {
+	case SSDFS_CORRECT_POSITION:
+		/* check the lookup2 table */
+		break;
+
+	case SSDFS_SEARCH_RIGHT_DIRECTION:
+		err = ssdfs_find_lookup1_position_from_right(node, search);
+		if (err == -ENODATA || err == -ENOENT) {
+			err = 0;
+			/* continue logic */
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to find a position in lookup1 table: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid direction\n");
+		return -ERANGE;
+	}
+
+	switch (is_lookup2_position_correct(node, search)) {
+	case SSDFS_CORRECT_POSITION:
+		/* check the hash table */
+		break;
+
+	case SSDFS_SEARCH_RIGHT_DIRECTION:
+		err = ssdfs_find_lookup2_position_from_right(node, search);
+		if (err == -ENODATA || err == -ENOENT) {
+			err = 0;
+			/* continue logic */
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to find a position in lookup2 table: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid direction\n");
+		return -ERANGE;
+	}
+
+	switch (is_hash_position_correct(node, search, item_index)) {
+	case SSDFS_CORRECT_POSITION:
+		/* do nothing */
+		break;
+
+	case SSDFS_SEARCH_RIGHT_DIRECTION:
+		err = ssdfs_find_hash_position_from_right(node,
+							  item_index,
+							  search);
+		if (err == -ENODATA || err == -ENOENT) {
+			err = 0;
+			/* continue logic */
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to find a position in hash table: "
+				  "err %d\n", err);
+			return err;
+		}
+		break;
+
+	default:
+		SSDFS_ERR("invalid direction\n");
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * __ssdfs_invalidate_items_area() - invalidate the items area
+ * @node: pointer on node object
+ * @start_index: starting index of the item
+ * @range_len: number of items in the range
+ * @search: pointer on search request object
+ *
+ * The method tries to invalidate the items area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int __ssdfs_invalidate_items_area(struct ssdfs_btree_node *node,
+				  u16 start_index, u16 range_len,
+				  struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node *parent = NULL;
+	struct ssdfs_shared_dictionary_node_header *hdr;
+	struct ssdfs_btree_node_items_area *items_area;
+	struct ssdfs_btree_node_index_area *ltbl_area;
+	struct ssdfs_btree_node_index_area *htbl_area;
+	bool is_hybrid = false;
+	bool has_index_area = false;
+	bool index_area_empty = false;
+	bool items_area_empty = false;
+	int parent_type = SSDFS_BTREE_LEAF_NODE;
+	spinlock_t *lock;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, start_index %u, range_len %u\n",
+		  node->node_id, start_index, range_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	items_area = &node->items_area;
+
+	switch (atomic_read(&node->lookup_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_LOOKUP_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid lookup_tbl_area state %#x\n",
+			  atomic_read(&node->lookup_tbl_area.state));
+		return -ERANGE;
+	}
+
+	ltbl_area = &node->lookup_tbl_area;
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	htbl_area = &node->hash_tbl_area;
+
+	if (((u32)start_index + range_len) > items_area->items_count) {
+		SSDFS_ERR("start_index %u, range_len %u, items_count %u\n",
+			  start_index, range_len,
+			  items_area->items_count);
+		return -ERANGE;
+	}
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_HYBRID_NODE:
+		is_hybrid = true;
+		break;
+
+	case SSDFS_BTREE_LEAF_NODE:
+		is_hybrid = false;
+		break;
+
+	default:
+		SSDFS_WARN("invalid node type %#x\n",
+			   atomic_read(&node->type));
+		return -ERANGE;
+	}
+
+	if (items_area->items_count == range_len) {
+		items_area_empty = true;
+
+		items_area->items_count = 0;
+		items_area->free_space = items_area->area_size;
+		items_area->items_capacity =
+			items_area->free_space / items_area->min_item_size;
+		items_area->start_hash = U64_MAX;
+		items_area->end_hash = U64_MAX;
+
+		htbl_area->index_count = 0;
+		htbl_area->index_capacity =
+			htbl_area->area_size / htbl_area->index_size;
+		htbl_area->start_hash = U64_MAX;
+		htbl_area->end_hash = U64_MAX;
+
+		ltbl_area->index_count = 0;
+		ltbl_area->index_capacity =
+			ltbl_area->area_size / ltbl_area->index_size;
+		ltbl_area->start_hash = U64_MAX;
+		ltbl_area->end_hash = U64_MAX;
+
+		hdr = &node->raw.dict_header;
+		hdr->lookup_table1_items = cpu_to_le16(0);
+		memset(hdr->lookup_table1, 0xFF,
+			sizeof(struct ssdfs_shdict_ltbl1_item) *
+			SSDFS_SHDIC_LTBL1_SIZE);
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("LOOKUP1 TABLE DUMP\n");
+		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+				     hdr->lookup_table1,
+				     sizeof(struct ssdfs_shdict_ltbl1_item) *
+					SSDFS_SHDIC_LTBL1_SIZE);
+		SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+	} else
+		items_area_empty = false;
+
+	switch (atomic_read(&node->index_area.state)) {
+	case SSDFS_BTREE_NODE_INDEX_AREA_EXIST:
+		has_index_area = true;
+		if (node->index_area.index_count == 0)
+			index_area_empty = true;
+		else
+			index_area_empty = false;
+		break;
+
+	default:
+		has_index_area = false;
+		index_area_empty = false;
+		break;
+	}
+
+	switch (search->request.type) {
+	case SSDFS_BTREE_SEARCH_DELETE_ITEM:
+	case SSDFS_BTREE_SEARCH_DELETE_RANGE:
+		if (is_hybrid && has_index_area && !index_area_empty) {
+			search->result.state =
+				SSDFS_BTREE_SEARCH_OBSOLETE_RESULT;
+		} else if (items_area_empty) {
+			search->result.state =
+				SSDFS_BTREE_SEARCH_PLEASE_DELETE_NODE;
+		} else {
+			search->result.state =
+				SSDFS_BTREE_SEARCH_OBSOLETE_RESULT;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_DELETE_ALL:
+		search->result.state =
+			SSDFS_BTREE_SEARCH_OBSOLETE_RESULT;
+
+		parent = node;
+
+		do {
+			lock = &parent->descriptor_lock;
+			spin_lock(lock);
+			parent = parent->parent_node;
+			spin_unlock(lock);
+			lock = NULL;
+
+			if (!parent) {
+				SSDFS_ERR("node %u hasn't parent\n",
+					  node->node_id);
+				return -ERANGE;
+			}
+
+			parent_type = atomic_read(&parent->type);
+			switch (parent_type) {
+			case SSDFS_BTREE_ROOT_NODE:
+			case SSDFS_BTREE_INDEX_NODE:
+			case SSDFS_BTREE_HYBRID_NODE:
+				/* expected state */
+				break;
+
+			default:
+				SSDFS_ERR("invalid parent node's type %#x\n",
+					  parent_type);
+				return -ERANGE;
+			}
+		} while (parent_type != SSDFS_BTREE_ROOT_NODE);
+
+		err = ssdfs_invalidate_root_node_hierarchy(parent);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to invalidate root node hierarchy: "
+				  "err %d\n", err);
+			return -ERANGE;
+		}
+		break;
+
+	default:
+		atomic_set(&node->state,
+			   SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid request type %#x\n",
+			  search->request.type);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_invalidate_whole_items_area() - invalidate the whole items area
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * The method tries to invalidate the items area.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_invalidate_whole_items_area(struct ssdfs_btree_node *node,
+					struct ssdfs_btree_search *search)
+{
+	u16 items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, search %p\n",
+		  node->node_id, search);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	items_count = node->items_area.items_count;
+	return __ssdfs_invalidate_items_area(node, 0, items_count, search);
+}
+
+/*
+ * ssdfs_invalidate_items_area_partially() - invalidate the items area
+ * @node: pointer on node object
+ * @start_index: starting index
+ * @range_len: number of items in the range
+ * @search: pointer on search request object
+ *
+ * The method tries to invalidate the items area partially.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_invalidate_items_area_partially(struct ssdfs_btree_node *node,
+					  u16 start_index, u16 range_len,
+					  struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, start_index %u, range_len %u\n",
+		  node->node_id, start_index, range_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return __ssdfs_invalidate_items_area(node,
+					     start_index, range_len,
+					     search);
+}
+
+/*
+ * ssdfs_shift_strings_range_left() - shift the strings range to the left
+ * @node: pointer on node object
+ * @start_hindex: starting hash index of removing item
+ * @end_hindex: ending hash index of removing item
+ * @deleted_space: pointer on the value of deleted space size [in|out]
+ *
+ * The method tries to shift the strings range to the left.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shift_strings_range_left(struct ssdfs_btree_node *node,
+				   u16 start_hindex, u16 end_hindex,
+				   u32 *deleted_space)
+{
+	struct ssdfs_shdict_htbl_item hash_desc;
+	u16 start_offset;
+	u32 selected_space, shift;
+	u16 deleted_range;
+	bool need_to_shift = true;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !deleted_space);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, start_hindex %u, end_hindex %u\n",
+		  node->node_id, start_hindex, end_hindex);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					end_hindex,
+					&hash_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  end_hindex, err);
+		SSDFS_ERR("HASH AREA: (offset %u, area_size %u, "
+			  "index_size %u, index_count %u, "
+			  "index_capacity %u, start_hash %#llx, "
+			  "end_hash %#llx)\n",
+			  node->hash_tbl_area.offset,
+			  node->hash_tbl_area.area_size,
+			  node->hash_tbl_area.index_size,
+			  node->hash_tbl_area.index_count,
+			  node->hash_tbl_area.index_capacity,
+			  node->hash_tbl_area.start_hash,
+			  node->hash_tbl_area.end_hash);
+		return err;
+	}
+
+	start_offset = le16_to_cpu(hash_desc.str_offset);
+	start_offset += hash_desc.str_len;
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					start_hindex,
+					&hash_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  start_hindex, err);
+		return err;
+	}
+
+	if (le16_to_cpu(hash_desc.str_offset) > start_offset) {
+		SSDFS_ERR("start_offset1 %u > start_offset2 %u\n",
+			  le16_to_cpu(hash_desc.str_offset),
+			  start_offset);
+		return -ERANGE;
+	}
+
+	shift = start_offset - le16_to_cpu(hash_desc.str_offset);
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					node->hash_tbl_area.index_count - 1,
+					&hash_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  node->hash_tbl_area.index_count - 1, err);
+		return err;
+	}
+
+	selected_space = le16_to_cpu(hash_desc.str_offset);
+	selected_space += hash_desc.str_len;
+
+	if (start_offset > selected_space) {
+		SSDFS_ERR("start_offset1 %u > start_offset2 %u\n",
+			  start_offset, selected_space);
+		return -ERANGE;
+	}
+
+	selected_space -= start_offset;
+
+	if ((end_hindex + 1) >= node->hash_tbl_area.index_count)
+		need_to_shift = false;
+	else
+		need_to_shift = true;
+
+	if (need_to_shift) {
+		err = ssdfs_shift_memory_range_left(node, &node->items_area,
+						    start_offset,
+						    selected_space,
+						    shift);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to shift memory range: "
+				  "node_id %u, start_offset %u, "
+				  "selected_space %u, shift %u, err %d\n",
+				  node->node_id, start_offset,
+				  selected_space, shift, err);
+			return err;
+		}
+	}
+
+	node->items_area.free_space += shift;
+
+	if (node->items_area.free_space > node->items_area.area_size) {
+		SSDFS_ERR("free_space %u > area_size %u\n",
+			  node->items_area.free_space,
+			  node->items_area.area_size);
+		return -ERANGE;
+	}
+
+	deleted_range = (end_hindex + 1) - start_hindex;
+
+	if (deleted_range > node->items_area.items_count) {
+		SSDFS_ERR("deleted_range %u > items_count %u\n",
+			  deleted_range,
+			  node->items_area.items_count);
+		return -ERANGE;
+	}
+
+	node->items_area.items_count -= deleted_range;
+	*deleted_space += shift;
+
+	set_ssdfs_btree_node_dirty(node);
+
+	return 0;
+}
+
+/*
+ * ssdfs_shift_hash_table_range_left() - shift the hash range to the left
+ * @node: pointer on node object
+ * @start_hindex: starting hash index
+ * @end_hindex: ending hash index
+ * @deleted_bytes: deleted strings' bytes count
+ *
+ * The method tries to shift the hash range to the left.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shift_hash_table_range_left(struct ssdfs_btree_node *node,
+				      u16 start_hindex, u16 end_hindex,
+				      u32 deleted_bytes)
+{
+	struct ssdfs_shdict_htbl_item hash_desc;
+	size_t hdesc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u16 start;
+	u16 deleted_range;
+	u16 selected_range;
+	u16 str_offset;
+	int i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, start_hindex %u, "
+		  "end_hindex %u, deleted_bytes %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  node->node_id, start_hindex,
+		  end_hindex, deleted_bytes,
+		  node->hash_tbl_area.start_hash,
+		  node->hash_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (start_hindex > end_hindex) {
+		SSDFS_ERR("start_hindex %u > end_hindex %u\n",
+			  start_hindex, end_hindex);
+		return -ERANGE;
+	}
+
+	start = end_hindex + 1;
+	deleted_range = start - start_hindex;
+
+	if (deleted_range > node->hash_tbl_area.index_count) {
+		SSDFS_ERR("deleted_range %u > items_count %u\n",
+			  deleted_range,
+			  node->hash_tbl_area.index_count);
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("end_hindex %u, deleted_range %u, "
+		  "hash_tbl_area.index_count %u\n",
+		  end_hindex, deleted_range,
+		  node->hash_tbl_area.index_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (start >= node->hash_tbl_area.index_count)
+		goto correct_hash_tbl_header;
+
+	selected_range = node->hash_tbl_area.index_count - start;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("end_hindex %u, selected_range %u, "
+		  "hash_tbl_area.index_count %u\n",
+		  end_hindex, selected_range,
+		  node->hash_tbl_area.index_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	for (i = start; i < node->hash_tbl_area.index_count; i++) {
+		err = ssdfs_get_hash_descriptor(node,
+						&node->hash_tbl_area,
+						i,
+						&hash_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %d, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		str_offset = le16_to_cpu(hash_desc.str_offset);
+
+		if (str_offset < deleted_bytes) {
+			SSDFS_ERR("str_offset %u < deleted_bytes %u\n",
+				  str_offset, deleted_bytes);
+			SSDFS_ERR("node_id %u, start_hindex %u, "
+				  "end_hindex %u, deleted_bytes %u, "
+				  "start_hash %#llx, end_hash %#llx\n",
+				  node->node_id, start_hindex,
+				  end_hindex, deleted_bytes,
+				  node->hash_tbl_area.start_hash,
+				  node->hash_tbl_area.end_hash);
+			SSDFS_ERR("index %d, selected_range %u, "
+				  "hash_tbl_area.index_count %u\n",
+				  i, selected_range,
+				  node->hash_tbl_area.index_count);
+			return -ERANGE;
+		}
+
+		str_offset -= (u16)deleted_bytes;
+		hash_desc.str_offset = cpu_to_le16(str_offset);
+
+		err = ssdfs_set_hash_descriptor(node,
+						&node->hash_tbl_area,
+						i,
+						&hash_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set hash descriptor: "
+				  "index %d, err %d\n",
+				  i, err);
+			return err;
+		}
+	}
+
+	err = ssdfs_shift_range_left2(node, &node->hash_tbl_area,
+					hdesc_size,
+					start,
+					selected_range,
+					deleted_range);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shift the hash range: "
+			  "node_id %u, start_index %u, "
+			  "range_len %u, shift %u, err %d\n",
+			  node->node_id, start,
+			  selected_range, deleted_range, err);
+		return err;
+	}
+
+correct_hash_tbl_header:
+	node->hash_tbl_area.index_count -= deleted_range;
+
+	if (node->hash_tbl_area.index_count > 0) {
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						0,
+						&hash_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  0, err);
+			return err;
+		}
+
+		node->hash_tbl_area.start_hash = le64_to_cpu(hash_desc.hash);
+
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					node->hash_tbl_area.index_count - 1,
+					&hash_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  node->hash_tbl_area.index_count - 1,
+				  err);
+			return err;
+		}
+
+		node->hash_tbl_area.end_hash = le64_to_cpu(hash_desc.hash);
+	} else {
+		node->hash_tbl_area.start_hash = le64_to_cpu(U64_MAX);
+		node->hash_tbl_area.end_hash = le64_to_cpu(U64_MAX);
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("node_id %u, start_hash %#llx, end_hash %#llx\n",
+		  node->node_id,
+		  node->hash_tbl_area.start_hash,
+		  node->hash_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	ssdfs_mark_hash_table_dirty(node);
+
+	return 0;
+}
+
+/*
+ * ssdfs_shift_lookup2_table_range_left() - shift the lookup2 table's range left
+ * @node: pointer on node object
+ * @start_l2index: starting lookup2 index
+ * @end_l2index: ending lookup2 index
+ *
+ * The method tries to shift the lookup2 table's range to the left.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_shift_lookup2_table_range_left(struct ssdfs_btree_node *node,
+					 u16 start_l2index,
+					 u16 end_l2index)
+{
+	struct ssdfs_shdict_ltbl2_item l2desc;
+	size_t l2desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	u16 start;
+	u16 deleted_range;
+	u16 selected_range;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, start_l2index %u, end_l2index %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  node->node_id, start_l2index, end_l2index,
+		  node->lookup_tbl_area.start_hash,
+		  node->lookup_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (start_l2index > end_l2index) {
+		SSDFS_ERR("start_l2index %u > end_l2index %u\n",
+			  start_l2index, end_l2index);
+		return -ERANGE;
+	}
+
+	start = end_l2index + 1;
+	deleted_range = start - start_l2index;
+
+	if (deleted_range > node->lookup_tbl_area.index_count) {
+		SSDFS_ERR("deleted_range %u > items_count %u\n",
+			  deleted_range,
+			  node->lookup_tbl_area.index_count);
+		return -ERANGE;
+	}
+
+	if (start >= node->lookup_tbl_area.index_count)
+		goto correct_lookup2_tbl_header;
+
+	selected_range = node->lookup_tbl_area.index_count - start;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("lookup_tbl_area.index_count %u, "
+		  "start %u, selected_range %u, deleted_range %u\n",
+		  node->lookup_tbl_area.index_count,
+		  start, selected_range, deleted_range);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_shift_range_left2(node, &node->lookup_tbl_area,
+					l2desc_size,
+					start,
+					selected_range,
+					deleted_range);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shift the lookup2 range: "
+			  "node_id %u, start_index %u, "
+			  "range_len %u, shift %u, err %d\n",
+			  node->node_id, start,
+			  selected_range, deleted_range, err);
+		return err;
+	}
+
+correct_lookup2_tbl_header:
+	node->lookup_tbl_area.index_count -= deleted_range;
+
+	if (node->lookup_tbl_area.index_count > 0) {
+		err = ssdfs_get_lookup2_descriptor(node,
+						   &node->lookup_tbl_area,
+						   0,
+						   &l2desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  0, err);
+			return err;
+		}
+
+		node->lookup_tbl_area.start_hash = le64_to_cpu(l2desc.hash);
+
+		err = ssdfs_get_lookup2_descriptor(node, &node->lookup_tbl_area,
+					node->lookup_tbl_area.index_count - 1,
+					&l2desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  node->lookup_tbl_area.index_count - 1, err);
+			return err;
+		}
+
+		node->lookup_tbl_area.end_hash = le64_to_cpu(l2desc.hash);
+	} else {
+		node->lookup_tbl_area.start_hash = le64_to_cpu(U64_MAX);
+		node->lookup_tbl_area.end_hash = le64_to_cpu(U64_MAX);
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("node_id %u, start_hash %#llx, end_hash %#llx\n",
+		  node->node_id,
+		  node->lookup_tbl_area.start_hash,
+		  node->lookup_tbl_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	ssdfs_mark_lookup2_table_dirty(node);
+
+	return 0;
+}
+
+/*
+ * ssdfs_save_found_l1desc() - save the found lookup1 descriptor
+ * @range: strings range
+ * @found: found search key
+ * @found_index: found index
+ * @lookup: lookup1 descriptor [out]
+ */
+static inline
+int ssdfs_save_found_l1desc(struct ssdfs_strings_range_descriptor *range,
+			    union ssdfs_shdict_search_key *found,
+			    u16 found_index,
+			    struct ssdfs_lookup_descriptor *lookup)
+{
+	struct ssdfs_shdict_ltbl1_item *ltbl1_item;
+	size_t key_size = sizeof(union ssdfs_shdict_search_key);
+	u16 start_index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!range || !found || !lookup);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	ltbl1_item = SSDFS_LTBL1_DESC(found);
+	start_index = le16_to_cpu(ltbl1_item->start_index);
+
+	if (range->index != start_index) {
+		SSDFS_ERR("range->index %u != start_index %u\n",
+			  range->index, start_index);
+		return -ERANGE;
+	}
+
+	ssdfs_memcpy(&lookup->desc, 0, key_size,
+		     &found, 0, key_size,
+		     key_size);
+	lookup->index = found_index;
+
+	return 0;
+}
+
+/*
+ * ssdfs_hash_index_compare() - compare the hash index with the range
+ * @hash_index: index of the hash
+ * @desc: lookup2 descriptor
+ *
+ * -1 - hash_index is outside the range (lesser)
+ *  0 - hash_index is inside the range
+ *  1 - hash_index is outside the range (greater)
+ */
+static inline
+int ssdfs_hash_index_compare(u16 hash_index,
+			     struct ssdfs_shdict_ltbl2_item *desc)
+{
+	u16 range_start, range_end;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!desc);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	range_start = le16_to_cpu(desc->hash_index);
+	range_end = range_start + desc->str_count;
+
+	if (hash_index < range_start)
+		return -1;
+	else if (hash_index >= range_start && hash_index < range_end)
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * ssdfs_extract_full_name_hash() - extract the full hash
+ * @node: pointer on node object
+ * @lookup2_index: index in lookup2 table
+ * @hash64: pointer on extracted hash value [out]
+ *
+ * The method tries to extract the full hash.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static inline
+int ssdfs_extract_full_name_hash(struct ssdfs_btree_node *node,
+				 u32 lookup2_index, u64 *hash64)
+{
+	struct ssdfs_shdict_ltbl2_item ltbl2_desc;
+	struct ssdfs_shdict_htbl_item hash_desc;
+	u32 hash_index;
+	u64 hash;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !hash64);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, lookup2_index %u\n",
+		  node->node_id, lookup2_index);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	*hash64 = U64_MAX;
+
+	err = ssdfs_get_lookup2_descriptor(node, &node->lookup_tbl_area,
+					   lookup2_index, &ltbl2_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get lookup2 descriptor: "
+			  "index %u, err %d\n",
+			  lookup2_index, err);
+		return err;
+	}
+
+	hash = le64_to_cpu(ltbl2_desc.hash);
+	hash_index = le16_to_cpu(ltbl2_desc.hash_index);
+
+	err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+					hash_index, &hash_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  hash_index, err);
+		return err;
+	}
+
+	if (hash != le64_to_cpu(hash_desc.hash)) {
+		int i;
+
+		SSDFS_ERR("node is corrupted: "
+			  "node_id %u, lookup2 %#llx, hash %#llx\n",
+			  node->node_id, hash, le64_to_cpu(hash_desc.hash));
+
+		for (i = 0 ; i < node->lookup_tbl_area.index_count; i++) {
+			ssdfs_get_lookup2_descriptor(node, &node->lookup_tbl_area,
+						     i, &ltbl2_desc);
+			hash_index = le16_to_cpu(ltbl2_desc.hash_index);
+			ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						  hash_index, &hash_desc);
+			SSDFS_ERR("node is corrupted: "
+				  "node_id %u, lookup2 (index %u, hash %#llx), "
+				  "hash (index %u, hash %#llx)\n",
+				  node->node_id,
+				  i, le64_to_cpu(ltbl2_desc.hash),
+				  hash_index, le64_to_cpu(hash_desc.hash));
+		}
+
+		return -ERANGE;
+	}
+
+	*hash64 = le64_to_cpu(hash_desc.hash);
+	return 0;
+}
+
+/*
+ * ssdfs_remove_strings_range() - remove the strings range
+ * @node: pointer on node object
+ * @item_index: starting item index
+ * @range_len: number of items for deletion
+ *
+ * The method tries to remove the strings range.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+static
+int ssdfs_remove_strings_range(struct ssdfs_btree_node *node,
+				u16 item_index, u16 range_len)
+{
+	struct ssdfs_shdict_ltbl2_item ltbl2_desc;
+	u16 start_hindex, end_hindex;
+	u16 start_l2index, end_l2index;
+	u16 hash_index;
+	u32 selected_space;
+	u16 items_capacity, items_count;
+	u32 area_offset, area_size;
+	u32 diff_range = 0;
+	u32 diff_offset = 0;
+	u32 diff_size = 0;
+	u64 hash64;
+	int i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, item_index %u, range_len %u\n",
+		  node->node_id, item_index, range_len);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (range_len == 0) {
+		SSDFS_ERR("range_len == 0\n");
+		return -ERANGE;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("BEFORE: items_count %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  node->items_area.items_count,
+		  node->items_area.start_hash,
+		  node->items_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	start_hindex = item_index;
+	end_hindex = item_index + range_len - 1;
+
+	selected_space = 0;
+	err = ssdfs_shift_strings_range_left(node,
+					     start_hindex,
+					     end_hindex,
+					     &selected_space);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shift the strings range: "
+			  "start_hindex %u, end_hindex %u, err %d\n",
+			  start_hindex, end_hindex, err);
+		return err;
+	}
+
+	err = ssdfs_shift_hash_table_range_left(node,
+						start_hindex,
+						end_hindex,
+						selected_space);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to shift the hash table: "
+			  "start_hindex %u, end_hindex %u, "
+			  "moved_bytes %u, err %d\n",
+			  start_hindex,
+			  end_hindex,
+			  selected_space,
+			  err);
+		return err;
+	}
+
+	for (i = node->lookup_tbl_area.index_count - 1; i >= 0; i--) {
+		err = ssdfs_get_lookup2_descriptor(node, &node->lookup_tbl_area,
+						   i, &ltbl2_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			return err;
+		}
+
+		hash_index = le16_to_cpu(ltbl2_desc.hash_index);
+
+		if (hash_index < start_hindex) {
+			/* do nothing: check next lookup2 item */
+		} else if (hash_index > end_hindex) {
+			/* correct hash index in lookup2 item */
+
+			if (hash_index < range_len) {
+				err = -ERANGE;
+				atomic_set(&node->state,
+					   SSDFS_BTREE_NODE_CORRUPTED);
+				SSDFS_ERR("corrupted lookup2 table: "
+					  "hash_index %u < range_len %u\n",
+					  hash_index, range_len);
+				return err;
+			}
+
+			hash_index -= range_len;
+			ltbl2_desc.hash_index = cpu_to_le16(hash_index);
+
+			err = ssdfs_set_lookup2_descriptor(node,
+						   &node->lookup_tbl_area,
+						   i, &ltbl2_desc);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to set lookup2 descriptor: "
+					  "index %u, err %d\n",
+					  i, err);
+				return err;
+			}
+		} else {
+			/* delete lookup2 item */
+			start_l2index = end_l2index = i;
+
+			err = ssdfs_shift_lookup2_table_range_left(node,
+								start_l2index,
+								end_l2index);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to shift lookup2 table range: "
+					  "start_index %d, end_index %d, "
+					  "err %d\n",
+					  start_l2index,
+					  end_l2index,
+					  err);
+				return err;
+			}
+		}
+	}
+
+	err = ssdfs_rebuild_lookup1_table(node);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to rebuild lookup1 table: err %d\n", err);
+		return err;
+	}
+
+	items_count = node->lookup_tbl_area.index_count;
+	items_capacity = node->lookup_tbl_area.index_capacity;
+
+	if (items_count < items_capacity) {
+		diff_range = items_capacity - items_count;
+		diff_size = diff_range * sizeof(struct ssdfs_shdict_ltbl2_item);
+		diff_offset += diff_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("items_count %u, items_capacity %u, "
+			  "diff_range %u, diff_offset %u, diff_size %u\n",
+			  items_count, items_capacity,
+			  diff_range, diff_offset, diff_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+	}
+
+	if (diff_offset > 0 || diff_size > 0) {
+		area_offset = node->lookup_tbl_area.offset;
+		area_size = node->lookup_tbl_area.area_size;
+
+		if (diff_size > area_size) {
+			SSDFS_ERR("diff %u > area_size %u\n",
+				  diff_size, area_size);
+			return -ERANGE;
+		}
+
+		area_offset += diff_offset;
+		area_size -= diff_size;
+
+		err = ssdfs_resize_lookup2_table(node, area_offset, area_size);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to resize lookup2 table: "
+				  "area_offset %u, area_size %u, err %d\n",
+				  area_offset, area_size, err);
+			return err;
+		}
+	}
+
+	items_count = node->hash_tbl_area.index_count;
+	items_capacity = node->hash_tbl_area.index_capacity;
+
+	if (items_count < items_capacity) {
+		diff_range = items_capacity - items_count;
+		diff_size = diff_range * sizeof(struct ssdfs_shdict_htbl_item);
+		diff_offset += diff_size;
+	}
+
+	if (diff_offset > 0 || diff_size > 0) {
+		area_offset = node->hash_tbl_area.offset;
+		area_size = node->hash_tbl_area.area_size;
+
+		if (diff_size > area_size) {
+			SSDFS_ERR("diff %u > area_size %u\n",
+				  diff_size, area_size);
+			return -ERANGE;
+		}
+
+		area_offset += diff_offset;
+		area_size -= diff_size;
+
+		/* temporary increase the area size for resize */
+		node->hash_tbl_area.area_size = area_size + diff_offset;
+
+		err = ssdfs_resize_hash_table(node, area_offset, area_size);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to resize hash table: "
+				  "area_offset %u, area_size %u, err %d\n",
+				  area_offset, area_size, err);
+			return err;
+		}
+	}
+
+	if (diff_offset > 0) {
+		area_offset = node->items_area.offset;
+		area_size = node->items_area.area_size;
+
+		area_size += diff_offset;
+
+		err = ssdfs_resize_string_area(node, area_offset, area_size);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to resize the string area: "
+				  "area_offset %u, area_size %u, err %d\n",
+				  area_offset, area_size, err);
+			return err;
+		}
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		return -ERANGE;
+	}
+
+	err = ssdfs_extract_full_name_hash(node, 0, &hash64);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to extract full hash: err %d\n", err);
+		return err;
+	}
+
+	node->items_area.start_hash = hash64;
+
+	err = ssdfs_extract_full_name_hash(node,
+					   node->hash_tbl_area.index_count - 1,
+					   &hash64);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to extract full hash: err %d\n", err);
+		return err;
+	}
+
+	node->items_area.end_hash = hash64;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("AFTER: items_count %u, "
+		  "start_hash %#llx, end_hash %#llx\n",
+		  node->items_area.items_count,
+		  node->items_area.start_hash,
+		  node->items_area.end_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	set_ssdfs_btree_node_dirty(node);
+
+	return 0;
+}
+
+/*
+ * __ssdfs_shared_dict_btree_node_delete_range() - delete a range of items
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to delete a range of items from the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int __ssdfs_shared_dict_btree_node_delete_range(struct ssdfs_btree_node *node,
+					    struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area items_area;
+	struct ssdfs_btree_node_index_area lookup_tbl_area;
+	struct ssdfs_btree_node_index_area hash_tbl_area;
+	struct ssdfs_name_string_range *name_range = NULL;
+	struct ssdfs_btree_search_buffer *buf;
+	u16 item_index;
+	u16 index_count = 0;
+	u16 range_len = 0;
+	u16 items_count;
+	int direction;
+	u16 names_count = 0;
+	u64 start_hash = U64_MAX;
+	u64 end_hash = U64_MAX;
+	u64 old_hash;
+	int err = 0, err1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p, request->count %u, "
+		  "result->count %u\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child, search->request.count,
+		  search->result.count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.state) {
+	case SSDFS_BTREE_SEARCH_VALID_ITEM:
+	case SSDFS_BTREE_SEARCH_POSSIBLE_PLACE_FOUND:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid result state %#x\n",
+			  search->result.state);
+		return -ERANGE;
+	}
+
+	if (search->result.err) {
+		SSDFS_WARN("invalid search result: err %d\n",
+			   search->result.err);
+		return search->result.err;
+	}
+
+	name_range = search->result.range_buf.place.name_range;
+	buf = &name_range->hash_table.buf;
+
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	start_hash = le64_to_cpu(buf->place.htbl_items[0].hash);
+	end_hash = le64_to_cpu(buf->place.htbl_items[items_count - 1].hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_hash %#llx, end_hash %#llx, items_count %u\n",
+		  start_hash, end_hash, items_count);
+
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	down_read(&node->header_lock);
+	ssdfs_memcpy(&items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     &node->items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     sizeof(struct ssdfs_btree_node_items_area));
+	old_hash = node->items_area.start_hash;
+	up_read(&node->header_lock);
+
+	err = ssdfs_check_items_area(node, &items_area);
+	if (err == -ENOSPC) {
+		/* ignore the error */
+		err = 0;
+	} else if (unlikely(err)) {
+		atomic_set(&node->state,
+			   SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("items area is corrupted: err %d\n",
+			  err);
+		return err;
+	}
+
+	item_index = search->result.start_index;
+
+	range_len = search->request.count;
+	if (range_len == 0) {
+		SSDFS_ERR("range_len == 0\n");
+		return -ERANGE;
+	}
+
+	switch (search->request.type) {
+	case SSDFS_BTREE_SEARCH_DELETE_ITEM:
+		if ((item_index + range_len) >= items_area.items_count) {
+			SSDFS_ERR("invalid request: "
+				  "item_index %u, count %u\n",
+				  item_index, range_len);
+			return -ERANGE;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_DELETE_RANGE:
+	case SSDFS_BTREE_SEARCH_DELETE_ALL:
+		/* request can be distributed between several nodes */
+		break;
+
+	default:
+		atomic_set(&node->state,
+			   SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid request type %#x\n",
+			  search->request.type);
+		return -ERANGE;
+	}
+
+	down_write(&node->full_lock);
+	down_write(&node->header_lock);
+
+	ssdfs_memcpy(&lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	ssdfs_memcpy(&hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+
+	err = ssdfs_check_lookup2_table_area(node, &lookup_tbl_area);
+	if (unlikely(err)) {
+		atomic_set(&node->state,
+			   SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("lookup2 table area is corrupted\n");
+		goto finish_delete_range;
+	}
+
+	err = ssdfs_check_hash_table_area(node, &hash_tbl_area);
+	if (unlikely(err)) {
+		atomic_set(&node->state,
+			   SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("hash table area is corrupted\n");
+		goto finish_delete_range;
+	}
+
+	direction = is_requested_position_correct(node, search);
+	switch (direction) {
+	case SSDFS_CORRECT_POSITION:
+		/* do nothing */
+		break;
+
+	case SSDFS_SEARCH_LEFT_DIRECTION:
+		err = ssdfs_find_correct_position_from_left(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to find the correct position: "
+				  "err %d\n",
+				  err);
+			goto finish_delete_range;
+		}
+		break;
+
+	case SSDFS_SEARCH_RIGHT_DIRECTION:
+		err = ssdfs_find_correct_position_from_right(node, search);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to find the correct position: "
+				  "err %d\n",
+				  err);
+			goto finish_delete_range;
+		}
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_ERR("fail to check requested position\n");
+		goto finish_delete_range;
+	}
+
+	item_index = search->result.start_index;
+
+	switch (search->request.type) {
+	case SSDFS_BTREE_SEARCH_DELETE_ITEM:
+		if ((item_index + range_len) > node->items_area.items_count) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid items_count: "
+				  "item_index %u, items_count %u, "
+				  "items_count %u\n",
+				  item_index, range_len,
+				  node->items_area.items_count);
+			goto finish_delete_range;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_DELETE_RANGE:
+	case SSDFS_BTREE_SEARCH_DELETE_ALL:
+		/* request can be distributed between several nodes */
+		range_len = min_t(unsigned int, range_len,
+				  node->items_area.items_count - item_index);
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("node_id %u, item_index %u, "
+			  "request.count %u, items_count %u\n",
+			  node->node_id, item_index,
+			  search->request.count,
+			  node->items_area.items_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (range_len == node->items_area.items_count) {
+		/* items area is empty */
+		err = ssdfs_invalidate_whole_items_area(node, search);
+	} else {
+		err = ssdfs_invalidate_items_area_partially(node,
+							    item_index,
+							    range_len,
+							    search);
+	}
+
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to invalidate items area: "
+			  "node_id %u, start_index %u, "
+			  "range_len %u, err %d\n",
+			  node->node_id, item_index,
+			  range_len, err);
+		goto finish_delete_range;
+	}
+
+	switch (search->request.type) {
+	case SSDFS_BTREE_SEARCH_DELETE_ITEM:
+	case SSDFS_BTREE_SEARCH_DELETE_RANGE:
+		switch (search->result.state) {
+		case SSDFS_BTREE_SEARCH_PLEASE_DELETE_NODE:
+			err = ssdfs_set_node_header_dirty(node,
+					node->items_area.items_capacity);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to set header dirty: "
+					  "err %d\n", err);
+			}
+			goto finish_delete_range;
+
+		default:
+			/* continue to shift rest names to left */
+			break;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_DELETE_ALL:
+		err = ssdfs_set_node_header_dirty(node,
+					node->items_area.items_capacity);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to set header dirty: err %d\n",
+				  err);
+		}
+		goto finish_delete_range;
+
+	default:
+		BUG();
+	}
+
+	if (node->items_area.items_count == 0)
+		goto finish_delete_range;
+
+	err = ssdfs_remove_strings_range(node, item_index, range_len);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to remove strings range: "
+			  "item_index %u, range_len %u, err %d\n",
+			  item_index, range_len, err);
+		goto finish_delete_range;
+	}
+
+	err1 = ssdfs_check_node_consistency(node);
+	if (unlikely(err1)) {
+		err = err == 0 ? err1 : err;
+		SSDFS_ERR("node %u is corrupted: err %d\n",
+			  node->node_id, err1);
+		goto finish_delete_range;
+	}
+
+	names_count = node->items_area.items_count;
+	start_hash = node->items_area.start_hash;
+	end_hash = node->items_area.end_hash;
+
+finish_delete_range:
+	if (!err)
+		set_ssdfs_btree_node_dirty(node);
+
+	up_write(&node->header_lock);
+	up_write(&node->full_lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("request.count %u, result.count %u\n",
+		  search->request.count,
+		  search->result.count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (unlikely(err))
+		return err;
+
+	switch (atomic_read(&node->type)) {
+	case SSDFS_BTREE_HYBRID_NODE:
+		if (names_count == 0) {
+			int state;
+
+			down_read(&node->header_lock);
+			state = atomic_read(&node->index_area.state);
+			index_count = node->index_area.index_count;
+			end_hash = node->index_area.end_hash;
+			up_read(&node->header_lock);
+
+			if (state != SSDFS_BTREE_NODE_INDEX_AREA_EXIST) {
+				SSDFS_ERR("invalid area state %#x\n",
+					  state);
+				return -ERANGE;
+			}
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("index_count %u, end_hash %llx, "
+				  "old_hash %llx\n",
+				  index_count, end_hash, old_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			if (index_count <= 1 || end_hash == old_hash) {
+				err = ssdfs_btree_node_delete_index(node,
+								    old_hash);
+				if (unlikely(err)) {
+					SSDFS_ERR("fail to delete index: "
+						  "old_hash %llx, err %d\n",
+						  old_hash, err);
+					return err;
+				}
+
+				if (index_count > 0)
+					index_count--;
+			}
+		} else if (old_hash != start_hash) {
+			struct ssdfs_btree_index_key old_key, new_key;
+
+			spin_lock(&node->descriptor_lock);
+			ssdfs_memcpy(&old_key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			ssdfs_memcpy(&new_key,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     &node->node_index,
+				     0, sizeof(struct ssdfs_btree_index_key),
+				     sizeof(struct ssdfs_btree_index_key));
+			spin_unlock(&node->descriptor_lock);
+
+			old_key.index.hash = cpu_to_le64(old_hash);
+			new_key.index.hash = cpu_to_le64(start_hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("start_hash %llx, old_hash %llx\n",
+				  start_hash, old_hash);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			err = ssdfs_btree_node_change_index(node,
+							&old_key, &new_key);
+			if (unlikely(err)) {
+				SSDFS_ERR("fail to change index: err %d\n",
+					  err);
+				return err;
+			}
+		}
+		break;
+
+	default:
+		/* do nothing */
+		break;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("node_type %#x, names_count %u, index_count %u\n",
+		  atomic_read(&node->type),
+		  names_count, index_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+
+	buf = &name_range->hash_table.buf;
+
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	start_hash = le64_to_cpu(buf->place.htbl_items[0].hash);
+	end_hash = le64_to_cpu(buf->place.htbl_items[items_count - 1].hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_hash %#llx, end_hash %#llx, items_count %u\n",
+		  start_hash, end_hash, items_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (names_count == 0 && index_count == 0)
+		search->result.state = SSDFS_BTREE_SEARCH_PLEASE_DELETE_NODE;
+	else
+		search->result.state = SSDFS_BTREE_SEARCH_OBSOLETE_RESULT;
+
+	if (search->request.type == SSDFS_BTREE_SEARCH_DELETE_RANGE) {
+		if (search->request.count > range_len) {
+			search->request.start.hash = items_area.end_hash;
+			search->request.count -= range_len;
+
+#ifdef CONFIG_SSDFS_DEBUG
+			SSDFS_DBG("request.count %u, result.count %u\n",
+				  search->request.count,
+				  search->result.count);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+			return -EAGAIN;
+		}
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	ssdfs_check_shdict_btree_node_consistency(node);
+	ssdfs_debug_btree_node_object(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_delete_item() - delete an item from node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to delete an item from the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_shared_dict_btree_node_delete_item(struct ssdfs_btree_node *node,
+					     struct ssdfs_btree_search *search)
+{
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+
+	BUG_ON(search->result.count != 1);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = __ssdfs_shared_dict_btree_node_delete_range(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to delete the name: err %d\n",
+			  err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_delete_range() - delete range of items from node
+ * @node: pointer on node object
+ * @search: pointer on search request object
+ *
+ * This method tries to delete a range of items from the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_shared_dict_btree_node_delete_range(struct ssdfs_btree_node *node,
+					      struct ssdfs_btree_search *search)
+{
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_hash %llx, end_hash %llx, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  search->request.start.hash, search->request.end.hash,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = __ssdfs_shared_dict_btree_node_delete_range(node, search);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to delete the range: err %d\n",
+			  err);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * ssdfs_prepare_prefix_for_name() - prepare a prefix for the name
+ * @node: node object
+ * @lookup2_area: lookup2 area's descriptor
+ * @hash_area: hash area's descriptor
+ * @name: name's string descriptor
+ * @range: pointer on found strings range [out]
+ *
+ * This method tries to prepare a prefix for the name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ */
+#ifdef CONFIG_SSDFS_UNDER_DEVELOPMENT_FUNC
+static
+int ssdfs_prepare_prefix_for_name(struct ssdfs_btree_node *node,
+			struct ssdfs_btree_node_index_area *lookup2_area,
+			struct ssdfs_btree_node_index_area *hash_area,
+			struct ssdfs_name_string *name,
+			struct ssdfs_strings_range_descriptor *range)
+{
+	u16 hash_index, prefix_index;
+	u16 table_size;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !lookup2_area || !hash_area || !name || !range);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_index = name->right_name.index;
+	table_size = lookup2_area->index_count;
+
+do_hash_index_compare:
+	res = ssdfs_hash_index_compare(hash_index, &range->desc);
+	if (res < 0) {
+		SSDFS_ERR("invalid strings_range: "
+			  "hash_index %u, range (start %u, str_count %u)\n",
+			  hash_index,
+			  le16_to_cpu(range->desc.hash_index),
+			  range->desc.str_count);
+		return -ERANGE;
+	} else if (res > 0) {
+		range->index++;
+
+		if (range->index >= table_size) {
+			SSDFS_ERR("range->index %u >= table_size %u\n",
+				  range->index, table_size);
+			return -ERANGE;
+		}
+
+		err = ssdfs_get_lookup2_table_search_key(node, range->index,
+				(union ssdfs_shdict_search_key *)&range->desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  range->index, err);
+			return err;
+		} else
+			goto do_hash_index_compare;
+	}
+
+	prefix_index = le16_to_cpu(range->desc.hash_index);
+	err = ssdfs_get_hash_descriptor(node, hash_area,
+					prefix_index,
+					&name->prefix.desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  prefix_index, err);
+		return err;
+	}
+
+	switch (name->prefix.desc.type) {
+	case SSDFS_NAME_PREFIX:
+	case SSDFS_FULL_NAME:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid descriptor type %#x\n",
+			  name->prefix.desc.type);
+		return -ERANGE;
+	}
+
+	name->prefix.index = prefix_index;
+	ssdfs_memcpy(&name->strings_range,
+		     0, sizeof(struct ssdfs_strings_range_descriptor),
+		     range,
+		     0, sizeof(struct ssdfs_strings_range_descriptor),
+		     sizeof(struct ssdfs_strings_range_descriptor));
+
+	return 0;
+}
+#endif /* CONFIG_SSDFS_UNDER_DEVELOPMENT_FUNC */
+
+/*
+ * ssdfs_lookup2_index_compare() - compare lookup2 index with lookup1 descriptor
+ * @lookup2_index: lookup2 index
+ * @desc: lookup1 descriptor
+ *
+ * This method compares the lookup2 index with the range of indexes
+ * that is contained in the lookup1 descriptor.
+ *
+ * RETURN:
+ * -1 - lookup2_index is outside the range (lesser)
+ *  0 - lookup2_index is inside the range
+ *  1 - lookup2_index is outside the range (greater)
+ */
+static inline
+int ssdfs_lookup2_index_compare(u16 lookup2_index,
+				struct ssdfs_shdict_ltbl1_item *desc)
+{
+	u16 range_start, range_end;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!desc);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	range_start = le16_to_cpu(desc->start_index);
+	range_end = range_start + le16_to_cpu(desc->range_len);
+
+	if (lookup2_index < range_start)
+		return -1;
+	else if (lookup2_index >= range_start && lookup2_index < range_end)
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * ssdfs_prepare_lookup1_for_name() - prepare the lookup1 descriptor for a name
+ * @node: pointer on node object
+ * @name: pointer on name string descriptor
+ * @lookup: pointer on lookup1 descriptor [out]
+ *
+ * This method tries to prepare the lookup1 descriptor for the name.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ENODATA    - lookup1 table is empty.
+ * %-ERANGE     - internal error.
+ */
+#ifdef CONFIG_SSDFS_UNDER_DEVELOPMENT_FUNC
+static
+int ssdfs_prepare_lookup1_for_name(struct ssdfs_btree_node *node,
+				   struct ssdfs_name_string *name,
+				   struct ssdfs_lookup_descriptor *lookup)
+{
+	u16 lookup2_index;
+	u16 table_size;
+	int res;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !name || !lookup);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u\n", node->node_id);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	table_size = le16_to_cpu(node->raw.dict_header.lookup_table1_items);
+
+	if (table_size == 0) {
+		SSDFS_DBG("lookup1 table is empty\n");
+		return -ENODATA;
+	}
+
+	if (table_size > SSDFS_SHDIC_LTBL1_SIZE) {
+		SSDFS_ERR("invalid table_size %u\n",
+			  table_size);
+		return -ERANGE;
+	}
+
+	lookup2_index = name->strings_range.index;
+
+	if (lookup2_index >= U16_MAX) {
+		SSDFS_ERR("invalid lookup2 index\n");
+		return -ERANGE;
+	}
+
+do_lookup2_index_compare:
+	res = ssdfs_lookup2_index_compare(lookup2_index, &lookup->desc);
+	if (res < 0) {
+		SSDFS_ERR("invalid lookup: "
+			  "lookup2_index %u, "
+			  "range (start_index %u, range_len %u)\n",
+			  lookup2_index,
+			  le16_to_cpu(lookup->desc.start_index),
+			  le16_to_cpu(lookup->desc.range_len));
+		return -ERANGE;
+	} else if (res > 0) {
+		lookup->index++;
+
+		if (lookup->index >= table_size) {
+			SSDFS_ERR("lookup->index %u >= table_size %u\n",
+				  lookup->index, table_size);
+			return -ERANGE;
+		}
+
+		err = ssdfs_get_lookup1_table_search_key(node, lookup->index,
+					    SSDFS_SEARCH_KEY(&lookup->desc));
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup1 descriptor: "
+				  "index %u, err %d\n",
+				  lookup->index, err);
+			return err;
+		} else
+			goto do_lookup2_index_compare;
+	}
+
+	ssdfs_memcpy(&name->lookup,
+		     0, sizeof(struct ssdfs_lookup_descriptor),
+		     lookup,
+		     0, sizeof(struct ssdfs_lookup_descriptor),
+		     sizeof(struct ssdfs_lookup_descriptor));
+
+	return 0;
+}
+#endif /* CONFIG_SSDFS_UNDER_DEVELOPMENT_FUNC */
+
+/*
+ * ssdfs_shared_dict_btree_node_extract_range() - extract range of items from node
+ * @node: pointer on node object
+ * @start_index: starting index of the range
+ * @count: count of items in the range
+ * @search: pointer on search request object
+ *
+ * This method tries to extract a range of items from the node.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ * %-ENOMEM     - fail to allocate memory.
+ * %-ENODATA    - no such range in the node.
+ */
+static
+int ssdfs_shared_dict_btree_node_extract_range(struct ssdfs_btree_node *node,
+					       u16 start_index, u16 count,
+					       struct ssdfs_btree_search *search)
+{
+	struct ssdfs_btree_node_items_area items_area;
+	struct ssdfs_btree_node_index_area lookup_tbl_area;
+	struct ssdfs_btree_node_index_area hash_tbl_area;
+	struct ssdfs_shdict_htbl_item hash_desc;
+	size_t hdesc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	struct ssdfs_shdict_ltbl2_item ltbl2_desc;
+	size_t l2desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	struct ssdfs_name_string_range *name_range;
+	struct ssdfs_btree_search_buffer *buf;
+	size_t ltbl2_size;
+	u32 htbl_offset;
+	size_t htbl_size;
+	size_t str_buf_size;
+	u16 lookup2_index;
+	u16 hash_index;
+	u16 end_index;
+	u32 offset1 = U32_MAX;
+	u32 offset2 = U32_MAX;
+	u64 hash1 = U64_MAX;
+	u64 hash2 = U64_MAX;
+	u16 items_count;
+	int i;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !node->tree || !search);
+
+	SSDFS_DBG("type %#x, flags %#x, "
+		  "start_index %u, count %u, "
+		  "state %#x, node_id %u, height %u, "
+		  "parent %p, child %p\n",
+		  search->request.type, search->request.flags,
+		  start_index, count,
+		  atomic_read(&node->state), node->node_id,
+		  atomic_read(&node->height), search->node.parent,
+		  search->node.child);
+
+	ssdfs_check_shdict_btree_node_consistency(node);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->items_area.state)) {
+	case SSDFS_BTREE_NODE_ITEMS_AREA_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid items_area state %#x\n",
+			  atomic_read(&node->items_area.state));
+		return -ERANGE;
+	}
+
+	down_read(&node->header_lock);
+	ssdfs_memcpy(&items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     &node->items_area,
+		     0, sizeof(struct ssdfs_btree_node_items_area),
+		     sizeof(struct ssdfs_btree_node_items_area));
+	ssdfs_memcpy(&lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->lookup_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	ssdfs_memcpy(&hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     &node->hash_tbl_area,
+		     0, sizeof(struct ssdfs_btree_node_index_area),
+		     sizeof(struct ssdfs_btree_node_index_area));
+	up_read(&node->header_lock);
+
+	if (items_area.items_capacity == 0 ||
+	    items_area.items_capacity < items_area.items_count) {
+		SSDFS_ERR("invalid items accounting: "
+			  "node_id %u, items_capacity %u, items_count %u\n",
+			  search->node.id,
+			  items_area.items_capacity,
+			  items_area.items_count);
+		return -ERANGE;
+	}
+
+	if (count == 0) {
+		SSDFS_ERR("empty request\n");
+		return -ERANGE;
+	}
+
+	if (start_index >= items_area.items_count) {
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("start_index %u >= items_count %u\n",
+			  start_index, items_area.items_count);
+#endif /* CONFIG_SSDFS_DEBUG */
+		return -ENODATA;
+	}
+
+	if ((start_index + count) > items_area.items_count)
+		count = items_area.items_count - start_index;
+
+	down_read(&node->full_lock);
+
+	/* correct start index */
+	hash_index = start_index;
+	while (hash_index >= 0) {
+		err = ssdfs_get_hash_descriptor(node, &hash_tbl_area,
+						hash_index, &hash_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  hash_index, err);
+			goto finish_extract_range;
+		}
+
+		if (hash_desc.type == SSDFS_NAME_SUFFIX) {
+			hash_index--;
+			start_index = hash_index;
+			count++;
+		} else
+			break;
+	}
+
+	/* correct count of items */
+	hash_index = start_index + count;
+	while (hash_index < items_area.items_count) {
+		err = ssdfs_get_hash_descriptor(node, &hash_tbl_area,
+						hash_index, &hash_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  hash_index, err);
+			goto finish_extract_range;
+		}
+
+		if (hash_desc.type == SSDFS_NAME_SUFFIX) {
+			hash_index++;
+			count++;
+		} else
+			break;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("corrected: start_index %u, count %u\n",
+		  start_index, count);
+	BUG_ON(count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash_index = start_index;
+	err = ssdfs_get_hash_descriptor(node, &hash_tbl_area,
+					hash_index, &hash_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  hash_index, err);
+		goto finish_extract_range;
+	}
+
+	offset1 = le16_to_cpu(hash_desc.str_offset);
+	hash1 = le64_to_cpu(hash_desc.hash);
+
+	hash_index = start_index + count - 1;
+	err = ssdfs_get_hash_descriptor(node, &hash_tbl_area,
+					hash_index, &hash_desc);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get hash descriptor: "
+			  "index %u, err %d\n",
+			  hash_index, err);
+		goto finish_extract_range;
+	}
+
+	offset2 = le16_to_cpu(hash_desc.str_offset) + hash_desc.str_len;
+	hash2 = le64_to_cpu(hash_desc.hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(offset1 >= offset2);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	str_buf_size = offset2 - offset1;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(str_buf_size == 0);
+	BUG_ON(str_buf_size > items_area.area_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	htbl_size = count * hdesc_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(htbl_size == 0);
+	BUG_ON(htbl_size > hash_tbl_area.area_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	ltbl2_size = count * l2desc_size;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(ltbl2_size == 0);
+	BUG_ON(ltbl2_size > lookup_tbl_area.area_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (search->result.range_buf.state) {
+	case SSDFS_BTREE_SEARCH_UNKNOWN_BUFFER_STATE:
+		err = ssdfs_btree_search_alloc_result_name_range(search,
+								 ltbl2_size,
+								 htbl_size,
+								 str_buf_size);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to allocate buffer\n");
+			goto finish_extract_range;
+		}
+		break;
+
+	case SSDFS_BTREE_SEARCH_INLINE_BUFFER:
+		ssdfs_btree_search_free_result_name_range(search);
+		err = ssdfs_btree_search_alloc_result_name_range(search,
+								 ltbl2_size,
+								 htbl_size,
+								 str_buf_size);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to allocate buffer\n");
+			goto finish_extract_range;
+		}
+		break;
+
+	default:
+		err = -ERANGE;
+		SSDFS_ERR("invalid name_range_state %#x\n",
+			  search->result.range_buf.state);
+		goto finish_extract_range;
+	}
+
+	name_range = search->result.range_buf.place.name_range;
+	buf = &name_range->lookup2_table.buf;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	end_index = start_index + count - 1;
+	name_range->lookup2_table.index = U16_MAX;
+
+	for (i = 0; i < lookup_tbl_area.index_count; i++) {
+		u32 iter_offset;
+		u64 cur_hash;
+
+		err = ssdfs_get_lookup2_descriptor(node, &lookup_tbl_area,
+						   i, &ltbl2_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get lookup2 descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			goto finish_extract_range;
+		}
+
+		hash_index = le16_to_cpu(ltbl2_desc.hash_index);
+
+		if (hash_index < start_index || hash_index > end_index) {
+			/* skip lookup2 item */
+			continue;
+		}
+
+		if (name_range->lookup2_table.index >= U16_MAX)
+			name_range->lookup2_table.index = i;
+
+		iter_offset = buf->items_count * l2desc_size;
+		err = ssdfs_memcpy(buf->place.ltbl2_items,
+				   iter_offset, buf->size,
+				   &ltbl2_desc,
+				   0, l2desc_size,
+				   l2desc_size);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to copy: err %d\n", err);
+			goto finish_extract_range;
+		}
+
+		cur_hash = le64_to_cpu(ltbl2_desc.hash);
+
+		if (hash1 >= U64_MAX)
+			hash1 = cur_hash;
+		else if (cur_hash < hash1)
+			hash1 = cur_hash;
+
+		if (hash2 >= U64_MAX)
+			hash2 = cur_hash;
+		else if (cur_hash > hash2)
+			hash2 = cur_hash;
+
+		buf->items_count++;
+
+		if (buf->items_count == count) {
+			/* all lookup2 items have been copied */
+			break;
+		}
+	}
+
+	if (buf->items_count != count) {
+		err = -ERANGE;
+		SSDFS_ERR("fail to extract lookup2 descriptors: "
+			  "requested count %u, extracted count %u\n",
+			  count, buf->items_count);
+		goto finish_extract_range;
+	}
+
+	lookup2_index = name_range->lookup2_table.index;
+	name_range->lookup1.index =
+		ssdfs_convert_lookup2_to_lookup1_index(lookup2_index);
+
+	down_read(&node->header_lock);
+	err = ssdfs_get_lookup1_table_search_key(node,
+				name_range->lookup1.index,
+				SSDFS_SEARCH_KEY(&name_range->lookup1.desc));
+	up_read(&node->header_lock);
+
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to get lookup1 key: "
+			  "index %u, err %d\n",
+			  name_range->lookup1.index, err);
+		goto finish_extract_range;
+	}
+
+	buf = &name_range->hash_table.buf;
+	name_range->hash_table.index = start_index;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	htbl_offset = (u32)start_index * hdesc_size;
+	htbl_offset += hash_tbl_area.offset;
+
+	err = ssdfs_btree_node_read_content(node,
+					    htbl_offset,
+					    htbl_size,
+					    buf->place.htbl_items,
+					    buf->size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to read node's content: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		goto finish_extract_range;
+	}
+
+	buf->items_count = count;
+
+	buf = &name_range->strings.buf;
+	offset1 += items_area.offset;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(buf->state != SSDFS_BTREE_SEARCH_EXTERNAL_BUFFER);
+	SSDFS_DBG("offset1 %u, str_buf_size %zu\n",
+		  offset1, str_buf_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	err = ssdfs_btree_node_read_content(node,
+					    offset1,
+					    str_buf_size,
+					    buf->place.ptr,
+					    buf->size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to read node's content: "
+			  "node_id %u, err %d\n",
+			  node->node_id, err);
+		goto finish_extract_range;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("STRINGS BLOB DUMP\n");
+	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+			     buf->place.ptr, buf->size);
+	SSDFS_DBG("\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+finish_extract_range:
+	up_read(&node->full_lock);
+
+	if (unlikely(err)) {
+		search->result.state = SSDFS_BTREE_SEARCH_FAILURE;
+		search->result.err = err;
+	} else {
+		search->request.flags =
+			SSDFS_BTREE_SEARCH_HAS_VALID_HASH_RANGE |
+			SSDFS_BTREE_SEARCH_HAS_VALID_COUNT;
+		search->request.start.hash = hash1;
+		search->request.end.hash = hash2;
+		search->request.count = count;
+
+		search->result.flags &= ~SSDFS_BTREE_SEARCH_RESULT_HAS_NAME;
+		search->result.flags |= SSDFS_BTREE_SEARCH_RESULT_HAS_RANGE;
+		search->result.count = count;
+		search->result.state = SSDFS_BTREE_SEARCH_VALID_ITEM;
+		search->result.start_index = start_index;
+	}
+
+	buf = &name_range->hash_table.buf;
+	items_count = buf->items_count;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(items_count == 0);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	hash1 = le64_to_cpu(buf->place.htbl_items[0].hash);
+	hash2 = le64_to_cpu(buf->place.htbl_items[items_count - 1].hash);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("start_hash %#llx, end_hash %#llx, items_count %u\n",
+		  hash1, hash2, items_count);
+
+	SSDFS_DBG("DEBUG SEARCH RESULT NAME:\n");
+	ssdfs_debug_btree_search_result_name(search);
+	SSDFS_DBG("END DEBUG OUTPUT\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_resize_items_area() - resize items area of the node
+ * @node: node object
+ * @new_size: new size of the items area
+ *
+ * This method tries to resize the items area of the node.
+ *
+ * TODO: It makes sense to allocate the bitmap with taking into
+ *       account that we will resize the node. So, it needs
+ *       to allocate the index area in bitmap is equal to
+ *       the whole node and items area is equal to the whole node.
+ *       This technique provides opportunity not to resize or
+ *       to shift the content of the bitmap.
+ *
+ * RETURN:
+ * [success]
+ * [failure] - error code:
+ *
+ * %-ERANGE     - internal error.
+ * %-EFAULT     - node is corrupted.
+ */
+static
+int ssdfs_shared_dict_btree_resize_items_area(struct ssdfs_btree_node *node,
+						u32 new_size)
+{
+	size_t hdr_size = sizeof(struct ssdfs_shared_dictionary_node_header);
+	u32 area_offset;
+	u32 area_size;
+	u32 free_space;
+	u32 diff;
+	u32 index_size;
+	u32 new_index_capacity;
+	u16 items_capacity;
+	unsigned long index_start_bit;
+	unsigned long item_start_bit;
+	unsigned long bits_count;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node);
+	BUG_ON(!rwsem_is_locked(&node->full_lock));
+	BUG_ON(!rwsem_is_locked(&node->header_lock));
+
+	SSDFS_DBG("node_id %u, new_size %u\n",
+		  node->node_id, new_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	switch (atomic_read(&node->state)) {
+	case SSDFS_BTREE_NODE_INITIALIZED:
+	case SSDFS_BTREE_NODE_DIRTY:
+		/* expected state */
+		break;
+
+	case SSDFS_BTREE_NODE_CORRUPTED:
+		SSDFS_WARN("node %u is corrupted\n",
+			   node->node_id);
+		return -EFAULT;
+
+	default:
+		SSDFS_ERR("invalid node state %#x\n",
+			  atomic_read(&node->state));
+		return -ERANGE;
+	}
+
+	down_write(&node->bmap_array.lock);
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("ITEMS_AREA (area_offset %u, area_size %u, free_space %u), "
+		  "LOOKUP_AREA (area_offset %u, area_size %u), "
+		  "HASH_AREA (area_offset %u, area_size %u)\n",
+		  node->items_area.offset,
+		  node->items_area.area_size,
+		  node->items_area.free_space,
+		  node->lookup_tbl_area.offset,
+		  node->lookup_tbl_area.area_size,
+		  node->hash_tbl_area.offset,
+		  node->hash_tbl_area.area_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (area_size < free_space) {
+		err = -EFAULT;
+		SSDFS_ERR("area_size %u < free_space %u\n",
+			  area_size, free_space);
+		goto finish_area_resize;
+	}
+
+	if ((area_size - free_space) > new_size) {
+		err = -ERANGE;
+		SSDFS_ERR("fail to resize items area: "
+			  "area_size %u, free_space %u, new_size %u\n",
+			  area_size, free_space, new_size);
+		goto finish_area_resize;
+	}
+
+	if (new_size == 0) {
+		area_offset = node->node_size;
+		area_size = 0;
+	} else if (area_size < new_size) {
+		diff = new_size - area_size;
+
+		if (area_offset <= diff) {
+			err = -ERANGE;
+			SSDFS_ERR("area_offset %u <= diff %u\n",
+				  area_offset, diff);
+			goto finish_area_resize;
+		}
+
+		area_offset -= diff;
+
+		if (area_offset < hdr_size) {
+			err = -ERANGE;
+			SSDFS_ERR("area_offset %u < hdr_size %zu\n",
+				  area_offset, hdr_size);
+			goto finish_area_resize;
+		}
+
+		area_size += diff;
+	} else if (area_size > new_size) {
+		diff = area_size - new_size;
+		area_offset += diff;
+		area_size -= diff;
+	} else {
+		err = 0;
+#ifdef CONFIG_SSDFS_DEBUG
+		SSDFS_DBG("area_size %u == new_size %u\n",
+			  area_size, new_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+		goto finish_area_resize;
+	}
+
+	err = ssdfs_resize_string_area(node, area_offset, area_size);
+	if (unlikely(err)) {
+		SSDFS_ERR("fail to resize the items area: "
+			  "node_id %u, area_offset %u, "
+			  "area_size %u, err %d\n",
+			  node->node_id, area_offset,
+			  area_size, err);
+		goto finish_area_resize;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("STRINGS AREA RESIZED: "
+		  "ITEMS_AREA (area_offset %u, area_size %u, free_space %u), "
+		  "LOOKUP_AREA (area_offset %u, area_size %u), "
+		  "HASH_AREA (area_offset %u, area_size %u)\n",
+		  node->items_area.offset,
+		  node->items_area.area_size,
+		  node->items_area.free_space,
+		  node->lookup_tbl_area.offset,
+		  node->lookup_tbl_area.area_size,
+		  node->hash_tbl_area.offset,
+		  node->hash_tbl_area.area_size);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (node->index_area.offset >= node->items_area.offset) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize: "
+			  "index_area.offset %u, items_area.offset %u\n",
+			  node->node_id,
+			  node->index_area.offset,
+			  node->items_area.offset);
+		goto finish_area_resize;
+	}
+
+	diff = node->items_area.offset - node->index_area.offset;
+	index_size = node->index_area.index_size;
+
+	if (diff % index_size) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize: "
+			  "index_area.offset %u, items_area.offset %u, "
+			  "index_size %u, diff %u\n",
+			  node->node_id,
+			  node->index_area.offset,
+			  node->items_area.offset,
+			  index_size, diff);
+		goto finish_area_resize;
+	}
+
+	new_index_capacity = diff / index_size;
+
+	if (node->index_area.index_count > new_index_capacity) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize: "
+			  "index_area.offset %u, items_area.offset %u, "
+			  "index_size %u, diff %u, "
+			  "index_count %u, new_index_capacity %u\n",
+			  node->node_id,
+			  node->index_area.offset,
+			  node->items_area.offset,
+			  index_size, diff,
+			  node->index_area.index_count,
+			  new_index_capacity);
+		goto finish_area_resize;
+	}
+
+	node->bmap_array.item_start_bit =
+			node->bmap_array.index_start_bit + new_index_capacity;
+
+	items_capacity = node->items_area.items_capacity;
+	index_start_bit = node->bmap_array.index_start_bit;
+	item_start_bit = node->bmap_array.item_start_bit;
+
+	node->bmap_array.bits_count = new_index_capacity + items_capacity + 1;
+	bits_count = node->bmap_array.bits_count;
+
+	if ((index_start_bit + new_index_capacity) > item_start_bit) {
+		err = -ERANGE;
+		atomic_set(&node->state,
+				SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid shift: "
+			  "index_start_bit %lu, new_index_capacity %u, "
+			  "item_start_bit %lu\n",
+			  index_start_bit, new_index_capacity,
+			  item_start_bit);
+		goto finish_area_resize;
+	}
+
+	if ((index_start_bit + new_index_capacity) > bits_count) {
+		err = -ERANGE;
+		atomic_set(&node->state,
+				SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid shift: "
+			  "index_start_bit %lu, new_index_capacity %u, "
+			  "bits_count %lu\n",
+			  index_start_bit, new_index_capacity, bits_count);
+		goto finish_area_resize;
+	}
+
+	if ((item_start_bit + items_capacity) > bits_count) {
+		err = -ERANGE;
+		atomic_set(&node->state,
+				SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("invalid shift: "
+			  "item_start_bit %lu, items_capacity %u, "
+			  "bits_count %lu\n",
+			  item_start_bit, items_capacity, bits_count);
+		goto finish_area_resize;
+	}
+
+	if (is_ssdfs_resized_node_corrupted(node)) {
+		err = -ERANGE;
+		atomic_set(&node->state, SSDFS_BTREE_NODE_CORRUPTED);
+		SSDFS_ERR("node %u has been corrupted during resize\n",
+			  node->node_id);
+		goto finish_area_resize;
+	}
+
+	atomic_set(&node->state, SSDFS_BTREE_NODE_DIRTY);
+
+	area_offset = node->items_area.offset;
+	area_size = node->items_area.area_size;
+	free_space = node->items_area.free_space;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("area_offset %u, area_size %u, free_space %u\n",
+		  area_offset, area_size, free_space);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+finish_area_resize:
+	up_write(&node->bmap_array.lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("finished: err %d\n", err);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	return err;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_left_items() - estimate number of items
+ * @node: pointer on node object
+ * @threshold: upper bound of items' index
+ * @free_space: free space in bytes [in|out]
+ *
+ * This method tries to estimate number of items from the left
+ * side of the node for requested free space. Also, it returns
+ * calculated amount of freeing space.
+ *
+ * RETURN:
+ * [success] - calculated number of items + real amount of freeing space.
+ * [failure] - error code:
+ *
+ * %-EINVAL     - invalid input.
+ * %-ERANGE     - internal error.
+ */
+int ssdfs_shared_dict_btree_node_left_items(struct ssdfs_btree_node *node,
+					    u32 threshold,
+					    u16 *free_space)
+{
+	struct ssdfs_shdict_htbl_item cur_desc;
+	size_t lookup2_desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t hash_desc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u16 items_count;
+	u32 total_len = 0;
+	int calculated_items = 0;
+	u16 i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !free_space);
+
+	SSDFS_DBG("node_id %u, free_space %u\n",
+		  node->node_id, *free_space);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (*free_space == 0) {
+		SSDFS_ERR("invalid free space %u\n", *free_space);
+		return -EINVAL;
+	}
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	down_read(&node->full_lock);
+
+	down_read(&node->header_lock);
+	items_count = node->hash_tbl_area.index_count;
+	up_read(&node->header_lock);
+
+	items_count = min_t(u16, (u16)threshold, items_count);
+
+	if (items_count == 0) {
+		*free_space = 0;
+		calculated_items = 0;
+		goto finish_estimate_items;
+	}
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("items_count %u, threshold %u\n",
+		  items_count, threshold);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	for (i = 0; i < items_count; i++) {
+		u32 iter_len;
+
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			calculated_items = err;
+			goto finish_estimate_items;
+		}
+
+		iter_len = cur_desc.str_len;
+		iter_len += lookup2_desc_size;
+		iter_len += hash_desc_size;
+
+		if ((total_len + iter_len) > *free_space)
+			break;
+
+		total_len += iter_len;
+		calculated_items++;
+
+		if (total_len == *free_space)
+			break;
+	}
+
+finish_estimate_items:
+	up_read(&node->full_lock);
+
+#ifdef CONFIG_SSDFS_DEBUG
+	SSDFS_DBG("calculated_items %u, total_len %u\n",
+		  calculated_items, total_len);
+	BUG_ON(calculated_items >= threshold);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	*free_space = total_len;
+	return calculated_items;
+}
+
+/*
+ * ssdfs_shared_dict_btree_node_right_items() - estimate number of items
+ * @node: pointer on node object
+ * @threshold: upper bound of items' index
+ * @free_space: free space in bytes [in|out]
+ *
+ * This method tries to estimate number of items from the right
+ * side of the node for requested free space. Also, it returns
+ * calculated amount of freeing space.
+ *
+ * RETURN:
+ * [success] - calculated number of items + real amount of freeing space.
+ * [failure] - error code:
+ *
+ * %-EINVAL     - invalid input.
+ * %-ERANGE     - internal error.
+ */
+int ssdfs_shared_dict_btree_node_right_items(struct ssdfs_btree_node *node,
+					     u32 threshold,
+					     u16 *free_space)
+{
+	struct ssdfs_shdict_htbl_item cur_desc;
+	size_t lookup2_desc_size = sizeof(struct ssdfs_shdict_ltbl2_item);
+	size_t hash_desc_size = sizeof(struct ssdfs_shdict_htbl_item);
+	u16 items_count;
+	u32 total_len = 0;
+	int calculated_items = 0;
+	int i;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!node || !free_space);
+
+	SSDFS_DBG("node_id %u, free_space %u\n",
+		  node->node_id, *free_space);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	if (*free_space == 0) {
+		SSDFS_ERR("invalid free space %u\n", *free_space);
+		return -EINVAL;
+	}
+
+	switch (atomic_read(&node->hash_tbl_area.state)) {
+	case SSDFS_BTREE_NODE_HASH_TBL_EXIST:
+		/* expected state */
+		break;
+
+	default:
+		SSDFS_ERR("invalid hash_tbl_area state %#x\n",
+			  atomic_read(&node->hash_tbl_area.state));
+		return -ERANGE;
+	}
+
+	down_read(&node->full_lock);
+
+	down_read(&node->header_lock);
+	items_count = node->hash_tbl_area.index_count;
+	up_read(&node->header_lock);
+
+	if (items_count == 0) {
+		calculated_items = 0;
+		goto finish_estimate_items;
+	}
+
+	for (i = items_count - 1; i >= threshold; i--) {
+		u32 iter_len;
+
+		err = ssdfs_get_hash_descriptor(node, &node->hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "index %u, err %d\n",
+				  i, err);
+			calculated_items = err;
+			goto finish_estimate_items;
+		}
+
+		iter_len = cur_desc.str_len;
+		iter_len += lookup2_desc_size;
+		iter_len += hash_desc_size;
+
+		if ((total_len + iter_len) > *free_space)
+			break;
+
+		total_len += iter_len;
+		calculated_items++;
+
+		if (total_len == *free_space)
+			break;
+	}
+
+finish_estimate_items:
+	up_read(&node->full_lock);
+
+	*free_space = total_len;
+	return calculated_items;
+}
+
+void ssdfs_debug_shdict_btree_object(struct ssdfs_shared_dict_btree_info *tree)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	struct list_head *this, *next;
+	struct ssdfs_btree_index *index;
+	struct ssdfs_raw_extent *extent;
+
+	BUG_ON(!tree);
+
+	SSDFS_DBG("SHARED DICTIONARY: state %#x, is_locked %d, "
+		  "read_reqs %d\n",
+		  atomic_read(&tree->state),
+		  rwsem_is_locked(&tree->lock),
+		  atomic_read(&tree->read_reqs));
+
+	ssdfs_debug_btree_object(&tree->generic_tree);
+
+	spin_lock(&tree->requests.queue.lock);
+	if (!list_empty_careful(&tree->requests.queue.list)) {
+		SSDFS_DBG("NAME REQUESTS:\n");
+
+		list_for_each_safe(this, next, &tree->requests.queue.list) {
+			struct ssdfs_name_info *ni;
+
+			ni = list_entry(this, struct ssdfs_name_info, list);
+
+			if (ni) {
+				switch (ni->type) {
+				case SSDFS_NAME_ADD:
+				case SSDFS_NAME_CHANGE:
+				case SSDFS_NAME_DELETE:
+					SSDFS_DBG("NAME: op_type %#x, "
+						  "hash %llx, len %zu\n",
+						   ni->type,
+						   ni->desc.name.hash,
+						   ni->desc.name.len);
+
+					SSDFS_DBG("STRING DUMP:\n");
+					print_hex_dump_bytes("",
+							DUMP_PREFIX_OFFSET,
+							ni->desc.name.str_buf,
+							SSDFS_MAX_NAME_LEN);
+					SSDFS_DBG("\n");
+					break;
+
+				case SSDFS_INIT_SHDICT_NODE:
+					index = &ni->desc.index;
+					extent = &index->extent;
+					SSDFS_DBG("NODE_INDEX: hash %llx, "
+						  "seg_id %llu, "
+						  "logical_blk %u, "
+						  "len %u\n",
+					    le64_to_cpu(index->hash),
+					    le64_to_cpu(extent->seg_id),
+					    le32_to_cpu(extent->logical_blk),
+					    le32_to_cpu(extent->len));
+					break;
+
+				default:
+					/* do nothing */
+					break;
+				}
+			}
+		}
+
+		SSDFS_DBG("\n");
+	}
+	spin_unlock(&tree->requests.queue.lock);
+
+	SSDFS_DBG("WAIT_QUEUE: is_active %d\n",
+		  waitqueue_active(&tree->wait_queue));
+#endif /* CONFIG_SSDFS_DEBUG */
+}
+
+void ssdfs_debug_btree_search_result_name(struct ssdfs_btree_search *search)
+{
+#ifdef CONFIG_SSDFS_DEBUG
+	struct ssdfs_shdict_ltbl2_item *ltbl2_item;
+	struct ssdfs_name_string_range *name_range;
+	struct ssdfs_btree_search_buffer *buf;
+	u8 *kaddr;
+	size_t item_size;
+	size_t count;
+	size_t bytes_count;
+	int i;
+
+	BUG_ON(!search);
+
+	SSDFS_DBG("REQUEST: type %#x, flags %#x, count %u, "
+		  "START: name %p, name_len %zu, hash %#llx, ino %llu, "
+		  "END: name %p, name_len %zu, hash %#llx, ino %llu\n",
+		  search->request.type,
+		  search->request.flags,
+		  search->request.count,
+		  search->request.start.name,
+		  search->request.start.name_len,
+		  search->request.start.hash,
+		  search->request.start.ino,
+		  search->request.end.name,
+		  search->request.end.name_len,
+		  search->request.end.hash,
+		  search->request.end.ino);
+
+	SSDFS_DBG("RESULT: state %#x, err %d, flags %#x, start_index %u, count %u, "
+		  "search_cno %llu\n",
+		  search->result.state,
+		  search->result.err,
+		  search->result.flags,
+		  search->result.start_index,
+		  search->result.count,
+		  search->result.search_cno);
+
+	SSDFS_DBG("NAME: buf_state %#x, name %p, "
+		  "buf_size %zu, items_count %u\n",
+		  search->result.name_buf.state,
+		  search->result.name_buf.place.name,
+		  search->result.name_buf.size,
+		  search->result.name_buf.items_count);
+
+	buf = &search->result.name_buf;
+
+	if (buf->place.name) {
+		SSDFS_DBG("LOOKUP: index %u, hash %#x, "
+			  "start_index %u, range_len %u\n",
+			  buf->place.name->lookup.index,
+			  le32_to_cpu(buf->place.name->lookup.desc.hash_lo),
+			  le16_to_cpu(buf->place.name->lookup.desc.start_index),
+			  le16_to_cpu(buf->place.name->lookup.desc.range_len));
+
+		ltbl2_item = &buf->place.name->strings_range.desc;
+		SSDFS_DBG("STRINGS_RANGE: index %u, hash %#llx, "
+			  "prefix_len %u, str_count %u, "
+			  "hash_index %u\n",
+			  buf->place.name->strings_range.index,
+			  le64_to_cpu(ltbl2_item->hash),
+			  ltbl2_item->prefix_len,
+			  ltbl2_item->str_count,
+			  le16_to_cpu(ltbl2_item->hash_index));
+
+		SSDFS_DBG("PREFIX: index %u, hash_hi %#llx, "
+			  "str_offset %u, str_len %u, type %#x\n",
+			  buf->place.name->prefix.index,
+			  le64_to_cpu(buf->place.name->prefix.desc.hash),
+			  le16_to_cpu(buf->place.name->prefix.desc.str_offset),
+			  buf->place.name->prefix.desc.str_len,
+			  buf->place.name->prefix.desc.type);
+
+		SSDFS_DBG("LEFT_NAME: index %u, hash %#llx, "
+			  "str_offset %u, str_len %u, type %#x\n",
+			  buf->place.name->left_name.index,
+			  le64_to_cpu(buf->place.name->left_name.desc.hash),
+			  le16_to_cpu(buf->place.name->left_name.desc.str_offset),
+			  buf->place.name->left_name.desc.str_len,
+			  buf->place.name->left_name.desc.type);
+
+		SSDFS_DBG("RIGHT_NAME: index %u, hash %#llx, "
+			  "str_offset %u, str_len %u, type %#x\n",
+			  buf->place.name->right_name.index,
+			  le64_to_cpu(buf->place.name->right_name.desc.hash),
+			  le16_to_cpu(buf->place.name->right_name.desc.str_offset),
+			  buf->place.name->right_name.desc.str_len,
+			  buf->place.name->right_name.desc.type);
+
+		count = search->result.name_buf.items_count;
+
+		if (count > 0)
+			item_size = search->result.name_buf.size / count;
+		else
+			item_size = 0;
+
+		for (i = 0; i < search->result.name_buf.items_count; i++) {
+			struct ssdfs_name_string *name;
+
+			kaddr = (u8 *)search->result.name_buf.place.name +
+								(i * item_size);
+			name = (struct ssdfs_name_string *)kaddr;
+
+			SSDFS_DBG("NAME: index %d, hash %#llx, str_len %zu\n",
+				  i, name->hash, name->len);
+
+			SSDFS_DBG("LOOKUP: index %u, hash %#x, "
+				  "start_index %u, range_len %u\n",
+				  name->lookup.index,
+				  le32_to_cpu(name->lookup.desc.hash_lo),
+				  le16_to_cpu(name->lookup.desc.start_index),
+				  le16_to_cpu(name->lookup.desc.range_len));
+
+			ltbl2_item = &name->strings_range.desc;
+			SSDFS_DBG("STRINGS_RANGE: index %u, hash %#llx, "
+				  "prefix_len %u, str_count %u, "
+				  "hash_index %u\n",
+				  name->strings_range.index,
+				  le64_to_cpu(ltbl2_item->hash),
+				  ltbl2_item->prefix_len,
+				  ltbl2_item->str_count,
+				  le16_to_cpu(ltbl2_item->hash_index));
+
+			SSDFS_DBG("PREFIX: index %u, hash %#llx, "
+				  "str_offset %u, str_len %u, type %#x\n",
+				  name->prefix.index,
+				  le64_to_cpu(name->prefix.desc.hash),
+				  le16_to_cpu(name->prefix.desc.str_offset),
+				  name->prefix.desc.str_len,
+				  name->prefix.desc.type);
+
+			SSDFS_DBG("LEFT_NAME: index %u, hash %#llx, "
+				  "str_offset %u, str_len %u, type %#x\n",
+				  name->left_name.index,
+				  le64_to_cpu(name->left_name.desc.hash),
+				  le16_to_cpu(name->left_name.desc.str_offset),
+				  name->left_name.desc.str_len,
+				  name->left_name.desc.type);
+
+			SSDFS_DBG("RIGHT_NAME: index %u, hash %#llx, "
+				  "str_offset %u, str_len %u, type %#x\n",
+				  name->right_name.index,
+				  le64_to_cpu(name->right_name.desc.hash),
+				  le16_to_cpu(name->right_name.desc.str_offset),
+				  name->right_name.desc.str_len,
+				  name->right_name.desc.type);
+
+			SSDFS_DBG("RAW STRING DUMP: index %d\n",
+				  i);
+			print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+						name->str,
+						name->len);
+			SSDFS_DBG("\n");
+		}
+	}
+
+	SSDFS_DBG("NAME RANGE: buf_state %#x, name_range %p, "
+		  "buf_size %zu, items_count %u\n",
+		  search->result.range_buf.state,
+		  search->result.range_buf.place.name_range,
+		  search->result.range_buf.size,
+		  search->result.range_buf.items_count);
+
+	buf = &search->result.range_buf;
+	name_range = buf->place.name_range;
+
+	if (name_range) {
+		SSDFS_DBG("NAME STRING RANGE: "
+			  "lookup2_table: index %u, (buf_state %#x, items %p, "
+			  "buf_size %zu, items_count %u), "
+			  "hash_table: index %u (buf_state %#x, items %p, "
+			  "buf_size %zu, items_count %u), "
+			  "strings (buf_state %#x, buf %p, "
+			  "buf_size %zu)\n",
+			  name_range->lookup2_table.index,
+			  name_range->lookup2_table.buf.state,
+			  name_range->lookup2_table.buf.place.ltbl2_items,
+			  name_range->lookup2_table.buf.size,
+			  name_range->lookup2_table.buf.items_count,
+			  name_range->hash_table.index,
+			  name_range->hash_table.buf.state,
+			  name_range->hash_table.buf.place.htbl_items,
+			  name_range->hash_table.buf.size,
+			  name_range->hash_table.buf.items_count,
+			  name_range->strings.buf.state,
+			  name_range->strings.buf.place.ptr,
+			  name_range->strings.buf.size);
+
+		SSDFS_DBG("LOOKUP: index %u, hash %#x, "
+			  "start_index %u, range_len %u\n",
+			  name_range->lookup1.index,
+			  le32_to_cpu(name_range->lookup1.desc.hash_lo),
+			  le16_to_cpu(name_range->lookup1.desc.start_index),
+			  le16_to_cpu(name_range->lookup1.desc.range_len));
+
+		buf = &name_range->lookup2_table.buf;
+		if (buf->place.ltbl2_items) {
+			kaddr = (u8 *)buf->place.ltbl2_items;
+			bytes_count = buf->size;
+
+			SSDFS_DBG("LOOKUP2 TABLE DUMP:\n");
+			print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+					     kaddr, bytes_count);
+			SSDFS_DBG("\n");
+		}
+
+		buf = &name_range->hash_table.buf;
+		if (buf->place.htbl_items) {
+			kaddr = (u8 *)buf->place.htbl_items;
+			bytes_count = buf->size;
+
+			SSDFS_DBG("HASH TABLE DUMP:\n");
+			print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+					     kaddr, bytes_count);
+			SSDFS_DBG("\n");
+		}
+
+		buf = &name_range->strings.buf;
+		if (buf->place.ptr) {
+			kaddr = buf->place.ptr;
+			bytes_count = buf->size;
+
+			SSDFS_DBG("STRINGS DUMP:\n");
+			print_hex_dump_bytes("", DUMP_PREFIX_OFFSET,
+					     kaddr, bytes_count);
+			SSDFS_DBG("\n");
+		}
+	}
+#endif /* CONFIG_SSDFS_DEBUG */
+}
+
+static inline
+void ssdfs_debug_show_areas_state(struct ssdfs_btree_node *node,
+				  struct ssdfs_btree_node_index_area *hash_tbl,
+				  struct ssdfs_btree_node_index_area *lookup_tbl,
+				  struct ssdfs_btree_node_items_area *items_area)
+{
+#ifdef CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK
+	struct ssdfs_shdict_ltbl2_item ltbl2_desc;
+	struct ssdfs_shdict_htbl_item hash_desc;
+	int i;
+
+	SSDFS_ERR("HASH TBL: (area_offset %u, area_size %u, "
+		  "index_size %u, index_count %u, "
+		  "index_capacity %u, start_hash %#llx, "
+		  "end_hash %#llx)\n",
+		  hash_tbl->offset, hash_tbl->area_size,
+		  hash_tbl->index_size, hash_tbl->index_count,
+		  hash_tbl->index_capacity,
+		  hash_tbl->start_hash, hash_tbl->end_hash);
+	SSDFS_ERR("LOOKUP TBL: (area_offset %u, area_size %u, "
+		  "index_size %u, index_count %u, "
+		  "index_capacity %u, start_hash %#llx, "
+		  "end_hash %#llx)\n",
+		  lookup_tbl->offset, lookup_tbl->area_size,
+		  lookup_tbl->index_size, lookup_tbl->index_count,
+		  lookup_tbl->index_capacity,
+		  lookup_tbl->start_hash, lookup_tbl->end_hash);
+	SSDFS_ERR("ITEMS AREA: (area_offset %u, area_size %u, "
+		  "item_size %u, min_item_size %u, "
+		  "max_item_size %u, items_count %u, "
+		  "items_capacity %u, start_hash %#llx, "
+		  "end_hash %#llx)\n",
+		  items_area->offset, items_area->area_size,
+		  items_area->item_size, items_area->min_item_size,
+		  items_area->max_item_size, items_area->items_count,
+		  items_area->items_capacity,
+		  items_area->start_hash, items_area->end_hash);
+
+	for (i = 0 ; i < lookup_tbl->index_count; i++) {
+		ssdfs_get_lookup2_descriptor(node, lookup_tbl,
+					     i, &ltbl2_desc);
+		SSDFS_ERR_DBG("LOOKUP TBL: "
+			      "node_id %u, index_count %u "
+			      "(index %u, hash %#llx)\n",
+			      node->node_id,
+			      lookup_tbl->index_count,
+			      i, le64_to_cpu(ltbl2_desc.hash));
+	}
+
+	for (i = 0 ; i < hash_tbl->index_count; i++) {
+		ssdfs_get_hash_descriptor(node, hash_tbl,
+					  i, &hash_desc);
+		SSDFS_ERR_DBG("HASH TBL: "
+			      "node_id %u, index_count %u, "
+			      "hash (index %u, hash %#llx)\n",
+			      node->node_id,
+			      hash_tbl->index_count,
+			      i, le64_to_cpu(hash_desc.hash));
+	}
+#endif /* CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK */
+}
+
+static inline
+void ssdfs_check_shdict_btree_node_area(struct ssdfs_btree_node *node,
+				struct ssdfs_btree_node_index_area *hash_tbl,
+				struct ssdfs_btree_node_index_area *lookup_tbl,
+				struct ssdfs_btree_node_items_area *items_area,
+				u16 index_count,
+				u64 start_hash, u64 end_hash,
+				get_search_key_func_t get_key)
+{
+#ifdef CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK
+	union ssdfs_shdict_search_key value;
+	u64 found_hash;
+	u64 prev_hash;
+	int i;
+	int err;
+
+	prev_hash = start_hash;
+	for (i = 0; i < index_count; i++) {
+		err = get_key(node, i, &value);
+		if (err)
+			break;
+
+		found_hash = le64_to_cpu(value.hash);
+
+		if (i == 0 && start_hash != found_hash) {
+			SSDFS_ERR("node %u is corrupted: index %d, "
+				  "start_hash %#llx != found_hash %#llx\n",
+				  node->node_id, i,
+				  start_hash, found_hash);
+			ssdfs_debug_show_areas_state(node,
+						     hash_tbl, lookup_tbl,
+						     items_area);
+			BUG();
+		}
+
+		if (i == (index_count - 1) && end_hash != found_hash) {
+			SSDFS_ERR("node %u is corrupted: index %d, "
+				  "end_hash %#llx != found_hash %#llx\n",
+				  node->node_id, i,
+				  end_hash, found_hash);
+			ssdfs_debug_show_areas_state(node,
+						     hash_tbl, lookup_tbl,
+						     items_area);
+			BUG();
+		}
+
+		if (found_hash < start_hash || found_hash > end_hash) {
+			SSDFS_ERR("node %u is corrupted: index %d, "
+				  "start_hash %#llx, end_hash %#llx, "
+				  "found_hash %#llx\n",
+				  node->node_id, i, start_hash,
+				  end_hash, found_hash);
+			ssdfs_debug_show_areas_state(node,
+						     hash_tbl, lookup_tbl,
+						     items_area);
+			BUG();
+		}
+
+		if (prev_hash > found_hash) {
+			SSDFS_ERR("node %u is corrupted: index %d, "
+				  "prev_hash %#llx > found_hash %#llx\n",
+				  node->node_id, i,
+				  prev_hash, found_hash);
+			ssdfs_debug_show_areas_state(node,
+						     hash_tbl, lookup_tbl,
+						     items_area);
+			BUG();
+		}
+
+		prev_hash = found_hash;
+	}
+#endif /* CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK */
+}
+
+#ifdef CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK
+static
+void ssdfs_check_shdict_btree_node_consistency(struct ssdfs_btree_node *node)
+{
+	struct ssdfs_btree_node_index_area lookup_tbl_area;
+	struct ssdfs_btree_node_index_area hash_tbl_area;
+	struct ssdfs_btree_node_items_area items_area;
+	struct ssdfs_shdict_htbl_item cur_desc;
+	u16 items_count;
+	u16 used_space;
+	u32 total_len = 0;
+	int i;
+	int err;
+
+	down_read(&node->full_lock);
+
+	down_read(&node->header_lock);
+	memcpy(&lookup_tbl_area, &node->lookup_tbl_area,
+		sizeof(struct ssdfs_btree_node_index_area));
+	memcpy(&hash_tbl_area, &node->hash_tbl_area,
+		sizeof(struct ssdfs_btree_node_index_area));
+	memcpy(&items_area, &node->items_area,
+		sizeof(struct ssdfs_btree_node_items_area));
+	up_read(&node->header_lock);
+
+	ssdfs_check_shdict_btree_node_area(node,
+					   &hash_tbl_area,
+					   &lookup_tbl_area,
+					   &items_area,
+					   hash_tbl_area.index_count,
+					   hash_tbl_area.start_hash,
+					   hash_tbl_area.end_hash,
+					   ssdfs_get_hash_table_search_key);
+
+	ssdfs_check_shdict_btree_node_area(node,
+					   &hash_tbl_area,
+					   &lookup_tbl_area,
+					   &items_area,
+					   lookup_tbl_area.index_count,
+					   lookup_tbl_area.start_hash,
+					   lookup_tbl_area.end_hash,
+					   ssdfs_get_lookup2_table_search_key);
+
+	items_count = hash_tbl_area.index_count;
+
+	if (items_area.area_size < items_area.free_space) {
+		SSDFS_ERR("corrupted items_area: "
+			  "node_id %u, area_size %u, free_space %u\n",
+			  node->node_id,
+			  items_area.area_size,
+			  items_area.free_space);
+		BUG();
+	}
+
+	used_space = items_area.area_size - items_area.free_space;
+
+	for (i = 0; i < items_count; i++) {
+		err = ssdfs_get_hash_descriptor(node, &hash_tbl_area,
+						i, &cur_desc);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get hash descriptor: "
+				  "node_id %u, index %u, err %d\n",
+				  node->node_id, i, err);
+			BUG();
+		}
+
+		if (total_len > used_space) {
+			SSDFS_ERR("corrupted items_area: "
+				  "node_id %u, index %u, "
+				  "total_len %u, used_space %u\n",
+				  node->node_id, i,
+				  total_len, used_space);
+			BUG();
+		}
+
+		total_len += cur_desc.str_len;
+	}
+
+	if (total_len != used_space) {
+		SSDFS_ERR("corrupted items_area: "
+			  "node_id %u, index %u, "
+			  "total_len %u, used_space %u\n",
+			  node->node_id, i,
+			  total_len, used_space);
+		BUG();
+	}
+
+	up_read(&node->full_lock);
+}
+#endif /* CONFIG_SSDFS_BTREE_STRICT_CONSISTENCY_CHECK */
+
+const struct ssdfs_btree_descriptor_operations
+				ssdfs_shared_dict_btree_desc_ops = {
+	.init		= ssdfs_shared_dict_btree_desc_init,
+	.flush		= ssdfs_shared_dict_btree_desc_flush,
+};
+
+const struct ssdfs_btree_operations ssdfs_shared_dict_btree_ops = {
+	.create_root_node	= ssdfs_shared_dict_btree_create_root_node,
+	.create_node		= ssdfs_shared_dict_btree_create_node,
+	.init_node		= ssdfs_shared_dict_btree_init_node,
+	.destroy_node		= ssdfs_shared_dict_btree_destroy_node,
+	.add_node		= ssdfs_shared_dict_btree_add_node,
+	.delete_node		= ssdfs_shared_dict_btree_delete_node,
+	.pre_flush_root_node	= ssdfs_shared_dict_btree_pre_flush_root_node,
+	.flush_root_node	= ssdfs_shared_dict_btree_flush_root_node,
+	.pre_flush_node		= ssdfs_shared_dict_btree_pre_flush_node,
+	.flush_node		= ssdfs_shared_dict_btree_flush_node,
+};
+
+const struct ssdfs_btree_node_operations ssdfs_shared_dict_btree_node_ops = {
+	.find_item		= ssdfs_shared_dict_btree_node_find_item,
+	.find_range		= ssdfs_shared_dict_btree_node_find_range,
+	.extract_range		= ssdfs_shared_dict_btree_node_extract_range,
+	.allocate_item		= ssdfs_shared_dict_btree_node_allocate_item,
+	.allocate_range		= ssdfs_shared_dict_btree_node_allocate_range,
+	.insert_item		= ssdfs_shared_dict_btree_node_insert_item,
+	.insert_range		= ssdfs_shared_dict_btree_node_insert_range,
+	.change_item		= ssdfs_shared_dict_btree_node_change_item,
+	.delete_item		= ssdfs_shared_dict_btree_node_delete_item,
+	.delete_range		= ssdfs_shared_dict_btree_node_delete_range,
+	.resize_items_area	= ssdfs_shared_dict_btree_resize_items_area,
+};
diff --git a/fs/ssdfs/shared_dictionary_thread.c b/fs/ssdfs/shared_dictionary_thread.c
new file mode 100644
index 000000000000..991082a22abc
--- /dev/null
+++ b/fs/ssdfs/shared_dictionary_thread.c
@@ -0,0 +1,457 @@
+/*
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ *
+ * SSDFS -- SSD-oriented File System.
+ *
+ * fs/ssdfs/shared_dictionary_thread.c - shared dictionary tree's thread impl.
+ *
+ * Copyright (c) 2014-2019 HGST, a Western Digital Company.
+ *              http://www.hgst.com/
+ * Copyright (c) 2014-2026 Viacheslav Dubeyko <slava@dubeyko.com>
+ *              http://www.ssdfs.org/
+ *
+ * (C) Copyright 2014-2019, HGST, Inc., All rights reserved.
+ *
+ * Created by HGST, San Jose Research Center, Storage Architecture Group
+ *
+ * Authors: Viacheslav Dubeyko <slava@dubeyko.com>
+ *
+ * Acknowledgement: Cyril Guyot
+ *                  Zvonimir Bandic
+ */
+
+#include <linux/kernel.h>
+#include <linux/rwsem.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/pagevec.h>
+
+#include "peb_mapping_queue.h"
+#include "peb_mapping_table_cache.h"
+#include "folio_vector.h"
+#include "ssdfs.h"
+#include "btree_search.h"
+#include "btree_node.h"
+#include "btree.h"
+#include "shared_dictionary.h"
+
+#include <trace/events/ssdfs.h>
+
+/*
+ * has_queue_unprocessed_names() - is requests queue empty?
+ * @tree: shared dictionary tree's object
+ */
+bool has_queue_unprocessed_names(struct ssdfs_shared_dict_btree_info *tree)
+{
+	struct ssdfs_names_queue *queue;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	queue = &tree->requests.queue;
+	return !is_ssdfs_names_queue_empty(queue);
+}
+
+/*
+ * ssdfs_shared_dict_pre_fetch_nodes() - pre-fetch root node's child nodes
+ * @tree: shared dictionary tree's object
+ * @ptr: requests queue
+ */
+static
+int ssdfs_shared_dict_pre_fetch_nodes(struct ssdfs_shared_dict_btree_info *tree,
+				      struct ssdfs_name_requests_queue *ptr)
+{
+	struct ssdfs_name_info *ni = NULL;
+	int req_type = SSDFS_INIT_SHDICT_NODE;
+	struct ssdfs_btree_node *parent, *child;
+	int initialized_nodes = 0;
+	u64 hash;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree || !ptr);
+
+	SSDFS_DBG("tree %p, queue %p\n",
+		  tree, ptr);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	do {
+		err = ssdfs_names_queue_remove_first(&ptr->queue, &ni);
+		if (err == -ENODATA) {
+			if (initialized_nodes == 0) {
+				SSDFS_WARN("empty queue\n");
+				return err;
+			} else {
+				/* finish initialization */
+				err = 0;
+				goto finish_init;
+			}
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to get name: err %d\n",
+				  err);
+			goto finish_init;
+		} else if (ni == NULL) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid name info\n");
+			goto finish_init;
+		}
+
+		req_type = ni->type;
+
+		if (req_type != SSDFS_INIT_SHDICT_NODE) {
+			ssdfs_names_queue_add_head(&ptr->queue, ni);
+
+			if (initialized_nodes == 0) {
+				err = -ERANGE;
+				SSDFS_WARN("queue hasn't init requests\n");
+			}
+
+			goto finish_init;
+		}
+
+		hash = le64_to_cpu(ni->desc.index.hash);
+
+		down_write(&tree->lock);
+		down_write(&tree->generic_tree.lock);
+
+		err = ssdfs_btree_radix_tree_find(&tree->generic_tree,
+						  SSDFS_BTREE_ROOT_NODE_ID,
+						  &parent);
+		if (unlikely(err)) {
+			SSDFS_ERR("fail to get the root node: err %d\n",
+				  err);
+			goto finish_read_child_node;
+		} else if (unlikely(!parent)) {
+			err = -ERANGE;
+			SSDFS_WARN("empty node pointer\n");
+			goto finish_read_child_node;
+		}
+
+		child = ssdfs_btree_get_child_node_for_hash(&tree->generic_tree,
+							    parent, hash);
+		if (IS_ERR_OR_NULL(child)) {
+			err = !child ? -ERANGE : PTR_ERR(child);
+			SSDFS_ERR("fail to get the child node: err %d\n",
+				  err);
+			goto finish_read_child_node;
+		}
+
+finish_read_child_node:
+		up_write(&tree->generic_tree.lock);
+		up_write(&tree->lock);
+
+		if (unlikely(err))
+			goto finish_init;
+
+		initialized_nodes++;
+	} while (req_type == SSDFS_INIT_SHDICT_NODE);
+
+finish_init:
+	return err;
+}
+
+#define SHDICT_PTR(tree) \
+	((struct ssdfs_shared_dict_btree_info *)(tree))
+#define SHDICT_THREAD_WAKE_CONDITION(tree) \
+	(kthread_should_stop() || \
+	 has_queue_unprocessed_names(SHDICT_PTR(tree)))
+#define SHDICT_FAILED_THREAD_WAKE_CONDITION() \
+	(kthread_should_stop())
+
+/*
+ * ssdfs_shared_dict_thread_func() - shared dictionary object's thread's func
+ */
+static
+int ssdfs_shared_dict_thread_func(void *data)
+{
+	struct ssdfs_shared_dict_btree_info *tree = data;
+	wait_queue_head_t *wait_queue = NULL;
+	struct ssdfs_name_requests_queue *ptr = NULL;
+	struct ssdfs_btree_search *search = NULL;
+	int read_reqs;
+	int err = 0;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	if (!tree) {
+		SSDFS_ERR("pointer on shared dictionary tree is NULL\n");
+		BUG();
+	}
+
+	SSDFS_DBG("shared dictionary tree's thread\n");
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	wait_queue = &tree->wait_queue;
+	ptr = &tree->requests;
+
+	search = ssdfs_btree_search_alloc();
+	if (!search) {
+		err = -ENOMEM;
+		SSDFS_ERR("fail to allocate btree search object\n");
+		goto sleep_failed_shared_dict_thread;
+	}
+
+repeat:
+	if (unlikely(err)) {
+		wake_up_all(&tree->wait_queue);
+
+		if (kthread_should_stop())
+			goto finish_thread;
+		else
+			goto sleep_failed_shared_dict_thread;
+	}
+
+	if (kthread_should_stop()) {
+		if (has_queue_unprocessed_names(tree))
+			goto try_process_queue;
+
+finish_thread:
+		complete_all(&ptr->thread.full_stop);
+		if (search)
+			ssdfs_btree_search_free(search);
+		return err;
+	}
+
+	if (tree->generic_tree.fsi->sb->s_flags & SB_RDONLY)
+		goto sleep_shared_dict_thread;
+
+	if (!has_queue_unprocessed_names(tree))
+		goto sleep_shared_dict_thread;
+
+try_process_queue:
+	do {
+		struct ssdfs_name_info *ni = NULL;
+
+		switch (atomic_read(&tree->state)) {
+		case SSDFS_SHDICT_BTREE_UNDER_INIT:
+			err = ssdfs_shared_dict_pre_fetch_nodes(tree, ptr);
+			if (unlikely(err)) {
+				atomic_set(&tree->state,
+					   SSDFS_SHDICT_BTREE_CORRUPTED);
+				ssdfs_fs_error(tree->generic_tree.fsi->sb,
+						__FILE__, __func__, __LINE__,
+						"fail to initialize nodes\n");
+				wake_up_all(&tree->wait_queue);
+				goto repeat;
+			} else {
+				atomic_set(&tree->state,
+					   SSDFS_SHDICT_BTREE_INITIALIZED);
+				wake_up_all(&tree->wait_queue);
+			}
+			break;
+
+		case SSDFS_SHDICT_BTREE_CORRUPTED:
+			err = -EFAULT;
+			ssdfs_fs_error(tree->generic_tree.fsi->sb,
+					__FILE__, __func__, __LINE__,
+					"shared dictionary is corrupted\n");
+			goto repeat;
+
+		case SSDFS_SHDICT_BTREE_CREATED:
+		case SSDFS_SHDICT_BTREE_INITIALIZED:
+			/* continue to work */
+			break;
+
+		default:
+			err = -EFAULT;
+			ssdfs_fs_error(tree->generic_tree.fsi->sb,
+					__FILE__, __func__, __LINE__,
+					"invalid shared dictionary state %#x\n",
+					atomic_read(&tree->state));
+			goto repeat;
+		}
+
+		read_reqs = atomic_read(&tree->read_reqs);
+		if (read_reqs > 0)
+			goto sleep_shared_dict_thread;
+
+		if (!has_queue_unprocessed_names(tree))
+			goto sleep_shared_dict_thread;
+
+		err = ssdfs_names_queue_remove_first(&ptr->queue, &ni);
+		if (err == -ENODATA) {
+			err = 0;
+			goto sleep_shared_dict_thread;
+		} else if (unlikely(err)) {
+			SSDFS_ERR("fail to get name: err %d\n", err);
+			goto repeat;
+		} else if (ni == NULL) {
+			err = -ERANGE;
+			SSDFS_ERR("invalid name info\n");
+			goto repeat;
+		}
+
+		switch (ni->type) {
+		case SSDFS_NAME_ADD:
+			ssdfs_btree_search_init(search);
+
+			down_write(&tree->lock);
+			err = ssdfs_shared_dict_tree_add(tree,
+							 ni->desc.name.hash,
+							 ni->desc.name.str_buf,
+							 ni->desc.name.len,
+							 search);
+			up_write(&tree->lock);
+
+			if (err == -EEXIST) {
+				/* name exist -> do nothing */
+				err = 0;
+				ssdfs_name_info_free(ni);
+				continue;
+			} else if (unlikely(err)) {
+				ssdfs_fs_error(tree->generic_tree.fsi->sb,
+						__FILE__, __func__, __LINE__,
+						"fail to add name: "
+						"hash %llx, name %s, len %zu, "
+						"err %d\n",
+						ni->desc.name.hash,
+						ni->desc.name.str_buf,
+						ni->desc.name.len,
+						err);
+				ssdfs_name_info_free(ni);
+				goto repeat;
+			} else
+				ssdfs_name_info_free(ni);
+			break;
+
+		case SSDFS_NAME_CHANGE:
+		case SSDFS_NAME_DELETE:
+			SSDFS_ERR("unsupported operation: "
+				  "type %#x, hash %llx, len %zu\n",
+				  ni->type,
+				  ni->desc.name.hash,
+				  ni->desc.name.len);
+			ssdfs_name_info_free(ni);
+			break;
+
+		default:
+			SSDFS_ERR("invalid operation type: "
+				  "type %#x, hash %llx, len %zu\n",
+				  ni->type,
+				  ni->desc.name.hash,
+				  ni->desc.name.len);
+			ssdfs_name_info_free(ni);
+			break;
+		};
+	} while (has_queue_unprocessed_names(tree));
+
+	if (kthread_should_stop())
+		goto repeat;
+
+sleep_shared_dict_thread:
+	wake_up_all(&tree->wait_queue);
+	DEFINE_WAIT_FUNC(wait, woken_wake_function);
+	add_wait_queue(wait_queue, &wait);
+	while (!SHDICT_THREAD_WAKE_CONDITION(tree)) {
+		if (signal_pending(current)) {
+			break;
+		} else {
+			wait_woken(&wait, TASK_INTERRUPTIBLE,
+				   SSDFS_DEFAULT_TIMEOUT);
+		}
+	}
+	remove_wait_queue(wait_queue, &wait);
+	goto repeat;
+
+sleep_failed_shared_dict_thread:
+	wake_up_all(&tree->wait_queue);
+	wait_event_interruptible(*wait_queue,
+			SHDICT_FAILED_THREAD_WAKE_CONDITION());
+	goto repeat;
+}
+
+static
+struct ssdfs_thread_descriptor thread_desc[1] = {
+	{.threadfn = ssdfs_shared_dict_thread_func,
+	 .fmt = "ssdfs-shared-dict",},
+};
+
+/*
+ * ssdfs_shared_dict_start_thread() - start shared dictionary tree's thread
+ * @tree: shared dictionary tree's object
+ */
+int ssdfs_shared_dict_start_thread(struct ssdfs_shared_dict_btree_info *tree)
+{
+	struct ssdfs_name_requests_queue *ptr;
+	ssdfs_threadfn threadfn;
+	const char *fmt;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree);
+
+	SSDFS_DBG("tree %p\n", tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	threadfn = thread_desc[0].threadfn;
+	fmt = thread_desc[0].fmt;
+
+	ptr = &tree->requests;
+	ptr->thread.task = kthread_create(threadfn, tree, fmt);
+	if (IS_ERR_OR_NULL(ptr->thread.task)) {
+		err = (ptr->thread.task == NULL ? -ENOMEM :
+						PTR_ERR(ptr->thread.task));
+		if (err == -EINTR) {
+			/*
+			 * Ignore this error.
+			 */
+		} else {
+			if (err == 0)
+				err = -ERANGE;
+			SSDFS_ERR("fail to start shared extents tree's thread: "
+				  "err %d\n", err);
+		}
+
+		return err;
+	}
+
+	init_waitqueue_entry(&ptr->thread.wait, ptr->thread.task);
+	add_wait_queue(&tree->wait_queue, &ptr->thread.wait);
+	init_completion(&ptr->thread.full_stop);
+
+	wake_up_process(ptr->thread.task);
+
+	return 0;
+}
+
+/*
+ * ssdfs_shared_dict_stop_thread() - stop shared dictionary tree's thread
+ * @tree: shared dictionary tree's object
+ */
+int ssdfs_shared_dict_stop_thread(struct ssdfs_shared_dict_btree_info *tree)
+{
+	struct ssdfs_name_requests_queue *ptr;
+	int err;
+
+#ifdef CONFIG_SSDFS_DEBUG
+	BUG_ON(!tree);
+#endif /* CONFIG_SSDFS_DEBUG */
+
+	ptr = &tree->requests;
+	if (!ptr->thread.task)
+		return 0;
+
+	err = kthread_stop(ptr->thread.task);
+	if (err == -EINTR) {
+		/*
+		 * Ignore this error.
+		 * The wake_up_process() was never called.
+		 */
+		return 0;
+	} else if (unlikely(err)) {
+		SSDFS_WARN("thread function had some issue: err %d\n",
+			    err);
+		return err;
+	}
+
+	finish_wait(&tree->wait_queue, &ptr->thread.wait);
+	ptr->thread.task = NULL;
+
+	err = SSDFS_WAIT_COMPLETION(&ptr->thread.full_stop);
+	if (unlikely(err)) {
+		SSDFS_ERR("stop thread fails: err %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
-- 
2.34.1

